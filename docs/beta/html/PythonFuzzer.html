
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Testing Compilers &#8212; The Fuzzing Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=42e1b1a5" />
    <link rel="stylesheet" type="text/css" href="_static/mastodon-timeline.css?v=f82c2b23" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'PythonFuzzer';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Testing Web Applications" href="WebFuzzer.html" />
    <link rel="prev" title="Carving Unit Tests" href="Carver.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>
<aside class="bd-header-announcement" aria-label="Announcement">
  <div class="bd-header-announcement__content"><p>This is a beta version of fuzzingbook.org, currently in development. See the <a href="https://fuzzingbook.org/"  style="color:white!important;">classic site</a> for resources.</p></div>
</aside>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/fuzzingbook.png" class="logo__image only-light" alt="The Fuzzing Book - Home"/>
    <script>document.write(`<img src="_static/fuzzingbook.png" class="logo__image only-dark" alt="The Fuzzing Book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    The Fuzzing Book
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tours.html">Tours through the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="Intro_Testing.html">Introduction to Software Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lexical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Fuzzer.html">Fuzzing: Breaking Things with Random Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Coverage.html">Code Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationFuzzer.html">Mutation-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GreyboxFuzzer.html">Greybox Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SearchBasedFuzzer.html">Search-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationAnalysis.html">Mutation Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Syntactical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Grammars.html">Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarFuzzer.html">Efficient Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarCoverageFuzzer.html">Grammar Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parser.html">Parsing Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="ProbabilisticGrammarFuzzer.html">Probabilistic Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeneratorGrammarFuzzer.html">Fuzzing with Generators</a></li>

<li class="toctree-l1"><a class="reference internal" href="GreyboxGrammarFuzzer.html">Greybox Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reducer.html">Reducing Failure-Inducing Inputs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Semantical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingWithConstraints.html">Fuzzing with Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarMiner.html">Mining Input Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="InformationFlow.html">Tracking Information Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConcolicFuzzer.html">Concolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SymbolicFuzzer.html">Symbolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DynamicInvariants.html">Mining Function Specifications</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Domain-Specific Fuzzing</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ConfigurationFuzzer.html">Testing Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="APIFuzzer.html">Fuzzing APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Carver.html">Carving Unit Tests</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Testing Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="WebFuzzer.html">Testing Web Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="GUIFuzzer.html">Testing Graphical User Interfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Managing Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingInTheLarge.html">Fuzzing in the Large</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhenToStopFuzzing.html">When To Stop Fuzzing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="AcademicPrototyping.html">Academic Prototyping</a></li>
<li class="toctree-l1"><a class="reference internal" href="PrototypingWithPython.html">Prototyping with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExpectError.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timer.html">Timer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timeout.html">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="ClassDiagram.html">Class Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="RailroadDiagrams.html">Railroad Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="ControlFlow.html">Control Flow Graph</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About This Book</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ReleaseNotes.html">Fuzzingbook Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Importing.html">Using Fuzzingbook Code in your own Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Guide_for_Authors.html">Guide for Authors</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?urlpath=tree/docs/notebooks/PythonFuzzer.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook/issues/new?title=Issue%20on%20page%20%2FPythonFuzzer.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/PythonFuzzer.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Testing Compilers</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-grammar-for-concrete-code">A Grammar for Concrete Code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#abstract-syntax-trees">Abstract Syntax Trees</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-grammar-for-asts">A Grammar for ASTs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constants">Constants</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-composites">Excursion: Composites</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-excursion">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-expressions">Excursion: Expressions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-names-and-function-calls">Excursion: Names and Function Calls</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-attributes-and-subscripts">Excursion: Attributes and Subscripts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-variable-assignments">Excursion: Variable Assignments</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-statements">Excursion: Statements</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-function-definitions">Excursion: Function Definitions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-modules">Excursion: Modules</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-class-for-fuzzing-python">A Class for Fuzzing Python</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#customizing-the-python-fuzzer">Customizing the Python Fuzzer</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adjusting-the-grammar">Adjusting the Grammar</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-constraints-for-customizing">Using Constraints for Customizing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mutating-code">Mutating Code</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-inputs">Parsing Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mutating-inputs">Mutating Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-effective-is-mutation">How Effective is Mutation?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#evolutionary-fuzzing">Evolutionary Fuzzing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-coverage">Getting Coverage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fitness">Fitness</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#evolving-inputs">Evolving Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#survival-of-the-fittest">Survival of the Fittest</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#evolution">Evolution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chances-of-evolutionary-fuzzing">Chances of Evolutionary Fuzzing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="testing-compilers">
<h1>Testing Compilers<a class="headerlink" href="#testing-compilers" title="Link to this heading">#</a></h1>
<p>In this chapter, we will make use of <a class="reference internal" href="Grammars.html"><span class="std std-doc">grammars and grammar-based testing</span></a> to systematically generate <em>program code</em> – for instance, to test a compiler or an interpreter. Not very surprisingly, we use <em>Python</em> and the <em>Python interpreter</em> as our domain.</p>
<p>We chose Python not only because the rest of the book is also based on Python.
Most importantly, Python brings lots of built-in infrastructure we can leverage, especially</p>
<ul class="simple">
<li><p><em>parsers</em> that convert Python code into an abstract syntax tree (AST) representation and</p></li>
<li><p><em>unparsers</em> that take an AST and convert it back into Python code.</p></li>
</ul>
<p>This allows us to leverage grammars that operate on ASTs rather than concrete syntax, greatly reducing complexity.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;Nr1xbKj_WRQ&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="640"
            height="360"
            src="https://www.youtube-nocookie.com/embed/Nr1xbKj_WRQ"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
<p><strong>Prerequisites</strong></p>
<ul class="simple">
<li><p>You must read the chapter on <a class="reference internal" href="Grammars.html"><span class="std std-doc">Fuzzing with Grammars</span></a> to understand how grammars and grammar-based testing work.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">import</span> <span class="nn">sys</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This code requires Python 3.10 or later&quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<section id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Link to this heading">#</a></h2>
<!-- Automatically generated. Do not edit. -->
<p>To <a class="reference internal" href="Importing.html"><span class="std std-doc">use the code provided in this chapter</span></a>, write</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fuzzingbook.PythonFuzzer</span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>and then make use of the following features.</p>
<p>This chapter provides a <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> class that allows producing arbitrary Python code elements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
<span class="go">def R():</span>
<span class="go">    break</span>

</pre></div>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> produces a <em>function definition</em> – that is, a list of statements as above.
You can pass a <code class="docutils literal notranslate"><span class="pre">start_symbol</span></code> argument to state which Python element you’d like to have:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="s1">&#39;&lt;While&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
<span class="go">while {set()[set():set():set()]}:</span>
<span class="go">    C = set()</span>
<span class="go">    D @= set()</span>
<span class="go">    break</span>
<span class="go">else:</span>
<span class="go">    return</span>

</pre></div>
</div>
<p>Here is a list of all possible start symbols. Their names reflect the nonterminals from the <a class="reference external" href="https://docs.python.org/3/library/ast.html">Python <code class="docutils literal notranslate"><span class="pre">ast</span></code> module documentation</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="go">[&#39;&lt;Assert&gt;&#39;,</span>
<span class="go"> &#39;&lt;Assign&gt;&#39;,</span>
<span class="go"> &#39;&lt;Attribute&gt;&#39;,</span>
<span class="go"> &#39;&lt;AugAssign&gt;&#39;,</span>
<span class="go"> &#39;&lt;BinOp&gt;&#39;,</span>
<span class="go"> &#39;&lt;BoolOp&gt;&#39;,</span>
<span class="go"> &#39;&lt;Break&gt;&#39;,</span>
<span class="go"> &#39;&lt;Call&gt;&#39;,</span>
<span class="go"> &#39;&lt;Compare&gt;&#39;,</span>
<span class="go"> &#39;&lt;Constant&gt;&#39;,</span>
<span class="go"> &#39;&lt;Continue&gt;&#39;,</span>
<span class="go"> &#39;&lt;Delete&gt;&#39;,</span>
<span class="go"> &#39;&lt;Dict&gt;&#39;,</span>
<span class="go"> &#39;&lt;EmptySet&gt;&#39;,</span>
<span class="go"> &#39;&lt;Expr&gt;&#39;,</span>
<span class="go"> &#39;&lt;For&gt;&#39;,</span>
<span class="go"> &#39;&lt;FunctionDef&gt;&#39;,</span>
<span class="go"> &#39;&lt;If&gt;&#39;,</span>
<span class="go"> &#39;&lt;List&gt;&#39;,</span>
<span class="go"> &#39;&lt;Module&gt;&#39;,</span>
<span class="go"> &#39;&lt;Name&gt;&#39;,</span>
<span class="go"> &#39;&lt;Pass&gt;&#39;,</span>
<span class="go"> &#39;&lt;Return&gt;&#39;,</span>
<span class="go"> &#39;&lt;Set&gt;&#39;,</span>
<span class="go"> &#39;&lt;Slice&gt;&#39;,</span>
<span class="go"> &#39;&lt;Starred&gt;&#39;,</span>
<span class="go"> &#39;&lt;Subscript&gt;&#39;,</span>
<span class="go"> &#39;&lt;Tuple&gt;&#39;,</span>
<span class="go"> &#39;&lt;UnaryOp&gt;&#39;,</span>
<span class="go"> &#39;&lt;While&gt;&#39;,</span>
<span class="go"> &#39;&lt;With&gt;&#39;,</span>
<span class="go"> &#39;&lt;arg&gt;&#39;,</span>
<span class="go"> &#39;&lt;arg_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;args&gt;&#39;,</span>
<span class="go"> &#39;&lt;args_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;arguments&gt;&#39;,</span>
<span class="go"> &#39;&lt;bool&gt;&#39;,</span>
<span class="go"> &#39;&lt;boolop&gt;&#39;,</span>
<span class="go"> &#39;&lt;cmpop&gt;&#39;,</span>
<span class="go"> &#39;&lt;cmpop_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;cmpops&gt;&#39;,</span>
<span class="go"> &#39;&lt;decorator_list_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;defaults_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;digit&gt;&#39;,</span>
<span class="go"> &#39;&lt;digits&gt;&#39;,</span>
<span class="go"> &#39;&lt;expr&gt;&#39;,</span>
<span class="go"> &#39;&lt;expr_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;exprs&gt;&#39;,</span>
<span class="go"> &#39;&lt;float&gt;&#39;,</span>
<span class="go"> &#39;&lt;func&gt;&#39;,</span>
<span class="go"> &#39;&lt;id&gt;&#39;,</span>
<span class="go"> &#39;&lt;id_continue&gt;&#39;,</span>
<span class="go"> &#39;&lt;id_start&gt;&#39;,</span>
<span class="go"> &#39;&lt;identifier&gt;&#39;,</span>
<span class="go"> &#39;&lt;integer&gt;&#39;,</span>
<span class="go"> &#39;&lt;keyword&gt;&#39;,</span>
<span class="go"> &#39;&lt;keyword_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;keywords&gt;&#39;,</span>
<span class="go"> &#39;&lt;keywords_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;kw_defaults_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;kwarg&gt;&#39;,</span>
<span class="go"> &#39;&lt;kwonlyargs_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_Attribute&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_List&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_Name&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_Starred&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_Subscript&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_Tuple&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_expr&gt;&#39;,</span>
<span class="go"> &#39;&lt;lhs_exprs&gt;&#39;,</span>
<span class="go"> &#39;&lt;literal&gt;&#39;,</span>
<span class="go"> &#39;&lt;mod&gt;&#39;,</span>
<span class="go"> &#39;&lt;none&gt;&#39;,</span>
<span class="go"> &#39;&lt;nonempty_expr_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;nonempty_lhs_expr_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;nonempty_stmt_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;nonzerodigit&gt;&#39;,</span>
<span class="go"> &#39;&lt;not_double_quotes&gt;&#39;,</span>
<span class="go"> &#39;&lt;not_single_quotes&gt;&#39;,</span>
<span class="go"> &#39;&lt;operator&gt;&#39;,</span>
<span class="go"> &#39;&lt;orelse_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;posonlyargs_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;returns&gt;&#39;,</span>
<span class="go"> &#39;&lt;start&gt;&#39;,</span>
<span class="go"> &#39;&lt;stmt&gt;&#39;,</span>
<span class="go"> &#39;&lt;stmt_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;stmts&gt;&#39;,</span>
<span class="go"> &#39;&lt;string&gt;&#39;,</span>
<span class="go"> &#39;&lt;type_comment&gt;&#39;,</span>
<span class="go"> &#39;&lt;type_ignore&gt;&#39;,</span>
<span class="go"> &#39;&lt;type_ignore_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;type_ignore_param&gt;&#39;,</span>
<span class="go"> &#39;&lt;type_ignores&gt;&#39;,</span>
<span class="go"> &#39;&lt;unaryop&gt;&#39;,</span>
<span class="go"> &#39;&lt;vararg&gt;&#39;,</span>
<span class="go"> &#39;&lt;withitem&gt;&#39;,</span>
<span class="go"> &#39;&lt;withitem_list&gt;&#39;,</span>
<span class="go"> &#39;&lt;withitems&gt;&#39;]</span>
</pre></div>
</div>
<p>If you’d like more control over Python code generation, here is what is happening behind the scenes.
The EBNF grammar <code class="docutils literal notranslate"><span class="pre">PYTHON_AST_GRAMMAR</span></code> can parse and produce <em>abstract syntax trees</em> for Python.
To produce a Python module without <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code>, you would take these steps:</p>
<p><strong>Step 1:</strong> Create a non-EBNF grammar suitable for <code class="docutils literal notranslate"><span class="pre">ISLaSolver</span></code> (or any other grammar fuzzer):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">python_ast_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Step 2:</strong>  Feed the resulting grammar into a grammar fuzzer such as ISLa:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Step 3:</strong>  Have the grammar fuzzer produce a string. This string represents an AST.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast_string</span>
<span class="go">&#39;FunctionDef(name=\&#39;y\&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])&#39;</span>
</pre></div>
</div>
<p><strong>Step 4:</strong>  Convert the AST into an actual Python AST data structure.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">abstract_syntax_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">ast_string</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Step 5:</strong> Finally, convert the AST structure back into readable Python code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">))</span>
<span class="go">@set()</span>
<span class="go">def y():</span>
<span class="go">    return</span>

</pre></div>
</div>
<p>The chapter has many more applications, including parsing and mutating Python code, evolutionary fuzzing, and more.</p>
<p>Here are the details on the <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> constructor:</p>
<p><code>PythonFuzzer(self, start_symbol: Optional[str] = None, *, grammar: Optional[Dict[str, List[Union[str, Tuple[str, Dict[str, Any]]]]]] = None, constraint: Optional[str] = None, **kw_params) -&gt; None</code></p>
<p>Produce Python code. Parameters are:</p>
<ul>
<li><code>start_symbol</code>: The grammatical entity to be generated (default: <code>&lt;FunctionDef&gt;</code>)</li>
<li><code>grammar</code>: The EBNF grammar to be used (default: <code>PYTHON__AST_GRAMMAR</code>); and</li>
<li><code>constraint</code> an ISLa constraint (if any).</li>
</ul>
<p>Additional keyword parameters are passed to the <code>ISLaSolver</code> superclass.</p>
<p><img alt="" src="_images/PythonFuzzer-synopsis-1.svg" /></p>
</section>
<section id="a-grammar-for-concrete-code">
<h2>A Grammar for Concrete Code<a class="headerlink" href="#a-grammar-for-concrete-code" title="Link to this heading">#</a></h2>
<p>To <em>produce</em> code, it is fairly easy to write a grammar with <em>concrete</em> syntax. If we want to produce, say, arithmetic expressions, we can easily create a concrete grammar which does precisely that.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bookutils.setup</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">Grammar</span>
<span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">convert_ebnf_grammar</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">trim_grammar</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
</pre></div>
</div>
</div>
</div>
<p>We use the <a class="reference external" href="https://www.fuzzingbook.org/html/Grammars.html">Fuzzingbook format for grammars</a>, in which grammars are represented as dictionaries from symbols to lists of expansion alternatives.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EXPR_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;term&gt; + &lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;term&gt; - &lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;factor&gt; * &lt;term&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt; / &lt;term&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;+&lt;factor&gt;&quot;</span><span class="p">,</span>
         <span class="s2">&quot;-&lt;factor&gt;&quot;</span><span class="p">,</span>
         <span class="s2">&quot;(&lt;expr&gt;)&quot;</span><span class="p">,</span>
         <span class="s2">&quot;&lt;integer&gt;.&lt;integer&gt;&quot;</span><span class="p">,</span>
         <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can use this grammar to produce syntactically valid arithmetic expressions.
We use the <a class="reference internal" href="FuzzingWithConstraints.html"><span class="std std-doc">ISLa solver</span></a> as our generator, as it is the most powerful; but we could also use any other of our grammar fuzzers such as <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">GrammarFuzzer</span></a> at this point.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">isla.solver</span> <span class="kn">import</span> <span class="n">ISLaSolver</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<p>Here are some concrete inputs produced from the grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">expr_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4.3 + 512 / -(7 / 6 - 0 / 9 * 1 * 1) * +8.3 / 7 * 4 / 6
(4 / 7 + 1) / (4) / 9 / 8 + 4 / (3 + 6 - 7)
+--(--(-9) * (4 * 7 + (4) + 4) + --(+(3)) - 6 + 0 / 7 + 7)
(2 * 6 + 0 - 5) * 4 - +1 * (2 - 2) / 8 / 6
(+-(0 - (1) * 7 / 3)) / ((1 * 3 + 8) + 9 - +1 / --0) - 5 * (-+939.491)
+2.9 * 0 / 501.19814 / --+--(6.05002)
+-8.8 / (1) * -+1 + -8 + 9 - 3 / 8 * 6 + 4 * 3 * 5
(+(8 / 9 - 1 - 7)) + ---06.30 / +4.39
8786.82 - +01.170 / 9.2 - +(7) + 1 * 9 - 0
+-6 * 0 / 5 * (-(1.7 * +(-1 / +4.9 * 5 * 1 * 2) + -4.2 + (6 + -5) / (4 * 3 + 4)))
</pre></div>
</div>
</div>
</div>
<p>We could extend the grammar further to also produce assignments and other statements, and piece by piece cover the entire syntax of the programming language. However, this would be a not-so-great idea. Why?</p>
<p>The problem is that when testing <em>compilers</em>, you not only want to be able to <em>produce</em> code, but also to <em>parse</em> code, such that you can mutate and manipulate it at will. And this is where our “concrete” syntax will give us problems. While we can easily parse code (or expressions) that exactly adheres to the syntax…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;2 + 2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>… a single space will already suffice to make it fail…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;2 +  2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Error parsing &quot;2 +  2&quot; starting with &quot;&lt;start&gt;&quot;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>… as does the absence of spaces:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;2+2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Error parsing &quot;2+2&quot; starting with &quot;&lt;start&gt;&quot;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>Indeed, spaces are optional in most programming languages. We <em>could</em> update our grammar such that it can handle optional spaces at all times (introducing a <code class="docutils literal notranslate"><span class="pre">&lt;space&gt;</span></code> nonterminal). But then, there are other features like <em>comments</em>…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;2 + 2    # should be 4&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Error parsing &quot;2 + 2    # should be 4&quot; starting with &quot;&lt;start&gt;&quot;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>… or <em>continuation lines</em> …</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;2 + </span><span class="se">\\\n</span><span class="s1">2&#39;</span><span class="p">)</span>  <span class="c1"># An expression split over two lines</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Error parsing &quot;2 + \
2&quot; starting with &quot;&lt;start&gt;&quot;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>that our grammar would have to cover.</p>
<p>On top, there are language features that cannot be even represented properly in a context-free grammar:</p>
<ul class="simple">
<li><p>In the C programming language, for instance, the parser needs to know whether an identifier has been defined as a <em>type</em></p></li>
<li><p>In Python, <em>indentation</em> levels cannot be represented by a context-free grammar.</p></li>
</ul>
<p>For this reason, it is often a good idea to make use of a dedicated <em>parser</em> (or <em>preprocessor</em>) to turn input into a more <em>abstract</em> representation - typically a <em>tree</em> structure. In programming languages, such a tree is called an <em>abstract syntax tree</em> (AST); it is the data structure that compilers operate on.</p>
</section>
<section id="abstract-syntax-trees">
<h2>Abstract Syntax Trees<a class="headerlink" href="#abstract-syntax-trees" title="Link to this heading">#</a></h2>
<p>Abstract Syntax Trees (ASTs) that represent program code are among the most complex data structures in the world (if not <em>the</em> most complex data structures) - notably because they reflect all the complexity of the programming language and its features.
The good news is that in Python, working with ASTs is particularly easy - one can work with them using standard language features.</p>
<p>Let us illustrate ASTs using an example. Here is a piece of code that we’d like to work with:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hello, world!&quot;</span><span class="p">)</span>  <span class="c1"># A simple example</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Hello, world!
</pre></div>
</div>
</div>
</div>
<p>Let us obtain the source code of this function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">inspect</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">main_source</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">main_source</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def main():
    print(&quot;Hello, world!&quot;)  # A simple example
</pre></div>
</div>
</div>
</div>
<p>We make use of the <a class="reference external" href="https://docs.python.org/3/library/ast.html">Python AST module</a> to convert this code string to an AST and back.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ast</span>
</pre></div>
</div>
</div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">ast.parse()</span></code>, we can parse the <code class="docutils literal notranslate"><span class="pre">main()</span></code> source into an AST:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">main_tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">main_source</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This is what this tree looks like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">show_ast</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">show_ast</span><span class="p">(</span><span class="n">main_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1c732affe04861dc28a5ea69e0c34dd4701f547d5c520ae442a30dbcd48788d5.svg" src="_images/1c732affe04861dc28a5ea69e0c34dd4701f547d5c520ae442a30dbcd48788d5.svg" />
</div>
</div>
<p>We see how the function definition has become a <code class="docutils literal notranslate"><span class="pre">FunctionDef</span></code> node, whose third child is an <code class="docutils literal notranslate"><span class="pre">Expr</span></code> node, which in turn becomes a <code class="docutils literal notranslate"><span class="pre">Call</span></code> – of the <code class="docutils literal notranslate"><span class="pre">&quot;print&quot;</span></code> function with an argument of <code class="docutils literal notranslate"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></code>.</p>
<p>Each of these AST nodes comes as a <em>constructor</em> – that is, we can invoke <code class="docutils literal notranslate"><span class="pre">FunctionDef()</span></code> to obtain a function definition node, or <code class="docutils literal notranslate"><span class="pre">Call()</span></code> to obtain a call node.
These constructors take the AST <em>children</em> as arguments, but also lots of <em>optional</em> arguments (which we did not use so far). The <em>dump</em> of the AST into a string reveals all the arguments for each constructor:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">main_tree</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(
    body=[
        FunctionDef(
            name=&#39;main&#39;,
            args=arguments(
                posonlyargs=[],
                args=[],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]),
            body=[
                Expr(
                    value=Call(
                        func=Name(id=&#39;print&#39;, ctx=Load()),
                        args=[
                            Constant(value=&#39;Hello, world!&#39;)],
                        keywords=[]))],
            decorator_list=[])],
    type_ignores=[])
</pre></div>
</div>
</div>
</div>
<p>The <a class="reference external" href="https://docs.python.org/3/library/ast.html">Python ast documentation</a> lists all these constructors, which make up the abstract syntax. There are more than 100 individual constructors! (We said that ASTs are complex, right?)</p>
<p>The nice thing about the above string representation is that we can take it <em>as is</em> and turn it into a tree again:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_main_tree</span> <span class="o">=</span> <span class="n">Module</span><span class="p">(</span>
    <span class="n">body</span><span class="o">=</span><span class="p">[</span>
        <span class="n">FunctionDef</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;main&#39;</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">(</span>
                <span class="n">posonlyargs</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">kwonlyargs</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">kw_defaults</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">defaults</span><span class="o">=</span><span class="p">[]),</span>
            <span class="n">body</span><span class="o">=</span><span class="p">[</span>
                <span class="n">Expr</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">Call</span><span class="p">(</span>
                        <span class="n">func</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">[</span>
                            <span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;Hello, world!&#39;</span><span class="p">)],</span>
                        <span class="n">keywords</span><span class="o">=</span><span class="p">[]))],</span>
            <span class="n">decorator_list</span><span class="o">=</span><span class="p">[])],</span>
    <span class="n">type_ignores</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
</div>
</div>
<p>We can take this tree and compile it into executable code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_main_tree</span> <span class="o">=</span> <span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">my_main_tree</span><span class="p">)</span>  <span class="c1"># required for trees built from constructors</span>
<span class="n">my_main_code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">my_main_tree</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;&lt;unknown&gt;&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;exec&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">main</span>  <span class="c1"># This deletes the definition of main()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">my_main_code</span><span class="p">)</span>  <span class="c1"># This defines main() again from `code`</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Hello, world!
</pre></div>
</div>
</div>
</div>
<p>We can also <em>unparse</em> the tree (= turn it into source code again). (Note how the comment got lost during parsing.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">my_main_tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def main():
    print(&#39;Hello, world!&#39;)
</pre></div>
</div>
</div>
</div>
<p>Hence, we can</p>
<ol class="arabic simple">
<li><p><em>Parse</em> concrete code into ASTs (with <code class="docutils literal notranslate"><span class="pre">ast.parse()</span></code>)</p></li>
<li><p><em>Generate</em> new ASTs and <em>mutate</em> existing ones</p></li>
<li><p><em>Unparse</em> ASTs to obtain concrete code again (with <code class="docutils literal notranslate"><span class="pre">ast.unparse()</span></code>)</p></li>
</ol>
<p>To <em>generate</em> and <em>mutate</em> ASTs (step #2, above), we need means to produce <em>correct</em> ASTs, invoking all constructors with the correct arguments.
The plan is thus to have a <em>grammar</em> for ASTs, which produces (and parses) ASTs as we like.</p>
</section>
<section id="a-grammar-for-asts">
<h2>A Grammar for ASTs<a class="headerlink" href="#a-grammar-for-asts" title="Link to this heading">#</a></h2>
<p>Programming language grammars are among the most complicated formal grammars around, and ASTs reflect much of this complexity. We will use the <a class="reference external" href="https://docs.python.org/3/library/ast.html">abstract AST grammar</a> as specified in the Python documentation as base, and build a formal context-free grammar step by step.</p>
<section id="constants">
<h3>Constants<a class="headerlink" href="#constants" title="Link to this heading">#</a></h3>
<p>We will start with simple constants – strings and integers. Again, we use the <code class="docutils literal notranslate"><span class="pre">fuzzingbook</span></code> syntax for grammars, as it allows for easier extension.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">string</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[]^_`{|}~ &quot;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_`{|}~ &#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;expr&gt;&#39;</span> <span class="p">],</span>

    <span class="c1"># Expressions</span>
    <span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;Constant&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Expr&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;Expr&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Expr(value=&lt;expr&gt;)&#39;</span> <span class="p">],</span>

    <span class="c1"># Constants</span>
    <span class="s1">&#39;&lt;Constant&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Constant(value=&lt;literal&gt;)&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;literal&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;float&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;bool&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;none&gt;&#39;</span> <span class="p">],</span>

    <span class="c1"># Strings</span>
    <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&quot;&lt;not_double_quotes&gt;*&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&lt;not_single_quotes&gt;*&#39;&quot;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;not_double_quotes&gt;&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH</span><span class="p">),</span>
    <span class="s1">&#39;&lt;not_single_quotes&gt;&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH</span><span class="p">),</span>
    <span class="c1"># FIXME: The actual rules for Python strings are also more complex:</span>
    <span class="c1"># https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals</span>

    <span class="c1"># Numbers</span>
    <span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;nonzerodigit&gt;&lt;digits&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;float&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;integer&gt;.&lt;integer&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;nonzerodigit&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;digits&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;digit&gt;&lt;digits&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;digit&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">],</span>
    <span class="c1"># FIXME: There are _many_ more ways to express numbers in Python; see</span>
    <span class="c1"># https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals</span>

    <span class="c1"># More</span>
    <span class="s1">&#39;&lt;bool&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="s1">&#39;False&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;none&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;None&#39;</span> <span class="p">],</span>

    <span class="c1"># FIXME: Not supported: bytes, format strings, regex strings...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>Note that we use <em>extended Backus-Naur form</em> in our grammars (here: <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;+</span></code> stands for one or more instances of <code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;*</span></code> stands for zero or more instances of <code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;</span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;?</span></code> stands for one or zero instances of <code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;</span></code>.</p></li>
</ul>
<p>A call to <code class="docutils literal notranslate"><span class="pre">is_valid_grammar()</span></code> ensures our grammar is free of common mistakes. Don’t write grammars without it!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">constants_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">)</span>
<span class="n">constants_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">constants_grammar</span><span class="p">)</span>
<span class="n">constants_tree_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">constants_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">constants_tree_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Expr(value=Constant(value=None))
</pre></div>
</div>
</div>
</div>
<p>We can create an AST from this expression and turn it into Python code (well, a literal):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">constants_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">constants_tree_str</span><span class="p">)</span>
<span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">constants_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;None&#39;
</pre></div>
</div>
</div>
</div>
<p>Let’s do this a number of times:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_samples</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">start_symbol</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">start_symbol</span><span class="p">,</span> <span class="n">max_number_free_instantiations</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">tree_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">tree_str</span><span class="p">)</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">code</span><span class="si">:</span><span class="s1">40</span><span class="si">}</span><span class="s1"> # </span><span class="si">{</span><span class="n">tree_str</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False                                    # Expr(value=Constant(value=False))
2                                        # Constant(value=2)
None                                     # Constant(value=None)
&#39;#&#39;                                      # Constant(value=&quot;#&quot;)
550.81                                   # Constant(value=550.81)
True                                     # Constant(value=True)
&#39;.&#39;                                      # Constant(value=&#39;.&#39;)
467                                      # Constant(value=467)
7894                                     # Constant(value=7894)
263                                      # Constant(value=263)
</pre></div>
</div>
</div>
</div>
<p>Our grammar can also <em>parse</em> ASTs obtained from concrete code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sample_constant_code</span> <span class="o">=</span> <span class="s2">&quot;4711&quot;</span>
<span class="n">sample_constant_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sample_constant_code</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># get the `Expr` node</span>
<span class="n">sample_constant_ast_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sample_constant_ast</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sample_constant_ast_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Expr(value=Constant(value=4711))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">constant_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">constants_grammar</span><span class="p">)</span>
<span class="n">constant_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">sample_constant_ast_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>Let us now come up with a quiz question: <em>Does our grammar support negative numbers?</em>
For this, let’s first find out if the <code class="docutils literal notranslate"><span class="pre">Constant()</span></code> constructor also take a <em>negative</em> number as an argument? It turns out it can:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;-1&#39;
</pre></div>
</div>
</div>
</div>
<p>But what happens if we parse a negative number, say <code class="docutils literal notranslate"><span class="pre">-1</span></code>? One might assume that this simply results in a <code class="docutils literal notranslate"><span class="pre">Constant(-1)</span></code>, right? Try it out yourself!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">quiz</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quiz</span><span class="p">(</span><span class="s2">&quot;If we parse a negative number, do we obtain &quot;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="s2">&quot;a `Constant()` with a negative value, or&quot;</span><span class="p">,</span>
        <span class="s2">&quot;a unary `-` operator applied to a positive value?&quot;</span>
    <span class="p">],</span> <span class="mi">1</span> <span class="o">**</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">**</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
    
    <script>
    var bad_answers = new Map();

    function answer(quiz_id) {
        ans = 0;
        for (i = 1;; i++) {
            checkbox = document.getElementById(quiz_id + "-" + i.toString());
            if (!checkbox)
                break;
            if (checkbox.checked)
                ans |= (1 << i);
        }
        return ans;
    }
    function check_selection(quiz_id, correct_answer, multiple_choice, hint) {
        given_answer = answer(quiz_id);
        if (given_answer == correct_answer)
        {
            document.getElementById(quiz_id + "-submit").value = "Correct!";
            document.getElementById(quiz_id + "-hint").innerHTML = "";

            for (i = 1;; i++) {
                checkbox = document.getElementById(quiz_id + "-" + i.toString());
                label = document.getElementById(quiz_id + "-" + i.toString() + "-label")
                if (!checkbox)
                    break;

                if (checkbox.checked) {
                    label.style.fontWeight = "bold";
                }
                else {
                    label.style.textDecoration = "line-through";
                }
            }
        }
        else 
        {
            document.getElementById(quiz_id + "-submit").value = "Try again";

            if (!bad_answers.has(quiz_id)) {
                bad_answers.set(quiz_id, 1);
            }
            else {
                bad_answers.set(quiz_id, bad_answers.get(quiz_id) + 1);
            }

            if (bad_answers.get(quiz_id) >= 2 && hint.length > 0) {
                document.getElementById(quiz_id + "-hint").innerHTML = 
                    "&nbsp;&nbsp;(Hint: <code>" + hint + "</code>)";
            }

            if (!multiple_choice) {
                for (i = 1;; i++) {
                    checkbox = document.getElementById(quiz_id + "-" + i.toString());
                    label = document.getElementById(quiz_id + "-" + i.toString() + "-label")

                    if (!checkbox)
                        break;
                    if (checkbox.checked) {
                        label.style.textDecoration = "line-through";
                    }
                }
            }
        }
    }
    function clear_selection(quiz_id) {
        document.getElementById(quiz_id + "-submit").value = "Submit";
        document.getElementById(quiz_id + "-hint").innerHTML = "";
    }
    </script>
    
    <div class="quiz">
    <h3 class="quiz_title">Quiz</h3>
    <p>
    <div class="quiz_question">If we parse a negative number, do we obtain </div>
    </p>
    <p>
    <div class="quiz_options" title="Pick a choice.">
    
        <input type="radio" name="c848bd34-d89c-11ef-9697-6298cf1a5790" id="c848bd34-d89c-11ef-9697-6298cf1a5790-1" onclick="clear_selection('c848bd34-d89c-11ef-9697-6298cf1a5790')">
        <label id="c848bd34-d89c-11ef-9697-6298cf1a5790-1-label" for="c848bd34-d89c-11ef-9697-6298cf1a5790-1">a <code>Constant()</code> with a negative value, or</label><br>
    
        <input type="radio" name="c848bd34-d89c-11ef-9697-6298cf1a5790" id="c848bd34-d89c-11ef-9697-6298cf1a5790-2" onclick="clear_selection('c848bd34-d89c-11ef-9697-6298cf1a5790')">
        <label id="c848bd34-d89c-11ef-9697-6298cf1a5790-2-label" for="c848bd34-d89c-11ef-9697-6298cf1a5790-2">a unary <code>-</code> operator applied to a positive value?</label><br>
    
    </div>
    </p>
    <input id="c848bd34-d89c-11ef-9697-6298cf1a5790-submit" type="submit" value="Submit" onclick="check_selection('c848bd34-d89c-11ef-9697-6298cf1a5790', 4, 0, '')">
    <span class="quiz_hint" id="c848bd34-d89c-11ef-9697-6298cf1a5790-hint"></span>
    </div>
    </div></div>
</div>
<p>The answer is that parsing <code class="docutils literal notranslate"><span class="pre">-1</span></code> yields a unary minus <code class="docutils literal notranslate"><span class="pre">USub()</span></code> applied to a positive value:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(body=[Expr(value=UnaryOp(op=USub(), operand=Constant(value=1)))], type_ignores=[])
</pre></div>
</div>
</div>
</div>
<p>As unary operators are not part of our grammar (yet), it cannot handle negative numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sample_constant_code</span> <span class="o">=</span> <span class="s2">&quot;-1&quot;</span>
<span class="n">sample_constant_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sample_constant_code</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># get the `Expr` node</span>
<span class="n">sample_constant_ast_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sample_constant_ast</span><span class="p">)</span>
<span class="n">constant_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">constants_grammar</span><span class="p">)</span>
<span class="n">constant_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">sample_constant_ast_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Error parsing &quot;Expr(value=UnaryOp(op=USub(), operand=Constant(value=1)))&quot; starting with &quot;&lt;start&gt;&quot;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<p>In the next sections, we will gradually expand our grammar with more and more Python features, eventually covering (almost) the entire language.</p>
</section>
<section id="excursion-composites">
<h3>Excursion: Composites<a class="headerlink" href="#excursion-composites" title="Link to this heading">#</a></h3>
<p>Let us add composite constants – lists, dictionaries, tuples, etc. Here is how these are represented in an AST:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;{ &#39;a&#39;: set() }&quot;</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(
    body=[
        Expr(
            value=Dict(
                keys=[
                    Constant(value=&#39;a&#39;)],
                values=[
                    Call(
                        func=Name(id=&#39;set&#39;, ctx=Load()),
                        args=[],
                        keywords=[])]))],
    type_ignores=[])
</pre></div>
</div>
</div>
</div>
<p>Let us encode these into a grammar, again using the definitions from the <a class="reference external" href="https://docs.python.org/3/library/ast.html">abstract AST grammar</a>.
All these structures also take <em>contexts</em> in which identifiers are used – <code class="docutils literal notranslate"><span class="pre">Load()</span></code> if they are used for evaluation, <code class="docutils literal notranslate"><span class="pre">Store()</span></code> if they appear on the left-hand side of an assignment (yes, in Python, you can have a tuple on the left-hand side of an assignment, say <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">2)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Del()</span></code> if they are used as operands in a <code class="docutils literal notranslate"><span class="pre">del</span></code> statement. Right now, we only use <code class="docutils literal notranslate"><span class="pre">Load()</span></code> and <code class="docutils literal notranslate"><span class="pre">Del()</span></code> interchangeably.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span>
    <span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">:</span> <span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;Dict&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Set&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;List&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Tuple&gt;&#39;</span>
    <span class="p">],</span>

    <span class="s1">&#39;&lt;Dict&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Dict(keys=&lt;expr_list&gt;, values=&lt;expr_list&gt;)&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;Set&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Set(elts=&lt;nonempty_expr_list&gt;)&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;EmptySet&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;EmptySet&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;List&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;List(elts=&lt;expr_list&gt;, ctx=Load())&#39;</span><span class="p">,</span>
        <span class="s1">&#39;List(elts=&lt;expr_list&gt;, ctx=Del())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;Tuple&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Tuple(elts=&lt;expr_list&gt;, ctx=Load())&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Tuple(elts=&lt;expr_list&gt;, ctx=Del())&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Lists of expressions</span>
    <span class="s1">&#39;&lt;expr_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;exprs&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;nonempty_expr_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;exprs&gt;]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;exprs&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;exprs&gt;, &lt;expr&gt;&#39;</span> <span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;Constant&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Dict&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Set&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;List&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Tuple&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Constant&gt;
&#39;c&#39;                                      # Constant(value=&#39;c&#39;)
96.7                                     # Constant(value=96.7)
None                                     # Constant(value=None)
False                                    # Constant(value=False)
505                                      # Constant(value=505)
&#39;U&#39;                                      # Constant(value=&quot;U&quot;)
True                                     # Constant(value=True)
41398                                    # Constant(value=41398)
24                                       # Constant(value=24)
72                                       # Constant(value=72)

&lt;Dict&gt;
{}                                       # Dict(keys=[], values=[List(elts=[Dict(keys=[List(elts=[Constant(value=9.63)], ctx=Load())], values=[Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Set(elts=[Constant(value=True), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])], ctx=Load())]), Constant(value=2), Tuple(elts=[Constant(value=&#39;&#39;), Constant(value=False), Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), Expr(value=List(elts=[Constant(value=None)], ctx=Load())), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())], ctx=Del())])
{577: &#39;&#39;}                                # Dict(keys=[Constant(value=577), Constant(value=34), Constant(value=286), Constant(value=7051)], values=[Constant(value=&quot;&quot;)])
{90: 14}                                 # Dict(keys=[Constant(value=90)], values=[Constant(value=14), Constant(value=88), Constant(value=435)])
{&quot;nF}[ (^{bXBrwzf-P@geW&#39;.]~G&gt;;O2i&amp;/t7Cc5:QU1jR4q_8VJ)Hsxd#o*aT3Sv!$ku?IhMpmA,EL0ZN=`9yK|&lt;Y6lD+%I&quot;: &#39;Gym]A&amp;K;70{jJLC&quot;DV)/Y S.eNMEQq^%?i+-b!hz|gcUBvW485O#pPu~d:(F&gt;_&lt;a}kI2norf9H[T,lXt=w6@Z*1$xs`&quot;R3&#39;} # Dict(keys=[Constant(value=&quot;nF}[ (^{bXBrwzf-P@geW&#39;.]~G&gt;;O2i&amp;/t7Cc5:QU1jR4q_8VJ)Hsxd#o*aT3Sv!$ku?IhMpmA,EL0ZN=`9yK|&lt;Y6lD+%I&quot;)], values=[Constant(value=&#39;Gym]A&amp;K;70{jJLC&quot;DV)/Y S.eNMEQq^%?i+-b!hz|gcUBvW485O#pPu~d:(F&gt;_&lt;a}kI2norf9H[T,lXt=w6@Z*1$xs`&quot;R3&#39;)])
{}                                       # Dict(keys=[], values=[])
{}                                       # Dict(keys=[], values=[])
{}                                       # Dict(keys=[], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Constant(value=True), Constant(value=687596.53), Dict(keys=[Set(elts=[Expr(value=Set(elts=[Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), Constant(value=34.676)]))])], values=[Set(elts=[Set(elts=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load())], ctx=Del())])])]), List(elts=[], ctx=Load())])
{}                                       # Dict(keys=[], values=[])
{}                                       # Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], values=[])
{}                                       # Dict(keys=[Tuple(elts=[], ctx=Del())], values=[])

&lt;Set&gt;
{
[], 79.2}                              # Set(elts=[Expr(value=List(elts=[], ctx=Del())), Constant(value=79.2)])
set()                                    # Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])
{{{False: [set()], None: []}, (({20: set()},),)}} # Set(elts=[Set(elts=[Dict(keys=[Constant(value=False), Constant(value=None)], values=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load()), List(elts=[], ctx=Del())]), Tuple(elts=[Tuple(elts=[Dict(keys=[Constant(value=20)], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Constant(value=True), List(elts=[], ctx=Del())])], ctx=Load())], ctx=Del())])])
{&#39;Z&#39;}                                    # Set(elts=[Constant(value=&#39;Z&#39;)])
{3763, &#39;&#39;}                               # Set(elts=[Constant(value=3763), Constant(value=&quot;&quot;)])
{475, 136, 95, 841, 58}                  # Set(elts=[Constant(value=475), Constant(value=136), Constant(value=95), Constant(value=841), Constant(value=58)])
{&quot;F3Ye]1UZz&amp;sPrG:D-R`k?5d+SM,/4b!uE fW;L$)@oQ&#39;h^qI[(lXgN0wmt=~Jav86|Vp%72CcOBj_nHK&lt;9A*#i}yTx&gt;{.&quot;} # Set(elts=[Constant(value=&quot;F3Ye]1UZz&amp;sPrG:D-R`k?5d+SM,/4b!uE fW;L$)@oQ&#39;h^qI[(lXgN0wmt=~Jav86|Vp%72CcOBj_nHK&lt;9A*#i}yTx&gt;{.&quot;)])
{66, 7}                                  # Set(elts=[Constant(value=66), Constant(value=7)])
{set(), &#39;&#39;, None, &#39;_P[&#39;, &#39;L}w,6&#39;}        # Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Constant(value=&#39;&#39;), Constant(value=None), Constant(value=&#39;_P[&#39;), Constant(value=&#39;L}w,6&#39;)])
{&#39;51I{Ef&amp;u;kThXbRo]cV/8)Q@W&gt;4|=J7lHge&quot;+^y%(rv&lt;q.DM:najxi9OUG?!KS zsd2t-Fm3NApB#0$~C`*PY&#39;} # Set(elts=[Constant(value=&#39;51I{Ef&amp;u;kThXbRo]cV/8)Q@W&gt;4|=J7lHge&quot;+^y%(rv&lt;q.DM:najxi9OUG?!KS zsd2t-Fm3NApB#0$~C`*PY&#39;)])

&lt;List&gt;
[[], {831.3: (7, set(), {(&#39;1&#39;,)})}]      # List(elts=[List(elts=[], ctx=Load()), Dict(keys=[Constant(value=831.30), Constant(value=None), Expr(value=Tuple(elts=[Constant(value=&quot;&quot;), Constant(value=True), Constant(value=False)], ctx=Del()))], values=[Tuple(elts=[Constant(value=7), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Set(elts=[Tuple(elts=[Constant(value=&#39;1&#39;)], ctx=Load())])], ctx=Load())])], ctx=Del())
[22]                                     # List(elts=[Constant(value=22)], ctx=Load())
[64]                                     # List(elts=[Constant(value=64)], ctx=Load())
[56]                                     # List(elts=[Constant(value=56)], ctx=Del())
[9589]                                   # List(elts=[Constant(value=9589)], ctx=Load())
[780]                                    # List(elts=[Constant(value=780)], ctx=Del())
[164, 47]                                # List(elts=[Constant(value=164), Constant(value=47)], ctx=Load())
[&quot;^dG@0 N26zE73qSfX,&gt;xhPlW#j.1cQO4bF+A:LZR&#39;CT=$i_&quot;, &#39;tJI`]gD_M/8yu!%&lt;n~&amp;H|9w*)Ur5sk(e}[vap?V-oK{BYm;eccmO&#39;] # List(elts=[Constant(value=&quot;^dG@0 N26zE73qSfX,&gt;xhPlW#j.1cQO4bF+A:LZR&#39;CT=$i_&quot;), Constant(value=&quot;tJI`]gD_M/8yu!%&lt;n~&amp;H|9w*)Ur5sk(e}[vap?V-oK{BYm;eccmO&quot;)], ctx=Load())
[&#39;e]@JX9LBnA:0Ha^3KVf OWuFT%*8ZGtp/x`Cw&quot;li|Mq?_UI45$)zNh#gDcs;!-d[,(~{&gt;bYrE&lt;.RQ27}&amp;moSk+vjP=6y9&#39;] # List(elts=[Constant(value=&#39;e]@JX9LBnA:0Ha^3KVf OWuFT%*8ZGtp/x`Cw&quot;li|Mq?_UI45$)zNh#gDcs;!-d[,(~{&gt;bYrE&lt;.RQ27}&amp;moSk+vjP=6y9&#39;)], ctx=Load())
[set(), set()]                           # List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load())

&lt;Tuple&gt;
()                                       # Tuple(elts=[], ctx=Load())
(set(),)                                 # Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())
(set(), [], 
1.4, [[None], True], {set(): (False, {set()})}) # Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Del()), Expr(value=Constant(value=1.4)), List(elts=[List(elts=[Constant(value=None)], ctx=Load()), Constant(value=True)], ctx=Load()), Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), Expr(value=Constant(value=False))], values=[Tuple(elts=[Constant(value=False), Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])], ctx=Load())])], ctx=Del())
(&#39;&#39;,)                                    # Tuple(elts=[Constant(value=&quot;&quot;)], ctx=Load())
(93,)                                    # Tuple(elts=[Constant(value=93)], ctx=Load())
(28371613, 51, 892, 45, 10678, &#39;&#39;)       # Tuple(elts=[Constant(value=28371613), Constant(value=51), Constant(value=892), Constant(value=45), Constant(value=10678), Constant(value=&#39;&#39;)], ctx=Del())
(72, 632)                                # Tuple(elts=[Constant(value=72), Constant(value=632)], ctx=Load())
(&#39;p[R#U&#39;, &#39;5JRh~3&#39;, &#39;aAI&gt;V+LBk60Ogp&#39;)    # Tuple(elts=[Constant(value=&#39;p[R#U&#39;), Constant(value=&quot;5JRh~3&quot;), Constant(value=&quot;aAI&gt;V+LBk60Ogp&quot;)], ctx=Load())
(363,)                                   # Tuple(elts=[Constant(value=363)], ctx=Del())
(&#39;a*wyz!$CcJ.TDj?&lt;8Q`o}|fG~3%FX/O:r@YW5dK,MqLt^l&amp;B(PbH1_ZInkimvSV4x&gt; u{+2gs)h&quot;e9NA;76]=E-0;&#39;,) # Tuple(elts=[Constant(value=&#39;a*wyz!$CcJ.TDj?&lt;8Q`o}|fG~3%FX/O:r@YW5dK,MqLt^l&amp;B(PbH1_ZInkimvSV4x&gt; u{+2gs)h&quot;e9NA;76]=E-0;&#39;)], ctx=Load())
</pre></div>
</div>
</div>
</div>
<p>You may encounter a number of uncommon expressions here. For instance:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">()</span></code> is an empty tuple.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(1,)</span></code> is a tuple with one element.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{}</span></code> is an empty dictionary; <code class="docutils literal notranslate"><span class="pre">{1}</span></code> is a set with one element.</p></li>
<li><p>An empty set is denoted by <code class="docutils literal notranslate"><span class="pre">set()</span></code>.</p></li>
</ol>
<p>The fact that we use <code class="docutils literal notranslate"><span class="pre">set()</span></code> to represent empty sets is actually a feature of our <code class="docutils literal notranslate"><span class="pre">PYTHON_AST_COMPOSITES_GRAMMAR</span></code> grammar.
If we invoke the <code class="docutils literal notranslate"><span class="pre">Set()</span></code> AST constructor without any elements, we obtain this beautiful expression…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">Set</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="p">[])))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{*()}
</pre></div>
</div>
</div>
</div>
<p>… which indeed evaluates into an empty set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">*</span><span class="p">()}</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>set()
</pre></div>
</div>
</div>
</div>
<p>Technically speaking, all of this is correct, but we’d like to stick to (somewhat) more readable code. If you want to confuse your programmer friends, always use <code class="docutils literal notranslate"><span class="pre">{*()}</span></code> instead of <code class="docutils literal notranslate"><span class="pre">set()</span></code>.</p>
</section>
<section id="end-of-excursion">
<h3>End of Excursion<a class="headerlink" href="#end-of-excursion" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-expressions">
<h3>Excursion: Expressions<a class="headerlink" href="#excursion-expressions" title="Link to this heading">#</a></h3>
<p>Let us extend our grammar with <em>expressions</em>. The Python parser already takes care of precedence rules, so we can treat all unary and binary operators in a similar fashion.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;2 + 2 is not False&quot;</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(
    body=[
        Expr(
            value=Compare(
                left=BinOp(
                    left=Constant(value=2),
                    op=Add(),
                    right=Constant(value=2)),
                ops=[
                    IsNot()],
                comparators=[
                    Constant(value=False)]))],
    type_ignores=[])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">:</span> <span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;BoolOp&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;BinOp&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;UnaryOp&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Compare&gt;&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Booleans: and or</span>
    <span class="s1">&#39;&lt;BoolOp&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;BoolOp(op=&lt;boolop&gt;, values=&lt;expr_list&gt;)&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;boolop&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;And()&#39;</span><span class="p">,</span> <span class="s1">&#39;Or()&#39;</span> <span class="p">],</span>

    <span class="c1"># Binary operators: + - * ...</span>
    <span class="s1">&#39;&lt;BinOp&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;BinOp(left=&lt;expr&gt;, op=&lt;operator&gt;, right=&lt;expr&gt;)&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;operator&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Add()&#39;</span><span class="p">,</span> <span class="s1">&#39;Sub()&#39;</span><span class="p">,</span> <span class="s1">&#39;Mult()&#39;</span><span class="p">,</span> <span class="s1">&#39;MatMult()&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;Div()&#39;</span><span class="p">,</span> <span class="s1">&#39;Mod()&#39;</span><span class="p">,</span> <span class="s1">&#39;Pow()&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;LShift()&#39;</span><span class="p">,</span> <span class="s1">&#39;RShift()&#39;</span><span class="p">,</span> <span class="s1">&#39;BitOr()&#39;</span><span class="p">,</span> <span class="s1">&#39;BitXor()&#39;</span><span class="p">,</span> <span class="s1">&#39;BitAnd()&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;FloorDiv()&#39;</span> <span class="p">],</span>

    <span class="c1"># Unary operators: not + - ...</span>
    <span class="s1">&#39;&lt;UnaryOp&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;UnaryOp(op=&lt;unaryop&gt;, operand=&lt;expr&gt;)&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;unaryop&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Invert()&#39;</span><span class="p">,</span> <span class="s1">&#39;Not()&#39;</span><span class="p">,</span> <span class="s1">&#39;UAdd()&#39;</span><span class="p">,</span> <span class="s1">&#39;USub()&#39;</span> <span class="p">],</span>

    <span class="c1"># Comparisons: == != &lt; &lt;= &gt; &gt;= is in ...</span>
    <span class="s1">&#39;&lt;Compare&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Compare(left=&lt;expr&gt;, ops=&lt;cmpop_list&gt;, comparators=&lt;expr_list&gt;)&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;cmpop_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;cmpops&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;cmpops&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;cmpop&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;cmpop&gt;, &lt;cmpops&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;cmpop&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Eq()&#39;</span><span class="p">,</span> <span class="s1">&#39;NotEq()&#39;</span><span class="p">,</span> <span class="s1">&#39;Lt()&#39;</span><span class="p">,</span> <span class="s1">&#39;LtE()&#39;</span><span class="p">,</span> <span class="s1">&#39;Gt()&#39;</span><span class="p">,</span> <span class="s1">&#39;GtE()&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;Is()&#39;</span><span class="p">,</span> <span class="s1">&#39;IsNot()&#39;</span><span class="p">,</span> <span class="s1">&#39;In()&#39;</span><span class="p">,</span> <span class="s1">&#39;NotIn()&#39;</span> <span class="p">],</span>

    <span class="c1"># FIXME: There&#39;s a few more expressions: GeneratorExp, Await, YieldFrom, ...</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;BoolOp&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;BinOp&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;UnaryOp&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Compare&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;BoolOp&gt;
() and {-([]) / (set(), set()), {
True: set()}} # BoolOp(op=And(), values=[BoolOp(op=Or(), values=[]), Set(elts=[BinOp(left=UnaryOp(op=USub(), operand=Compare(left=List(elts=[], ctx=Del()), ops=[], comparators=[])), op=Div(), right=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load())), Dict(keys=[Expr(value=Constant(value=True))], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Load())])])])
(set(), set(), set() @ set() | set() + set()) and set() ** (set() ^ set()) * set() # BoolOp(op=And(), values=[Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitOr(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))], ctx=Del()), BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
set() % (set() &gt;&gt; set()) - (set() &lt;&lt; set()) or set() &amp; set() # BoolOp(op=Or(), values=[BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=Sub(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
&#39;8&#39; or 6                                 # BoolOp(op=Or(), values=[Constant(value=&#39;8&#39;), Constant(value=6)])
~+123.95                                 # BoolOp(op=Or(), values=[UnaryOp(op=Invert(), operand=UnaryOp(op=UAdd(), operand=Constant(value=123.95)))])
not False // None                        # BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=BinOp(left=Constant(value=False), op=FloorDiv(), right=Constant(value=None)))])
&#39;S&#39; and 6180 in 397494                   # BoolOp(op=And(), values=[Constant(value=&quot;S&quot;), Compare(left=Constant(value=6180), ops=[In()], comparators=[Constant(value=397494)])])
41                                       # BoolOp(op=And(), values=[Constant(value=41)])
214                                      # BoolOp(op=Or(), values=[Constant(value=214)])
5818 and &quot;N1qoR6ak 2UJTWyh&gt;!B)/#YKe0]=w{E.-Q`F[5&#39;&amp;^9cA~&lt;V+M$bnLu%H8I3;g*D?rz7Xj:}pPvif_GOtx4,(ZCdmls|@YiT&quot; and 70 and 884 # BoolOp(op=And(), values=[Constant(value=5818), Constant(value=&quot;N1qoR6ak 2UJTWyh&gt;!B)/#YKe0]=w{E.-Q`F[5&#39;&amp;^9cA~&lt;V+M$bnLu%H8I3;g*D?rz7Xj:}pPvif_GOtx4,(ZCdmls|@YiT&quot;), Constant(value=70), Constant(value=884)])

&lt;BinOp&gt;
{} - 33                                  # BinOp(left=Expr(value=Dict(keys=[], values=[Tuple(elts=[UnaryOp(op=Invert(), operand=List(elts=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load()), Tuple(elts=[], ctx=Del()), BoolOp(op=And(), values=[Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load())])], ctx=Del())), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Compare(left=Tuple(elts=[], ctx=Load()), ops=[], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]))], ctx=Del())])), op=Sub(), right=Constant(value=33))
set() / (set() &lt;&lt; set()) * (set() &gt;&gt; set()) // (set() @ set() &amp; set()) # BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=Mult(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=FloorDiv(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))
None ^ False                             # BinOp(left=Constant(value=None), op=BitXor(), right=Constant(value=False))
-&#39;&#39; + +7719.5                            # BinOp(left=UnaryOp(op=USub(), operand=Constant(value=&quot;&quot;)), op=Add(), right=UnaryOp(op=UAdd(), operand=Constant(value=7719.5)))
(set() or 906) &gt;&gt; (&#39;F&#39;) | (not (True)) % ((set() and set()) &lt;&lt; False) # BinOp(left=BinOp(left=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Constant(value=906)]), op=RShift(), right=BoolOp(op=Or(), values=[Constant(value=&#39;F&#39;)])), op=BitOr(), right=BinOp(left=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Constant(value=True)])), op=Mod(), right=BinOp(left=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])]), op=LShift(), right=Constant(value=False))))
((set()) &gt; None != set()) | ((set()))    # BinOp(left=Compare(left=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[Gt(), NotEq()], comparators=[Constant(value=None), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), op=BitOr(), right=Compare(left=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[], comparators=[Constant(value=True)]))
524 - 188                                # BinOp(left=Constant(value=524), op=Sub(), right=Constant(value=188))
6214 / 81                                # BinOp(left=Constant(value=6214), op=Div(), right=Constant(value=81))
26 / 43                                  # BinOp(left=Constant(value=26), op=Div(), right=Constant(value=43))
&quot;s85;3Rw?ST!NI]_-eJ(x7&#39;kG|z}C^&amp;fWLnY[Z,rV*Qj.`Ed%:4&lt;t&quot; ^ &#39;/$ao6 U{2cim@hHtF&gt;b+vX)KBg1l=qyMDp~O0#A9uPa+l&#39; # BinOp(left=Constant(value=&quot;s85;3Rw?ST!NI]_-eJ(x7&#39;kG|z}C^&amp;fWLnY[Z,rV*Qj.`Ed%:4&lt;t&quot;), op=BitXor(), right=Constant(value=&quot;/$ao6 U{2cim@hHtF&gt;b+vX)KBg1l=qyMDp~O0#A9uPa+l&quot;))

&lt;UnaryOp&gt;
+(set(), 
[])                            # UnaryOp(op=UAdd(), operand=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Expr(value=List(elts=[], ctx=Del()))], ctx=Del()))
~(None)                                  # UnaryOp(op=Invert(), operand=BoolOp(op=Or(), values=[Constant(value=None)]))
-(((not {set(), set()})) &amp; {set(): set(), (): set()}) # UnaryOp(op=USub(), operand=BinOp(left=Compare(left=UnaryOp(op=Not(), operand=Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])), ops=[], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), op=BitAnd(), right=Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Load())], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load())])))
-((set() + set()) % ((set() &lt;&lt; set()) / (set() ^ set()))) ** (set() // set() &gt;&gt; set() * set()) # UnaryOp(op=USub(), operand=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))), op=Pow(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))))
-True                                    # UnaryOp(op=USub(), operand=Constant(value=True))
+(4.3 @ (823 - &#39;&amp;&#39;) | &#39;&#39;)                # UnaryOp(op=UAdd(), operand=BinOp(left=BinOp(left=Constant(value=4.30), op=MatMult(), right=BinOp(left=Constant(value=823), op=Sub(), right=Constant(value=&#39;&amp;&#39;))), op=BitOr(), right=Constant(value=&quot;&quot;)))
~(False &lt;= 51 not in 959)                # UnaryOp(op=Invert(), operand=BoolOp(op=And(), values=[Compare(left=Constant(value=False), ops=[LtE(), NotIn()], comparators=[Constant(value=51), Constant(value=959)])]))
~17                                      # UnaryOp(op=Invert(), operand=Constant(value=17))
not 26                                   # UnaryOp(op=Not(), operand=Constant(value=26))
-68                                      # UnaryOp(op=USub(), operand=Constant(value=68))

&lt;Compare&gt;
()                                       # Compare(left=BoolOp(op=Or(), values=[]), ops=[], comparators=[Expr(value=Constant(value=8)), Tuple(elts=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del()), Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], values=[]), Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Del())]), UnaryOp(op=UAdd(), operand=BinOp(left=Compare(left=Tuple(elts=[], ctx=Load()), ops=[], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), op=Add(), right=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load())))], ctx=Del())])
(set() &amp; set()) / (set() @ (set() - set())) not in set() ^ set() # Compare(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))), ops=[NotIn()], comparators=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
set() % set() // None &lt;&lt; (set() - set() &gt;&gt; set() ** set()) &lt;= set() | set() &gt; set() + set() # Compare(left=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=FloorDiv(), right=Constant(value=None)), op=LShift(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))), ops=[LtE(), Gt()], comparators=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Constant(value=True)])
-632.86 != (not ~(not (&#39;&#39;)))             # Compare(left=UnaryOp(op=USub(), operand=Constant(value=632.860)), ops=[NotEq()], comparators=[UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Constant(value=&#39;&#39;)]))))])
&#39;&#39; &gt;= 717 is not False                   # Compare(left=Constant(value=&quot;&quot;), ops=[GtE(), IsNot(), Eq()], comparators=[Constant(value=717), Constant(value=False)])
15 &lt; 39                                  # Compare(left=Constant(value=15), ops=[Lt(), Is(), Gt(), In()], comparators=[Constant(value=39)])
548 != 934688                            # Compare(left=Constant(value=548), ops=[NotEq(), LtE()], comparators=[Constant(value=934688)])
&quot;w-xSGA8TI{%pRcq6e!_E:}P]9LM/&amp;b1+7*lBDnvu)[o`3dY|Oj~JU&lt;#Z&#39;rH;g,f&gt;@Q0tKk4N$iVaFhzW52y=(C.? sXm^{ &quot; in 425 # Compare(left=Constant(value=&quot;w-xSGA8TI{%pRcq6e!_E:}P]9LM/&amp;b1+7*lBDnvu)[o`3dY|Oj~JU&lt;#Z&#39;rH;g,f&gt;@Q0tKk4N$iVaFhzW52y=(C.? sXm^{ &quot;), ops=[In()], comparators=[Constant(value=425), Constant(value=21270)])
&#39;H]3Ky.2p-:#6F%9V{X^8)lMD[;7Otk/hgImvcJf&amp; E`uG}w?PY:&#39; &gt;= &#39;nCALds|1zjq4BZ$&quot;ab*@_(e&lt;!rT=iUW~05+,Q&gt;oNSxRVpF&#39; # Compare(left=Constant(value=&#39;H]3Ky.2p-:#6F%9V{X^8)lMD[;7Otk/hgImvcJf&amp; E`uG}w?PY:&#39;), ops=[GtE(), Gt(), NotIn(), IsNot(), GtE()], comparators=[Constant(value=&#39;nCALds|1zjq4BZ$&quot;ab*@_(e&lt;!rT=iUW~05+,Q&gt;oNSxRVpF&#39;)])
6.3                                      # Compare(left=Constant(value=6.3), ops=[], comparators=[])
</pre></div>
</div>
</div>
</div>
<p>Not all of these expressions are <em>type-correct</em>. For instance, <code class="docutils literal notranslate"><span class="pre">set()</span> <span class="pre">*</span> <span class="pre">set()</span></code> raises a type error at runtime. They <em>can</em> be properly parsed, though.</p>
<p>How good is our grammar at this point? Let us create 20 expressions and check how many of these</p>
<ol class="arabic simple">
<li><p>parse without <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code></p></li>
<li><p>evaluate without <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_iterations</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">bad_syntax</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bad_type</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ast_exprs_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">)</span>
<span class="n">expr_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_exprs_grammar</span><span class="p">,</span> <span class="n">max_number_free_instantiations</span><span class="o">=</span><span class="n">expr_iterations</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">expr_iterations</span><span class="p">):</span>
    <span class="n">expr_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()))</span>
    <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">expr_tree</span><span class="p">)</span>
    <span class="n">expr_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">expr_tree</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">expr_str</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># insert parsing code here</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">bad_syntax</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">bad_type</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># &lt;-- insert evaluation code here</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">bad_type</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">bad_syntax</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bad syntax: </span><span class="si">{</span><span class="n">bad_syntax</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">expr_iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bad type: </span><span class="si">{</span><span class="n">bad_type</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">expr_iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 set()
1 
2 [
~(False,) &gt;&gt; {635: (set() @ set() &amp; set(),), 99.1 not in set() ** set(): {[set() ^ set()]}}]
3 (set() * set() - (set() + set())) / ((set() ^ set()) % set() | set() &lt;&lt; set() % set())
4 not None
5 -+(True and &#39;#&#39; and &#39;x&#39;)
6 (8876 &gt; 46 in 36 != 50)
7 24
8 &quot;LfDW-kSM|tpB&amp;+V*RgQ7U]3xq)zh~n^`wTdie5jvPN: A2K?$ZGJ(X;%@sr9mcIu!}OC/1&gt;&lt;b=y&#39;0H8o_.4lFYa{6[,&gt;E?&quot;
9 &#39;o,awXihgeM[581Bln&quot;RA60^k2N_L=d$C`7U~f)(&amp;ZG]#m+DqF|PjpIQ&lt;.4ur@ T!-W}Vs:Y{*zOEJb3StHK&gt;?y%c/;iv9&#39;
10 ((set()) &lt; set() is set()) &gt;= ((set()))
11 ((set())) == ((set()) &lt;= set())
12 
13 
14 set()
15 set()
16 []
17 
18 ((() or &#39;k5&#39;))
19 () | []
Bad syntax: 0/20
Bad type: 0/20
</pre></div>
</div>
</div>
</div>
<p>We’re not doing too bad here.
It is possible, in principle, to use ISLa constraints such that the resulting code will be properly typed - but this would take hundreds to thousands of rules. We will leave this exercise to the reader.</p>
<p>Note that you should <em>not</em> repeat this experiment once <em>identifiers</em> come into play. There is a remote chance that the fuzzer synthesizes a call like <code class="docutils literal notranslate"><span class="pre">os.remove(&quot;/&quot;)</span></code> – and away goes your file system!</p>
</section>
<section id="id1">
<h3>End of Excursion<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-names-and-function-calls">
<h3>Excursion: Names and Function Calls<a class="headerlink" href="#excursion-names-and-function-calls" title="Link to this heading">#</a></h3>
<p>Let us add some <em>identifiers</em> such that we can call <em>functions</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ID_START</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span>
<span class="n">ID_CONTINUE</span> <span class="o">=</span> <span class="n">ID_START</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ID_CONTINUE</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;xyzzy(a, b=c)&quot;</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(
    body=[
        Expr(
            value=Call(
                func=Name(id=&#39;xyzzy&#39;, ctx=Load()),
                args=[
                    Name(id=&#39;a&#39;, ctx=Load())],
                keywords=[
                    keyword(
                        arg=&#39;b&#39;,
                        value=Name(id=&#39;c&#39;, ctx=Load()))]))],
    type_ignores=[])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">:</span> <span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;Name&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Call&gt;&#39;</span>
    <span class="p">],</span>

    <span class="c1"># Identifiers</span>
    <span class="s1">&#39;&lt;Name&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Name(id=&lt;identifier&gt;, ctx=Load())&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Name(id=&lt;identifier&gt;, ctx=Del())&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;identifier&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s2">&quot;&#39;&lt;id&gt;&#39;&quot;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;id&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;id_start&gt;&lt;id_continue&gt;*&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;id_start&gt;&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ID_START</span><span class="p">),</span>
    <span class="s1">&#39;&lt;id_continue&gt;&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ID_CONTINUE</span><span class="p">),</span>
    <span class="c1"># FIXME: Actual rules are a bit more complex; see</span>
    <span class="c1"># https://docs.python.org/3/reference/lexical_analysis.html#identifiers</span>

    <span class="c1"># Function Calls</span>
    <span class="s1">&#39;&lt;Call&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Call(func=&lt;func&gt;&lt;args_param&gt;&lt;keywords_param&gt;)&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;args_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, args=&lt;expr_list&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;keywords_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, keywords=&lt;keyword_list&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;func&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;expr&gt;&#39;</span> <span class="p">],</span>  <span class="c1"># Actually &lt;Expr&gt;, but this is more readable and parses 90%</span>
    <span class="s1">&#39;&lt;keyword_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;keywords&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;keywords&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;keyword&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;keyword&gt;, &lt;keywords&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;keyword&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;keyword(arg=&lt;identifier&gt;, value=&lt;expr&gt;)&#39;</span> <span class="p">]</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
        <span class="c1"># As of 3.13, args and keywords parameters are optional</span>
        <span class="s1">&#39;&lt;Call&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Call(func=&lt;func&gt;&lt;args_param&gt;?&lt;keywords_param&gt;?)&#39;</span> <span class="p">],</span>
    <span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;Name&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Call&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Name&gt;
n                                        # Name(id=&#39;n&#39;, ctx=Load())
vmGtKyT3Oq1gBC_srAIRaeQw6Dh8V5oLdj9FcvHfb4MpPZiNuEJ27WYU0lnkSxX9Lz # Name(id=&#39;vmGtKyT3Oq1gBC_srAIRaeQw6Dh8V5oLdj9FcvHfb4MpPZiNuEJ27WYU0lnkSxX9Lz&#39;, ctx=Del())
h                                        # Name(id=&#39;h&#39;, ctx=Load())
L                                        # Name(id=&#39;L&#39;, ctx=Del())
M                                        # Name(id=&#39;M&#39;, ctx=Load())
g                                        # Name(id=&#39;g&#39;, ctx=Del())
P                                        # Name(id=&#39;P&#39;, ctx=Del())
It                                       # Name(id=&#39;It&#39;, ctx=Del())
jGn7g                                    # Name(id=&#39;jGn7g&#39;, ctx=Load())
psj                                      # Name(id=&#39;psj&#39;, ctx=Del())

&lt;Call&gt;
{{set(): set()}(+set())}(m7K, (), u=[set() // set()]) # Call(func=Set(elts=[Call(func=Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), args=[UnaryOp(op=UAdd(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], keywords=[])]), args=[Name(id=&#39;m7K&#39;, ctx=Del()), Tuple(elts=[], ctx=Load())], keywords=[keyword(arg=&#39;u&#39;, value=List(elts=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load()))])
(())(set(), None, 
U, j=False, i=set())  # Call(func=Compare(left=BoolOp(op=Or(), values=[]), ops=[], comparators=[BoolOp(op=And(), values=[])]), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Constant(value=None), Expr(value=Name(id=&#39;U&#39;, ctx=Load()))], keywords=[keyword(arg=&#39;j&#39;, value=Constant(value=False)), keyword(arg=&#39;i&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
[set(), set(), set()](set(), (set(),), T=set(), L=set(), y=set()) # Call(func=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())], keywords=[keyword(arg=&#39;T&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;L&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;y&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
(set() - set() ** set() % (set() @ set()))(set() * set(), set() &lt;&lt; set(), W=set() / set()) # Call(func=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))), args=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg=&#39;W&#39;, value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))])
(set() &gt;&gt; set())((set() | set()) ^ set(), g=set() &amp; set(), B=set() + set()) # Call(func=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), args=[BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg=&#39;g&#39;, value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), keyword(arg=&#39;B&#39;, value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))])
&#39;&#39;(-(not 48.9), Q=~70, FmD=True, h=set()) # Call(func=Constant(value=&#39;&#39;), args=[UnaryOp(op=USub(), operand=UnaryOp(op=Not(), operand=Constant(value=48.9)))], keywords=[keyword(arg=&#39;Q&#39;, value=UnaryOp(op=Invert(), operand=Constant(value=70))), keyword(arg=&#39;FmD&#39;, value=Constant(value=True)), keyword(arg=&#39;h&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
((set() in set()) &gt; set())(None, v=set()) # Call(func=Compare(left=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), ops=[Gt()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), args=[Compare(left=Constant(value=None), ops=[], comparators=[])], keywords=[keyword(arg=&#39;v&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
&#39;&#39;(set(), V, l, t, _, zM=H)              # Call(func=Constant(value=&quot;&quot;), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Name(id=&#39;V&#39;, ctx=Load()), Name(id=&#39;l&#39;, ctx=Load()), Name(id=&#39;t&#39;, ctx=Del()), Name(id=&#39;_&#39;, ctx=Load())], keywords=[keyword(arg=&#39;zM&#39;, value=Name(id=&#39;H&#39;, ctx=Load()))])
xTzqJe5gQ(n80d, qkw=b)                   # Call(func=Name(id=&#39;xTzqJe5gQ&#39;, ctx=Del()), args=[Name(id=&#39;n80d&#39;, ctx=Load())], keywords=[keyword(arg=&#39;qkw&#39;, value=Name(id=&#39;b&#39;, ctx=Del()))])
k(set(), set(), set(), E, o=c)           # Call(func=Name(id=&#39;k&#39;, ctx=Load()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Name(id=&#39;E&#39;, ctx=Load())], keywords=[keyword(arg=&#39;o&#39;, value=Name(id=&#39;c&#39;, ctx=Load()))])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast_ids_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">id_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">&#39;&lt;id&gt;&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">id_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;open&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">name_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">name_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Name(id=&#39;open&#39;, ctx=Load())&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">call_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">&#39;&lt;keyword_list&gt;&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">call_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">&#39;[]&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">call_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;open(&quot;foo.txt&quot;, &quot;r&quot;)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
<span class="nb">print</span><span class="p">(</span><span class="n">call_str</span><span class="p">)</span>
<span class="n">call_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">call_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">call_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Call(func=Name(id=&#39;open&#39;, ctx=Load()), args=[Constant(value=&#39;foo.txt&#39;), Constant(value=&#39;r&#39;)], keywords=[])
</pre></div>
</div>
</div>
</div>
</section>
<section id="id2">
<h3>End of Excursion<a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-attributes-and-subscripts">
<h3>Excursion: Attributes and Subscripts<a class="headerlink" href="#excursion-attributes-and-subscripts" title="Link to this heading">#</a></h3>
<p>Let us add attributes and subscripts.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;a[b].c&quot;</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(
    body=[
        Expr(
            value=Attribute(
                value=Subscript(
                    value=Name(id=&#39;a&#39;, ctx=Load()),
                    slice=Name(id=&#39;b&#39;, ctx=Load()),
                    ctx=Load()),
                attr=&#39;c&#39;,
                ctx=Load()))],
    type_ignores=[])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">:</span> <span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;Attribute&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Subscript&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Starred&gt;&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Attributes</span>
    <span class="s1">&#39;&lt;Attribute&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Attribute(value=&lt;expr&gt;, attr=&lt;identifier&gt;, ctx=Load())&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Attribute(value=&lt;expr&gt;, attr=&lt;identifier&gt;, ctx=Del())&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Subscripts</span>
    <span class="s1">&#39;&lt;Subscript&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Subscript(value=&lt;expr&gt;, slice=&lt;Slice&gt;, ctx=Load())&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Subscript(value=&lt;expr&gt;, slice=&lt;Slice&gt;, ctx=Del())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;Slice&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Slice()&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Slice(&lt;expr&gt;)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Slice(&lt;expr&gt;, &lt;expr&gt;)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Slice(&lt;expr&gt;, &lt;expr&gt;, &lt;expr&gt;)&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Starred</span>
    <span class="s1">&#39;&lt;Starred&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Starred(value=&lt;expr&gt;, ctx=Load())&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Starred(value=&lt;expr&gt;, ctx=Del())&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># We&#39;re extending the set of callers a bit</span>
    <span class="s1">&#39;&lt;func&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;Name&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Attribute&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Subscript&gt;&#39;</span> <span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;Attribute&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Subscript&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Starred&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Attribute&gt;
{}.zZ                                    # Attribute(value=Dict(keys=[BoolOp(op=Or(), values=[Expr(value=UnaryOp(op=UAdd(), operand=Call(func=Name(id=&#39;e&#39;, ctx=Del()), args=[], keywords=[]))), BinOp(left=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]), Starred(value=Attribute(value=Tuple(elts=[Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())])], ctx=Load()), attr=&#39;HV&#39;, ctx=Load()), ctx=Del())], values=[]), attr=&#39;zZ&#39;, ctx=Del())
OON6Q9X8m1yqSkYJtGPI_bADfjMTaIhp._Rr5dHs2n7UwzFoLulcei3KCgW4EvxB60jmPP # Attribute(value=Name(id=&#39;OON6Q9X8m1yqSkYJtGPI_bADfjMTaIhp&#39;, ctx=Load()), attr=&#39;_Rr5dHs2n7UwzFoLulcei3KCgW4EvxB60jmPP&#39;, ctx=Del())
175 .M                                   # Attribute(value=Constant(value=175), attr=&#39;M&#39;, ctx=Del())
*[set() * set() + set() / set()][(set() &lt;&lt; set(), set() % set(), set() ** (set() &amp; set())):].Wn # Attribute(value=Starred(value=Subscript(value=List(elts=[BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Add(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))], ctx=Load()), slice=Slice(Tuple(elts=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))], ctx=Del())), ctx=Load()), ctx=Load()), attr=&#39;Wn&#39;, ctx=Del())
((-+set()[:]()[set():set():set()] | (not ~set().E())) @ &#39;&#39; // (None ^ False)).B # Attribute(value=BinOp(left=BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=UnaryOp(op=UAdd(), operand=Subscript(value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Del()))), op=BitOr(), right=UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Call(func=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;E&#39;, ctx=Del()), args=[], keywords=[])))), op=MatMult(), right=Constant(value=&#39;&#39;)), op=FloorDiv(), right=BinOp(left=Constant(value=None), op=BitXor(), right=Constant(value=False))), attr=&#39;B&#39;, ctx=Load())
((99.8) &gt;&gt; (True)[&#39;HAVsYE|,]@bXz!hguQimRwL0)2=W-8PteTK&lt;{c~*3}f$OandqF1%&amp;4IJ&quot;MjZ&gt;^k`pv;/U_?B.7[+y#(G 9S5CDoNrlx:6Z&#39;:&#39;S&#39;]).yM # Attribute(value=BinOp(left=BoolOp(op=And(), values=[Constant(value=99.8)]), op=RShift(), right=Subscript(value=BoolOp(op=And(), values=[Constant(value=True)]), slice=Slice(Constant(value=&#39;HAVsYE|,]@bXz!hguQimRwL0)2=W-8PteTK&lt;{c~*3}f$OandqF1%&amp;4IJ&quot;MjZ&gt;^k`pv;/U_?B.7[+y#(G 9S5CDoNrlx:6Z&#39;), Constant(value=&quot;S&quot;)), ctx=Del())), attr=&#39;yM&#39;, ctx=Del())
(((set()) &lt; set() == set()) not in set()).l # Attribute(value=Compare(left=Compare(left=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[Lt(), Eq()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), ops=[NotIn()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Name(id=&#39;c&#39;, ctx=Del())]), attr=&#39;l&#39;, ctx=Del())
vlL.CZ                                   # Attribute(value=Name(id=&#39;vlL&#39;, ctx=Load()), attr=&#39;CZ&#39;, ctx=Del())
w.nyuCk                                  # Attribute(value=Name(id=&#39;w&#39;, ctx=Del()), attr=&#39;nyuCk&#39;, ctx=Load())
Js.Za                                    # Attribute(value=Name(id=&#39;Js&#39;, ctx=Load()), attr=&#39;Za&#39;, ctx=Load())

&lt;Subscript&gt;
{279.0 &gt;&gt; [], -*set()[:][:](set(), set(), ())}[{}:] # Subscript(value=Set(elts=[BinOp(left=Constant(value=279.0), op=RShift(), right=List(elts=[BoolOp(op=And(), values=[])], ctx=Del())), UnaryOp(op=USub(), operand=Call(func=Subscript(value=Subscript(value=Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Load()), slice=Slice(), ctx=Del()), slice=Slice(), ctx=Load()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Load())], keywords=[]))]), slice=Slice(Dict(keys=[], values=[Name(id=&#39;U&#39;, ctx=Load())])), ctx=Del())
(set()).y[():b:
set()]                   # Subscript(value=Attribute(value=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), attr=&#39;y&#39;, ctx=Load()), slice=Slice(Tuple(elts=[], ctx=Del()), Name(id=&#39;b&#39;, ctx=Del()), Expr(value=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]))), ctx=Del())
(set() &lt;&lt; set() - set()).c[[set() @ set() // set()]:*(set() &amp; set()).z] # Subscript(value=Attribute(value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), attr=&#39;c&#39;, ctx=Load()), slice=Slice(List(elts=[BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load()), Starred(value=Attribute(value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), attr=&#39;z&#39;, ctx=Del()), ctx=Del())), ctx=Load())
((set() | set()) ^ set() ** set())[set() * set():(set() + set()) / set()] # Subscript(value=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), slice=Slice(BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Load())
None[&#39;t&#39;:]                               # Subscript(value=Constant(value=None), slice=Slice(Constant(value=&quot;t&quot;)), ctx=Load())
(not set().H(~set(), N=set()))[M():n():set()] # Subscript(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;H&#39;, ctx=Del()), args=[UnaryOp(op=Invert(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg=&#39;N&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])), slice=Slice(Call(func=Name(id=&#39;M&#39;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&#39;n&#39;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Del())
False[1632:]                             # Subscript(value=Constant(value=False), slice=Slice(Constant(value=1632)), ctx=Del())
((&#39;&#39;) % +(94 or True))[True or ((t)) is set() &lt;= Q:] # Subscript(value=BinOp(left=BoolOp(op=Or(), values=[Constant(value=&#39;&#39;)]), op=Mod(), right=UnaryOp(op=UAdd(), operand=BoolOp(op=Or(), values=[Constant(value=94), Constant(value=True)]))), slice=Slice(BoolOp(op=Or(), values=[Constant(value=True), Compare(left=Compare(left=Compare(left=Name(id=&#39;t&#39;, ctx=Load()), ops=[], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), ops=[], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), ops=[Is(), LtE()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Name(id=&#39;Q&#39;, ctx=Load()), Name(id=&#39;r&#39;, ctx=Del())])])), ctx=Load())
l7oUAETh5yCvxmRcgJ8[vtk3XeH:midn6Wa4]    # Subscript(value=Name(id=&#39;l7oUAETh5yCvxmRcgJ8&#39;, ctx=Load()), slice=Slice(Name(id=&#39;vtk3XeH&#39;, ctx=Load()), Name(id=&#39;midn6Wa4&#39;, ctx=Load())), ctx=Load())
JN0GQSzfYw1MLI2up6[gD9VZbsK_lqjrPOFB:]   # Subscript(value=Name(id=&#39;JN0GQSzfYw1MLI2up6&#39;, ctx=Load()), slice=Slice(Name(id=&#39;gD9VZbsK_lqjrPOFB&#39;, ctx=Del())), ctx=Load())

&lt;Starred&gt;
*[]                                      # Starred(value=List(elts=[], ctx=Del()), ctx=Load())
*(
{{set().j(K.J, Q=set()): (+*(set())[set():set():set()],)}, 440.7}) &gt;&gt; i # Starred(value=BinOp(left=BoolOp(op=And(), values=[Expr(value=Set(elts=[Dict(keys=[Call(func=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;j&#39;, ctx=Del()), args=[Attribute(value=Name(id=&#39;K&#39;, ctx=Del()), attr=&#39;J&#39;, ctx=Load())], keywords=[keyword(arg=&#39;Q&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])], values=[Tuple(elts=[UnaryOp(op=UAdd(), operand=Starred(value=Subscript(value=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Load()), ctx=Load()))], ctx=Del())]), Constant(value=440.7)]))]), op=RShift(), right=Name(id=&#39;i&#39;, ctx=Load())), ctx=Del())
*[set(), set(), set() @ set()][(set(), set() - set(), set() % set() / set() ** set()):] # Starred(value=Subscript(value=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load()), slice=Slice(Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))], ctx=Load())), ctx=Del()), ctx=Load())
*(set() ^ set()) &amp; (set() &lt;&lt; set()) + set() | set() * set() # Starred(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=BitOr(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Del())
*&#39;g&#39;                                     # Starred(value=Constant(value=&#39;g&#39;), ctx=Load())
*-None                                   # Starred(value=UnaryOp(op=USub(), operand=Constant(value=None)), ctx=Del())
*9523[:](set(), -set(), not ~set(), (not not set())[-(set() // set()):]) # Starred(value=Call(func=Subscript(value=Constant(value=9523), slice=Slice(), ctx=Del()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), UnaryOp(op=USub(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), Subscript(value=UnaryOp(op=Not(), operand=UnaryOp(op=Not(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), slice=Slice(UnaryOp(op=USub(), operand=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), BoolOp(op=Or(), values=[])), ctx=Load())], keywords=[]), ctx=Del())
*False                                   # Starred(value=Constant(value=False), ctx=Load())
*X(Y(q=set()), I=U(), D=set())           # Starred(value=Call(func=Name(id=&#39;X&#39;, ctx=Load()), args=[Call(func=Name(id=&#39;Y&#39;, ctx=Load()), args=[], keywords=[keyword(arg=&#39;q&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])], keywords=[keyword(arg=&#39;I&#39;, value=Call(func=Name(id=&#39;U&#39;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;D&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]), ctx=Del())
*&#39;#&#39;                                     # Starred(value=Constant(value=&quot;#&quot;), ctx=Del())
</pre></div>
</div>
</div>
</div>
</section>
<section id="id3">
<h3>End of Excursion<a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-variable-assignments">
<h3>Excursion: Variable Assignments<a class="headerlink" href="#excursion-variable-assignments" title="Link to this heading">#</a></h3>
<p>Now for variable assignments. These make things more complex, as we have a restricted set of expressions on the left hand side of an assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;stmt&gt;&#39;</span> <span class="p">],</span>

    <span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;Assign&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;AugAssign&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;Expr&gt;&#39;</span>
    <span class="p">],</span>

    <span class="c1"># Assignments</span>
    <span class="s1">&#39;&lt;Assign&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Assign(targets=&lt;nonempty_lhs_expr_list&gt;, value=&lt;expr&gt;&lt;type_comment&gt;?)&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;type_comment&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, type_comment=&lt;string&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;AugAssign&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;AugAssign(target=&lt;lhs_expr&gt;, op=&lt;operator&gt;, value=&lt;expr&gt;)&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Lists of left-hand side expressions</span>
    <span class="c1"># &#39;&lt;lhs_expr_list&gt;&#39;: [ &#39;[&lt;lhs_exprs&gt;?]&#39; ],</span>
    <span class="s1">&#39;&lt;nonempty_lhs_expr_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;lhs_exprs&gt;]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;lhs_exprs&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;lhs_expr&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;lhs_exprs&gt;, &lt;lhs_expr&gt;&#39;</span> <span class="p">],</span>

    <span class="c1"># On the left-hand side of assignments, we allow a number of structures</span>
    <span class="s1">&#39;&lt;lhs_expr&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;lhs_Name&gt;&#39;</span><span class="p">,</span>  <span class="c1"># Most common</span>
        <span class="s1">&#39;&lt;lhs_List&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;lhs_Tuple&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;lhs_Attribute&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;lhs_Subscript&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;lhs_Starred&gt;&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">&#39;&lt;lhs_Name&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Name(id=&lt;identifier&gt;, ctx=Store())&#39;</span><span class="p">,</span> <span class="p">],</span>

    <span class="s1">&#39;&lt;lhs_List&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;List(elts=&lt;nonempty_lhs_expr_list&gt;, ctx=Store())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;lhs_Tuple&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Tuple(elts=&lt;nonempty_lhs_expr_list&gt;, ctx=Store())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;lhs_Attribute&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Attribute(value=&lt;lhs_expr&gt;, attr=&lt;identifier&gt;, ctx=Store())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;lhs_Subscript&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Subscript(value=&lt;lhs_expr&gt;, slice=&lt;Slice&gt;, ctx=Store())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;lhs_Starred&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Starred(value=&lt;lhs_expr&gt;, ctx=Store())&#39;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&lt;Assign&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;AugAssign&gt;&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Assign&gt;
*[(r,), (V, C[set():set()]), Z[set():].WDY3i] = () # type: * # Assign(targets=[Starred(value=List(elts=[Tuple(elts=[Name(id=&#39;r&#39;, ctx=Store())], ctx=Store()), Tuple(elts=[Name(id=&#39;V&#39;, ctx=Store()), Subscript(value=Name(id=&#39;C&#39;, ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store())], ctx=Store()), Attribute(value=Subscript(value=Name(id=&#39;Z&#39;, ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), attr=&#39;WDY3i&#39;, ctx=Store())], ctx=Store()), ctx=Store())], value=Tuple(elts=[], ctx=Load()), type_comment=&#39;*&#39;)
h[set():set():set()][set():*set():set()[:]()][:] = [set()].Yzt # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id=&#39;h&#39;, ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Load()), Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(), ctx=Store())], value=Attribute(value=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del()), attr=&#39;Yzt&#39;, ctx=Load()))
N[:][:][set():set():set()][{}:][:] = 
ExcXjv1h # type: R # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id=&#39;N&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(Dict(keys=[], values=[])), ctx=Store()), slice=Slice(BoolOp(op=Or(), values=[])), ctx=Store())], value=Expr(value=Name(id=&#39;ExcXjv1h&#39;, ctx=Del())), type_comment=&quot;R&quot;)
H[:][:][set():set():set()] = -set() # type: y{ # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id=&#39;H&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store())], value=UnaryOp(op=USub(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), type_comment=&#39;y{&#39;)
K[:][:] = a[:][set():set()] = False # type: USsF # Assign(targets=[Subscript(value=Subscript(value=Name(id=&#39;K&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id=&#39;a&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Constant(value=False), type_comment=&quot;USsF&quot;)
B[set():set()] = set()[:] &lt;&lt; (set()[:]) # type: K # Assign(targets=[Subscript(value=Name(id=&#39;B&#39;, ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), op=LShift(), right=Compare(left=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), ops=[], comparators=[])), type_comment=&#39;K&#39;)
sKC = fm = (*set().y, *{set()}) # type: L^}3QF # Assign(targets=[Name(id=&#39;sKC&#39;, ctx=Store()), Name(id=&#39;fm&#39;, ctx=Store())], value=Tuple(elts=[Starred(value=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;y&#39;, ctx=Del()), ctx=Del()), Starred(value=Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), ctx=Load())], ctx=Del()), type_comment=&#39;L^}3QF&#39;)
S = n = I = [set(), set(), F] # type: 8-h # Assign(targets=[Name(id=&#39;S&#39;, ctx=Store()), Name(id=&#39;n&#39;, ctx=Store()), Name(id=&#39;I&#39;, ctx=Store())], value=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Name(id=&#39;F&#39;, ctx=Load())], ctx=Load()), type_comment=&quot;8-h&quot;)
gy = set() % set() @ set() - (set() &amp; set()) # type: .~ # Assign(targets=[Name(id=&#39;gy&#39;, ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Sub(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), type_comment=&quot;.~&quot;)
cnoOWRu = set() * (set() &gt;&gt; set() ^ set() + set()) # type: [&#39;Ox# # Assign(targets=[Name(id=&#39;cnoOWRu&#39;, ctx=Store())], value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))), type_comment=&quot;[&#39;Ox#&quot;)

&lt;AugAssign&gt;
K &lt;&lt;= set()                              # AugAssign(target=Name(id=&#39;K&#39;, ctx=Store()), op=LShift(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))
(_, [A]).H ^= (*{}.a[set() | set():set():], False) # AugAssign(target=Attribute(value=Tuple(elts=[Name(id=&#39;_&#39;, ctx=Store()), List(elts=[Name(id=&#39;A&#39;, ctx=Store())], ctx=Store())], ctx=Store()), attr=&#39;H&#39;, ctx=Store()), op=BitXor(), value=Tuple(elts=[Subscript(value=Attribute(value=Starred(value=Dict(keys=[], values=[]), ctx=Del()), attr=&#39;a&#39;, ctx=Del()), slice=Slice(BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BoolOp(op=Or(), values=[])), ctx=Load()), Constant(value=False)], ctx=Load()))
*i[:][:][y():set()] -= [~(
set())]       # AugAssign(target=Subscript(value=Starred(value=Subscript(value=Subscript(value=Name(id=&#39;i&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), ctx=Store()), slice=Slice(Call(func=Name(id=&#39;y&#39;, ctx=Del()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), op=Sub(), value=List(elts=[UnaryOp(op=Invert(), operand=Compare(left=Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ops=[], comparators=[]))], ctx=Load()))
t3lmH[(set(), set()):] //= oxNerA8       # AugAssign(target=Subscript(value=Name(id=&#39;t3lmH&#39;, ctx=Store()), slice=Slice(Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())), ctx=Store()), op=FloorDiv(), value=Name(id=&#39;oxNerA8&#39;, ctx=Load()))
pdnk2WaQFLs @= {*[set()].Qc[set().x:]}   # AugAssign(target=Name(id=&#39;pdnk2WaQFLs&#39;, ctx=Store()), op=MatMult(), value=Set(elts=[Subscript(value=Starred(value=Attribute(value=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del()), attr=&#39;Qc&#39;, ctx=Load()), ctx=Load()), slice=Slice(Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;x&#39;, ctx=Load())), ctx=Del())]))
YMy **= (set() + (set() &amp; set())) / (None % (set() &gt;&gt; set())) # AugAssign(target=Name(id=&#39;YMy&#39;, ctx=Store()), op=Pow(), value=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=Div(), right=BinOp(left=Constant(value=None), op=Mod(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))))
rXvE0_VP7puUYSIJwg4qDZt9z6RjiChKGTofbBO15 *= +&#39;h&#39; # AugAssign(target=Name(id=&#39;rXvE0_VP7puUYSIJwg4qDZt9z6RjiChKGTofbBO15&#39;, ctx=Store()), op=Mult(), value=UnaryOp(op=UAdd(), operand=Constant(value=&quot;h&quot;)))
PFUN += not True[set():](991.2, J=None, k=False) # AugAssign(target=Name(id=&#39;PFUN&#39;, ctx=Store()), op=Add(), value=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Constant(value=True), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Del()), args=[Constant(value=991.2)], keywords=[keyword(arg=&#39;J&#39;, value=Constant(value=None)), keyword(arg=&#39;k&#39;, value=Constant(value=False))])))
g ^= (-set()).m(set(), , u=-set(), h=set()) # AugAssign(target=Name(id=&#39;g&#39;, ctx=Store()), op=BitXor(), value=Call(func=Attribute(value=UnaryOp(op=USub(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), attr=&#39;m&#39;, ctx=Load()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BoolOp(op=And(), values=[])], keywords=[keyword(arg=&#39;u&#39;, value=UnaryOp(op=USub(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), keyword(arg=&#39;h&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]))
Ce |= 448                                # AugAssign(target=Name(id=&#39;Ce&#39;, ctx=Store()), op=BitOr(), value=Constant(value=448))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id4">
<h3>End of Excursion<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-statements">
<h3>Excursion: Statements<a class="headerlink" href="#excursion-statements" title="Link to this heading">#</a></h3>
<p>Now for statements. There’s quite a lot of these.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;stmt&gt;&#39;</span> <span class="p">],</span>

    <span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">:</span> <span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">&#39;&lt;For&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;While&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;If&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;Return&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Delete&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Assert&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;Pass&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Break&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;Continue&gt;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&lt;With&gt;&#39;</span>
    <span class="p">],</span>

    <span class="c1"># Control structures</span>
    <span class="s1">&#39;&lt;For&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;For(target=&lt;lhs_expr&gt;, iter=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;, orelse=&lt;stmt_list&gt;&lt;type_comment&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;stmt_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;stmts&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;nonempty_stmt_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;stmts&gt;]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;stmts&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;stmt&gt;, &lt;stmts&gt;&#39;</span> <span class="p">],</span>

    <span class="s1">&#39;&lt;While&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;While(test=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;, orelse=&lt;stmt_list&gt;)&#39;</span>
    <span class="p">],</span>

    <span class="s1">&#39;&lt;If&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;If(test=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;&lt;orelse_param&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;orelse_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;, orelse=&lt;stmt_list&gt;&#39;</span>
    <span class="p">],</span>

    <span class="s1">&#39;&lt;With&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;With(items=&lt;withitem_list&gt;, body=&lt;nonempty_stmt_list&gt;&lt;type_comment&gt;?)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;withitem_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;withitems&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;withitems&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;withitem&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;withitems&gt;, &lt;withitem&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;withitem&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;withitem(context_expr=&lt;expr&gt;)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;withitem(context_expr=&lt;expr&gt;, optional_vars=&lt;lhs_expr&gt;)&#39;</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Other statements</span>
    <span class="s1">&#39;&lt;Return&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Return()&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Return(value=&lt;expr&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;Delete&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Delete(targets=&lt;expr_list&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;Assert&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Assert(test=&lt;expr&gt;)&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Assert(test=&lt;expr&gt;, msg=&lt;expr&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;Pass&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Pass()&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;Break&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Break()&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;Continue&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Continue()&#39;</span><span class="p">]</span>

    <span class="c1"># FIXME: A few more: AsyncFor, AsyncWith, Match, Try, TryStar</span>
    <span class="c1"># Import, ImportFrom, Global, Nonlocal...</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> \
        <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
        <span class="c1"># As of 3.13, orelse is optional</span>
        <span class="s1">&#39;&lt;If&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s1">&#39;If(test=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;&lt;orelse_param&gt;?)&#39;</span>
        <span class="p">],</span>
    <span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Assign&gt;
*[v[:][:][:]][{}:+*set()[:]()] = (XDBoW_Av,).L4 = (32.6,) # type:  # Assign(targets=[Starred(value=Subscript(value=List(elts=[Subscript(value=Subscript(value=Subscript(value=Name(id=&#39;v&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store())], ctx=Store()), slice=Slice(Dict(keys=[], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), UnaryOp(op=UAdd(), operand=Starred(value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[]), ctx=Load()))), ctx=Store()), ctx=Store()), Attribute(value=Tuple(elts=[Name(id=&#39;XDBoW_Av&#39;, ctx=Store())], ctx=Store()), attr=&#39;L4&#39;, ctx=Store())], value=Tuple(elts=[Constant(value=32.6)], ctx=Load()), type_comment=&quot;&quot;)
g[:][set():][[]::set()] = set()[:]       # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id=&#39;g&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), BoolOp(op=And(), values=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Compare(left=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), ops=[], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]))
W[:] = y[:][set():set():set()] = 
K18E # type: N # Assign(targets=[Subscript(value=Name(id=&#39;W&#39;, ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id=&#39;y&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Expr(value=Name(id=&#39;K18E&#39;, ctx=Load())), type_comment=&#39;N&#39;)
V = _ = (set() | set()).E # type: i0     # Assign(targets=[Name(id=&#39;V&#39;, ctx=Store()), Name(id=&#39;_&#39;, ctx=Store())], value=Attribute(value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), attr=&#39;E&#39;, ctx=Del()), type_comment=&quot;i0&quot;)
cZIujm3gC = eMePLrNVy9z2 # type: Wd~OC6+v02ey # Assign(targets=[Name(id=&#39;cZIujm3gC&#39;, ctx=Store())], value=Name(id=&#39;eMePLrNVy9z2&#39;, ctx=Del()), type_comment=&#39;Wd~OC6+v02ey&#39;)
Yf0lcOSaT = *[{set()}.b, (set(), set())] # type: *H&lt;u&amp;~|  # Assign(targets=[Name(id=&#39;Yf0lcOSaT&#39;, ctx=Store())], value=Starred(value=List(elts=[Attribute(value=Set(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), attr=&#39;b&#39;, ctx=Load()), Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())], ctx=Load()), ctx=Del()), type_comment=&quot;*H&lt;u&amp;~| &quot;)
N = i = ((set() ^ set()) &amp; set()) * (set() + set()) # type: +ps # Assign(targets=[Name(id=&#39;N&#39;, ctx=Store()), Name(id=&#39;i&#39;, ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), type_comment=&quot;+ps&quot;)
m = P = set() @ set() &lt;&lt; set() // set() # type: ]J # Assign(targets=[Name(id=&#39;m&#39;, ctx=Store()), Name(id=&#39;P&#39;, ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=LShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), type_comment=&#39;]J&#39;)
j = O = 18 % (set() / set()) # type: R?$6 # Assign(targets=[Name(id=&#39;j&#39;, ctx=Store()), Name(id=&#39;O&#39;, ctx=Store())], value=BinOp(left=Constant(value=18), op=Mod(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), type_comment=&quot;R?$6&quot;)
TGFJsqKdXkwb65xYnpHRh7UtQi4u = False # type: q(Q&gt;GHPBsa!|bUV9&amp;$w`Su.8-hAi3}7)#=LDx@5&quot;?Kgjkz,pt_r%XT1m/f{c*;^ZlIE: YRnoM4[F&lt; # Assign(targets=[Name(id=&#39;TGFJsqKdXkwb65xYnpHRh7UtQi4u&#39;, ctx=Store())], value=Constant(value=False), type_comment=&#39;q(Q&gt;GHPBsa!|bUV9&amp;$w`Su.8-hAi3}7)#=LDx@5&quot;?Kgjkz,pt_r%XT1m/f{c*;^ZlIE: YRnoM4[F&lt;&#39;)

&lt;AugAssign&gt;
(*krT_.qL2x,)[~[
set(), None, {}[:]].L:] //= (,) # AugAssign(target=Subscript(value=Tuple(elts=[Attribute(value=Starred(value=Name(id=&#39;krT_&#39;, ctx=Store()), ctx=Store()), attr=&#39;qL2x&#39;, ctx=Store())], ctx=Store()), slice=Slice(UnaryOp(op=Invert(), operand=Attribute(value=List(elts=[Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Constant(value=None), Subscript(value=Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], values=[]), slice=Slice(), ctx=Del())], ctx=Load()), attr=&#39;L&#39;, ctx=Load()))), ctx=Store()), op=FloorDiv(), value=Tuple(elts=[BoolOp(op=And(), values=[])], ctx=Del()))
[h[:], F[:], l[:][set():Z]] -= U(*set() | set()) # AugAssign(target=List(elts=[Subscript(value=Name(id=&#39;h&#39;, ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Name(id=&#39;F&#39;, ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id=&#39;l&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Name(id=&#39;Z&#39;, ctx=Load())), ctx=Store())], ctx=Store()), op=Sub(), value=Call(func=Name(id=&#39;U&#39;, ctx=Del()), args=[BinOp(left=Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Del()), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], keywords=[]))
Q[[]:set()][[]:set()[:]:set()[:]] &amp;= *(set(),).b # AugAssign(target=Subscript(value=Subscript(value=Name(id=&#39;Q&#39;, ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())), ctx=Store()), op=BitAnd(), value=Starred(value=Attribute(value=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load()), attr=&#39;b&#39;, ctx=Del()), ctx=Load()))
wnBzQMG &lt;&lt;= {set() @ set() ^ set() ** set() / set()} # AugAssign(target=Name(id=&#39;wnBzQMG&#39;, ctx=Store()), op=LShift(), value=Set(elts=[BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))]))
Psdhpk1YVICRcN0J4wDPjqZmE856iFUbKf9oASWlXgvtyH7Oeua3Lyt6 *= 48.5 # AugAssign(target=Name(id=&#39;Psdhpk1YVICRcN0J4wDPjqZmE856iFUbKf9oASWlXgvtyH7Oeua3Lyt6&#39;, ctx=Store()), op=Mult(), value=Constant(value=48.5))
a %= &#39;&#39;                                  # AugAssign(target=Name(id=&#39;a&#39;, ctx=Store()), op=Mod(), value=Constant(value=&quot;&quot;))
J += -True                               # AugAssign(target=Name(id=&#39;J&#39;, ctx=Store()), op=Add(), value=UnaryOp(op=USub(), operand=Constant(value=True)))
oU &gt;&gt;= set()[set():set():set()](E=set(), H=set()) # AugAssign(target=Name(id=&#39;oU&#39;, ctx=Store()), op=RShift(), value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Del()), args=[], keywords=[keyword(arg=&#39;E&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;H&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]))
N //= not +(not 7927416330)              # AugAssign(target=Name(id=&#39;N&#39;, ctx=Store()), op=FloorDiv(), value=UnaryOp(op=Not(), operand=UnaryOp(op=UAdd(), operand=UnaryOp(op=Not(), operand=Constant(value=7927416330)))))
s += &#39;&#39; or False or 8888 .W((set()), v=set(), Y=set()) # AugAssign(target=Name(id=&#39;s&#39;, ctx=Store()), op=Add(), value=BoolOp(op=Or(), values=[Constant(value=&#39;&#39;), Constant(value=False), Call(func=Attribute(value=Constant(value=8888), attr=&#39;W&#39;, ctx=Load()), args=[Compare(left=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[], comparators=[])], keywords=[keyword(arg=&#39;v&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;Y&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])]))

&lt;Expr&gt;

*{(None, n, [] &lt;&lt; +R()[{}.r::set().I])} # Expr(value=Expr(value=Starred(value=Set(elts=[Tuple(elts=[Constant(value=None), Name(id=&#39;n&#39;, ctx=Load()), BinOp(left=List(elts=[], ctx=Del()), op=LShift(), right=UnaryOp(op=UAdd(), operand=Subscript(value=Call(func=Name(id=&#39;R&#39;, ctx=Del()), args=[], keywords=[]), slice=Slice(Attribute(value=Dict(keys=[], values=[]), attr=&#39;r&#39;, ctx=Del()), BoolOp(op=Or(), values=[]), Compare(left=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;I&#39;, ctx=Load()), ops=[], comparators=[])), ctx=Del())))], ctx=Load())]), ctx=Del())))
(*((set() ^ set()) - (set() | set())) / (set() % set()), [set(), set() &gt;&gt; set(), set() // set(), set() + set()])[:] # Expr(value=Subscript(value=Tuple(elts=[Starred(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Sub(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=Div(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Load()), List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load())], ctx=Del()), slice=Slice(), ctx=Load()))
851648.62 * True &amp; 0                     # Expr(value=BinOp(left=BinOp(left=Constant(value=851648.62), op=Mult(), right=Constant(value=True)), op=BitAnd(), right=Constant(value=0)))
not -((set() @ set()) ** set()[:]())[set().z(_=set()):] # Expr(value=UnaryOp(op=Not(), operand=UnaryOp(op=USub(), operand=Subscript(value=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Pow(), right=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])), slice=Slice(Call(func=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;z&#39;, ctx=Del()), args=[], keywords=[keyword(arg=&#39;_&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])), ctx=Load()))))
&#39;N&#39;                                      # Expr(value=BoolOp(op=And(), values=[Constant(value=&quot;N&quot;)]))
(not ~&#39;f&#39;)[~False:+(17 == ZAEPSYo_lKJHf6my8xTR2wg9b3d71qBeC5Mj6)] # Expr(value=Subscript(value=UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Constant(value=&#39;f&#39;))), slice=Slice(UnaryOp(op=Invert(), operand=Constant(value=False)), UnaryOp(op=UAdd(), operand=Compare(left=Constant(value=17), ops=[Eq()], comparators=[Name(id=&#39;ZAEPSYo_lKJHf6my8xTR2wg9b3d71qBeC5Mj6&#39;, ctx=Load()), Name(id=&#39;FcVkWZ0hQsONnpzGLrXut4vFIDiUBa&#39;, ctx=Load())]))), ctx=Del()))
i                                        # Expr(value=Name(id=&#39;i&#39;, ctx=Load()))
o2                                       # Expr(value=Name(id=&#39;o2&#39;, ctx=Del()))
AR                                       # Expr(value=Name(id=&#39;AR&#39;, ctx=Load()))
Y                                        # Expr(value=Name(id=&#39;Y&#39;, ctx=Del()))

&lt;For&gt;
for U, [D, I] in []: # type: j
    set()
    m /= set() # For(target=Tuple(elts=[Name(id=&#39;U&#39;, ctx=Store()), List(elts=[Name(id=&#39;D&#39;, ctx=Store()), Name(id=&#39;I&#39;, ctx=Store())], ctx=Store())], ctx=Store()), iter=Compare(left=List(elts=[], ctx=Load()), ops=[Eq()], comparators=[]), body=[Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id=&#39;m&#39;, ctx=Store()), op=Div(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[], type_comment=&quot;j&quot;)
for *O.s in {}: # type: }
    with :
        break
    assert set()
else:
    pass
    return # For(target=Starred(value=Attribute(value=Name(id=&#39;O&#39;, ctx=Store()), attr=&#39;s&#39;, ctx=Store()), ctx=Store()), iter=Dict(keys=[], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), body=[With(items=[], body=[Break()]), Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[Pass(), Return()], type_comment=&#39;}&#39;)
for q[:][set():set():set()] in *set(): # type: 
    return
    return
else:
    continue
    continue # For(target=Subscript(value=Subscript(value=Name(id=&#39;q&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Load()), body=[Return(), Return()], orelse=[Continue(), Continue()], type_comment=&quot;&quot;)
for g[:][set():] in 
set(): # type: 
    return
else:
    l = set()
    return # For(target=Subscript(value=Subscript(value=Name(id=&#39;g&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), body=[Return()], orelse=[Assign(targets=[Name(id=&#39;l&#39;, ctx=Store())], value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return()], type_comment=&quot;&quot;)
for v in set().F(): # type: 
    if set():
        return
    return # For(target=Name(id=&#39;v&#39;, ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;F&#39;, ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return()], orelse=[], type_comment=&quot;&quot;)
for Z[:] in +set(): # type: 
    del 
    return
else:
    while set():
        return # For(target=Subscript(value=Name(id=&#39;Z&#39;, ctx=Store()), slice=Slice(), ctx=Store()), iter=UnaryOp(op=UAdd(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), body=[Delete(targets=[]), Return()], orelse=[While(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])], type_comment=&quot;&quot;)
for z[set():set()] in (): # type: L
    for o in set(): # type: 
        return
else:
    return
    return # For(target=Subscript(value=Name(id=&#39;z&#39;, ctx=Store()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Tuple(elts=[], ctx=Load()), body=[For(target=Name(id=&#39;o&#39;, ctx=Store()), iter=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[], type_comment=&#39;&#39;)], orelse=[Return(), Return()], type_comment=&quot;L&quot;)
for G[:] in True .KA: # type: 
    assert set(), set()
else:
    return # For(target=Subscript(value=Name(id=&#39;G&#39;, ctx=Store()), slice=Slice(), ctx=Store()), iter=Attribute(value=Constant(value=True), attr=&#39;KA&#39;, ctx=Del()), body=[Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[Return()], type_comment=&#39;&#39;)
for b[:][set() ^ set():] in e[set():]: # type: #
    return
else:
    return # For(target=Subscript(value=Subscript(value=Name(id=&#39;b&#39;, ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BoolOp(op=And(), values=[])), ctx=Store()), iter=Subscript(value=Name(id=&#39;e&#39;, ctx=Load()), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Load()), body=[Return()], orelse=[Return()], type_comment=&#39;#&#39;)
for LNx in *wu: # type: ckM&lt;v
    return k
else:
    return # For(target=Name(id=&#39;LNx&#39;, ctx=Store()), iter=Starred(value=Name(id=&#39;wu&#39;, ctx=Del()), ctx=Del()), body=[Return(value=Name(id=&#39;k&#39;, ctx=Del()))], orelse=[Return()], type_comment=&quot;ckM&lt;v&quot;)

&lt;While&gt;
while 
k:
    pass                       # While(test=BoolOp(op=Or(), values=[Expr(value=Name(id=&#39;k&#39;, ctx=Load()))]), body=[Pass()], orelse=[])
while *set()[set().e:]:
    del 
    with :
        return
    return
    continue
else:
    break
    return # While(test=Subscript(value=Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Load()), slice=Slice(Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;e&#39;, ctx=Load())), ctx=Load()), body=[Delete(targets=[]), With(items=[], body=[Return()]), Return(), Continue()], orelse=[Break(), Return()])
while {}:
    for H[:] in set(): # type: 
        return
    else:
        return
else:
    l |= set()
    while set():
        return # While(test=Dict(keys=[], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), body=[For(target=Subscript(value=Name(id=&#39;H&#39;, ctx=Store()), slice=Slice(), ctx=Store()), iter=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[Return()], type_comment=&#39;&#39;)], orelse=[AugAssign(target=Name(id=&#39;l&#39;, ctx=Store()), op=BitOr(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), While(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])])
while &#39;C&#39;:
    set()
    return
else:
    t = set()
    if set():
        return
    return
    return # While(test=Constant(value=&quot;C&quot;), body=[Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return()], orelse=[Assign(targets=[Name(id=&#39;t&#39;, ctx=Store())], value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return(), Return()])
while (not set()) == set():
    assert set()
    return
else:
    assert set(), set()
    return # While(test=Compare(left=UnaryOp(op=Not(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ops=[Eq()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), body=[Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return()], orelse=[Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return()])
while () @ set():
    return [set(), set()]
    return
    return
    return
else:
    return set()[:]() # While(test=BinOp(left=Tuple(elts=[], ctx=Del()), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), body=[Return(value=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())), Return(), Return(), Return()], orelse=[Return(value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]))])
while *(set(),):
    (h,) //= X
    E &lt;&lt;= set()
else:
    P *= set().W # While(test=Starred(value=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Del()), body=[AugAssign(target=Tuple(elts=[Name(id=&#39;h&#39;, ctx=Store())], ctx=Store()), op=FloorDiv(), value=Name(id=&#39;X&#39;, ctx=Del())), AugAssign(target=Name(id=&#39;E&#39;, ctx=Store()), op=LShift(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Name(id=&#39;P&#39;, ctx=Store()), op=Mult(), value=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;W&#39;, ctx=Del()))])
while [{set() + set()}]:
    *[u] ^= {set() &amp; set() &gt;&gt; set(), set() / set()}
else:
    s.N %= set()
    m **= set() # While(test=List(elts=[Set(elts=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])], ctx=Load()), body=[AugAssign(target=Starred(value=List(elts=[Name(id=&#39;u&#39;, ctx=Store())], ctx=Store()), ctx=Store()), op=BitXor(), value=Set(elts=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]))], orelse=[AugAssign(target=Attribute(value=Name(id=&#39;s&#39;, ctx=Store()), attr=&#39;N&#39;, ctx=Store()), op=Mod(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id=&#39;m&#39;, ctx=Store()), op=Pow(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
while False:
    with set(), set(): # type: ^B
        x -= set()
else:
    v = +5 # type: % # While(test=Constant(value=False), body=[With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], body=[AugAssign(target=Name(id=&#39;x&#39;, ctx=Store()), op=Sub(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], type_comment=&#39;^B&#39;)], orelse=[Assign(targets=[Name(id=&#39;v&#39;, ctx=Store())], value=UnaryOp(op=UAdd(), operand=Constant(value=5)), type_comment=&#39;%&#39;)])
while ~Y():
    T = set()
    return
    return
else:
    p = set()[:]() # While(test=UnaryOp(op=Invert(), operand=Call(func=Name(id=&#39;Y&#39;, ctx=Del()), args=[], keywords=[])), body=[Assign(targets=[Name(id=&#39;T&#39;, ctx=Store())], value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return(), Return()], orelse=[Assign(targets=[Name(id=&#39;p&#39;, ctx=Store())], value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[]))])

&lt;If&gt;
if :
    return
    for [a] in set(): # type: 
        break
    pass
    continue
    return
else:
    del set()[:] # If(test=BoolOp(op=Or(), values=[]), body=[Return(), For(target=List(elts=[Name(id=&#39;a&#39;, ctx=Store())], ctx=Store()), iter=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Break()], orelse=[], type_comment=&quot;&quot;), Pass(), Continue(), Return()], orelse=[Delete(targets=[Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())])])
if set()[:]():
    set()
    u %= set()
    return
else:
    return
    return # If(test=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id=&#39;u&#39;, ctx=Store()), op=Mod(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return()], orelse=[Return(), Return()])
if None &gt;= set():
    assert set(), set().q
    return
    return
else:
    return # If(test=Compare(left=Constant(value=None), ops=[GtE()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), body=[Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), msg=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;q&#39;, ctx=Del())), Return(), Return()], orelse=[Return()])
if +va:
    while set():
        return
    if set():
        return
else:
    Z = *set() # If(test=UnaryOp(op=UAdd(), operand=Name(id=&#39;va&#39;, ctx=Load())), body=[While(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), If(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])], orelse=[Assign(targets=[Name(id=&#39;Z&#39;, ctx=Store())], value=Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Del()))])
if 
set() &lt;&lt; []:
    with :
        return
    assert ()
else:
    j &amp;= set()
    return set() # If(test=Expr(value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=List(elts=[], ctx=Load()))), body=[With(items=[], body=[Return()]), Assert(test=Tuple(elts=[], ctx=Del()))], orelse=[AugAssign(target=Name(id=&#39;j&#39;, ctx=Store()), op=BitAnd(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
if {set(): set()}:
    G[:] **= set()
else:
    (Q,) += set() # If(test=Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Subscript(value=Name(id=&#39;G&#39;, ctx=Store()), slice=Slice(), ctx=Store()), op=Pow(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Tuple(elts=[Name(id=&#39;Q&#39;, ctx=Store())], ctx=Store()), op=Add(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
if *(set(),):
    h |= set()
    D &gt;&gt;= set()
else:
    *W /= r # If(test=Starred(value=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Load()), body=[AugAssign(target=Name(id=&#39;h&#39;, ctx=Store()), op=BitOr(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id=&#39;D&#39;, ctx=Store()), op=RShift(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Starred(value=Name(id=&#39;W&#39;, ctx=Store()), ctx=Store()), op=Div(), value=Name(id=&#39;r&#39;, ctx=Del()))])
if {[set(), set(), set()]}:
    w[:].N ^= set().F
else:
    L[:].z *= set().C # If(test=Set(elts=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del())]), body=[AugAssign(target=Attribute(value=Subscript(value=Name(id=&#39;w&#39;, ctx=Store()), slice=Slice(), ctx=Store()), attr=&#39;N&#39;, ctx=Store()), op=BitXor(), value=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;F&#39;, ctx=Load()))], orelse=[AugAssign(target=Attribute(value=Subscript(value=Name(id=&#39;L&#39;, ctx=Store()), slice=Slice(), ctx=Store()), attr=&#39;z&#39;, ctx=Store()), op=Mult(), value=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;C&#39;, ctx=Load()))])
if 192:
    return
    k //= set()
else:
    y -= set()
    d @= set() # If(test=Constant(value=192), body=[Return(), AugAssign(target=Name(id=&#39;k&#39;, ctx=Store()), op=FloorDiv(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Name(id=&#39;y&#39;, ctx=Store()), op=Sub(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id=&#39;d&#39;, ctx=Store()), op=MatMult(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
if not True[set():set()]:
    S = False
else:
    E = J = set() # If(test=UnaryOp(op=Not(), operand=Subscript(value=Constant(value=True), slice=Slice(Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Load())), body=[Assign(targets=[Name(id=&#39;S&#39;, ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id=&#39;E&#39;, ctx=Store()), Name(id=&#39;J&#39;, ctx=Store())], value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])

&lt;Return&gt;
return ()                                # Return(value=Tuple(elts=[], ctx=Load()))
return                                   # Return()
return *[{set(): g(), set().k: set()[:], set(): False}, set()] # Return(value=Starred(value=List(elts=[Dict(keys=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;k&#39;, ctx=Load()), Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])], values=[Call(func=Name(id=&#39;g&#39;, ctx=Load()), args=[], keywords=[]), Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), Constant(value=False)]), BoolOp(op=Or(), values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])], ctx=Del()), ctx=Load()))
return O2sIF9wuGDe5hBzM10X7a &gt;&gt; (not 
{[*(set(), set())[set() ^ set():set() % set()]].idboHj}) # Return(value=BinOp(left=Name(id=&#39;O2sIF9wuGDe5hBzM10X7a&#39;, ctx=Del()), op=RShift(), right=UnaryOp(op=Not(), operand=Expr(value=Set(elts=[Attribute(value=List(elts=[Starred(value=Subscript(value=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del()), slice=Slice(BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Load()), ctx=Del())], ctx=Load()), attr=&#39;idboHj&#39;, ctx=Del())])))))
return ((set() | set()) &lt;&lt; set() - set()) @ (set() ** set() * (set() / set())) # Return(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=LShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=MatMult(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))))
return 7.33                              # Return(value=Constant(value=7.33))
return &#39;G&#39;                               # Return(value=Constant(value=&quot;G&quot;))
return ~-None &amp; set()[:](set(), X=set()) // +set()[:].c(set()[:], set()[:], l=set(), Q=set()) # Return(value=BinOp(left=UnaryOp(op=Invert(), operand=UnaryOp(op=USub(), operand=Constant(value=None))), op=BitAnd(), right=BinOp(left=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg=&#39;X&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]), op=FloorDiv(), right=UnaryOp(op=UAdd(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), attr=&#39;c&#39;, ctx=Del()), args=[Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())], keywords=[keyword(arg=&#39;l&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;Q&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])))))
return (set() + set() and 24)[&#39;&#39;[set() | set():set() % set():set()]:] # Return(value=Subscript(value=BoolOp(op=And(), values=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Constant(value=24)]), slice=Slice(Subscript(value=Constant(value=&#39;&#39;), slice=Slice(BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Load())), ctx=Load()))
return (oiLk &lt; set() != set()) &gt; 496 &lt;= True # Return(value=Compare(left=Compare(left=Name(id=&#39;oiLk&#39;, ctx=Del()), ops=[Lt(), NotEq()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Name(id=&#39;f8&#39;, ctx=Del())]), ops=[Gt(), LtE()], comparators=[Constant(value=496), Constant(value=True)]))

&lt;Delete&gt;
del ((not {(set()[:]().PTA2)[*set():
{}]})) // True, [] # Delete(targets=[BinOp(left=Compare(left=UnaryOp(op=Not(), operand=Set(elts=[Subscript(value=BoolOp(op=And(), values=[Attribute(value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), attr=&#39;PTA2&#39;, ctx=Load())]), slice=Slice(Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Del()), Expr(value=Dict(keys=[], values=[]))), ctx=Load())])), ops=[], comparators=[Tuple(elts=[Name(id=&#39;G&#39;, ctx=Load())], ctx=Load())]), op=FloorDiv(), right=Constant(value=True)), List(elts=[], ctx=Del())])
del [set(), set(), set() / set()], *().QD, y4iFkwX # Delete(targets=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load()), Attribute(value=Starred(value=Tuple(elts=[], ctx=Del()), ctx=Load()), attr=&#39;QD&#39;, ctx=Del()), Name(id=&#39;y4iFkwX&#39;, ctx=Del())])
del set(), set(), set() ^ set(), set() % set() &gt;&gt; set() - set() @ set() # Delete(targets=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))))])
del set() &lt;&lt; set(), set() | set(), set() ** set(), set() * (set() + set()) # Delete(targets=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))])
del 6                                    # Delete(targets=[Constant(value=6)])
del &#39;_&#39;                                  # Delete(targets=[Constant(value=&#39;_&#39;)])
del ~50.413, +-set()[:][set() &amp; set():].F_(set() + set(), set()[:], L=set(), Z=set()) # Delete(targets=[UnaryOp(op=Invert(), operand=Constant(value=50.413)), UnaryOp(op=UAdd(), operand=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Subscript(value=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), slice=Slice(BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Load()), attr=&#39;F_&#39;, ctx=Del()), args=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del())], keywords=[keyword(arg=&#39;L&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), keyword(arg=&#39;Z&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])))])
del set() or None or z(), (set() and set())[False:c():T()] # Delete(targets=[BoolOp(op=Or(), values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Constant(value=None), Call(func=Name(id=&#39;z&#39;, ctx=Del()), args=[], keywords=[])]), Subscript(value=BoolOp(op=And(), values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), slice=Slice(Constant(value=False), Call(func=Name(id=&#39;c&#39;, ctx=Del()), args=[], keywords=[]), Call(func=Name(id=&#39;T&#39;, ctx=Load()), args=[], keywords=[])), ctx=Del())])
del &#39;&#39;                                   # Delete(targets=[Constant(value=&quot;&quot;)])
del k5vofh3xGZH == R1rc                  # Delete(targets=[Compare(left=Name(id=&#39;k5vofh3xGZH&#39;, ctx=Load()), ops=[Eq()], comparators=[Name(id=&#39;R1rc&#39;, ctx=Del()), Name(id=&#39;HPJup&#39;, ctx=Del())])])

&lt;Assert&gt;
assert {}                                # Assert(test=Dict(keys=[], values=[List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Constant(value=6.7), Attribute(value=BoolOp(op=Or(), values=[]), attr=&#39;Q&#39;, ctx=Del()), Compare(left=Expr(value=UnaryOp(op=Invert(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ops=[NotIn()], comparators=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])], ctx=Del())]))
assert Z4mcX(set(), o=set()), ICkz[*(set() ^ set(),):] # Assert(test=Call(func=Name(id=&#39;Z4mcX&#39;, ctx=Del()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg=&#39;o&#39;, value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))]), msg=Subscript(value=Name(id=&#39;ICkz&#39;, ctx=Load()), slice=Slice(Starred(value=Tuple(elts=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], ctx=Load()), ctx=Load())), ctx=Load()))
assert [().H, {().h}, *(set(),)[*set() / set():set() // set()]] # Assert(test=List(elts=[Attribute(value=Tuple(elts=[], ctx=Del()), attr=&#39;H&#39;, ctx=Del()), Set(elts=[Attribute(value=Tuple(elts=[], ctx=Del()), attr=&#39;h&#39;, ctx=Load())]), Subscript(value=Starred(value=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Del()), slice=Slice(Starred(value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Load()), BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Del())], ctx=Load()))
assert set() ** set() % (set() - set()), (set() &gt;&gt; (set() &amp; set())) + (set() | set()) * (set() &lt;&lt; set()) # Assert(test=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), msg=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=RShift(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), op=Add(), right=BinOp(left=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))))
assert None                              # Assert(test=Constant(value=None))
assert True                              # Assert(test=Constant(value=True))
assert not 331                           # Assert(test=UnaryOp(op=Not(), operand=Constant(value=331)))
assert -set()[:].x(set(), set()), +(not (set()[:]())[:]) # Assert(test=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), attr=&#39;x&#39;, ctx=Load()), args=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], keywords=[])), msg=UnaryOp(op=UAdd(), operand=UnaryOp(op=Not(), operand=Subscript(value=BoolOp(op=And(), values=[Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])]), slice=Slice(), ctx=Load()))))
assert &#39;X&#39; @ (set())[False:set()][&#39;&#39;:][False:][9:&#39;Rbw&#39;:&#39;m&#39;] # Assert(test=BinOp(left=Constant(value=&#39;X&#39;), op=MatMult(), right=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(Constant(value=False), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), ctx=Del()), slice=Slice(Constant(value=&quot;&quot;)), ctx=Load()), slice=Slice(Constant(value=False)), ctx=Load()), slice=Slice(Constant(value=9), Constant(value=&quot;Rbw&quot;), Constant(value=&quot;m&quot;)), ctx=Del())))
assert bwxOpNKPEWF6yVnaubG5BIrJ2lt3AiD97QMsvf_LjYeSZHqohR0g81TUd # Assert(test=Name(id=&#39;bwxOpNKPEWF6yVnaubG5BIrJ2lt3AiD97QMsvf_LjYeSZHqohR0g81TUd&#39;, ctx=Del()))

&lt;Pass&gt;
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()

&lt;Break&gt;
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()

&lt;Continue&gt;
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()

&lt;With&gt;
with :
    [c, (y,)] //= {}
    with set(), set(): # type: t
        return # With(items=[], body=[AugAssign(target=List(elts=[Name(id=&#39;c&#39;, ctx=Store()), Tuple(elts=[Name(id=&#39;y&#39;, ctx=Store())], ctx=Store())], ctx=Store()), op=FloorDiv(), value=Dict(keys=[], values=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;e&#39;, ctx=Load())])), With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], body=[Return()], type_comment=&#39;t&#39;)])
with set() as C, *set() as *P: # type: 
    while (set())[:]:
        break # With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), optional_vars=Name(id=&#39;C&#39;, ctx=Store())), withitem(context_expr=Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Del()), optional_vars=Starred(value=Name(id=&#39;P&#39;, ctx=Store()), ctx=Store()))], body=[While(test=Subscript(value=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(), ctx=Load()), body=[Break()], orelse=[])], type_comment=&quot;&quot;)
with &#39;&#39; as G[:]._: # type: H!
    del set(), set(), set()
    set()
    pass
    continue # With(items=[withitem(context_expr=Constant(value=&#39;&#39;), optional_vars=Attribute(value=Subscript(value=Name(id=&#39;G&#39;, ctx=Store()), slice=Slice(), ctx=Store()), attr=&#39;_&#39;, ctx=Store()))], body=[Delete(targets=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])]), Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Pass(), Continue()], type_comment=&quot;H!&quot;)
with : # type: |S9vg
    for B in set(): # type: 
        return # With(items=[withitem(context_expr=BoolOp(op=And(), values=[]))], body=[For(target=Name(id=&#39;B&#39;, ctx=Store()), iter=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[], type_comment=&quot;&quot;)], type_comment=&#39;|S9vg&#39;)
with () as Y[:]: # type: t&gt;A
    b = E = set() # With(items=[withitem(context_expr=Tuple(elts=[], ctx=Load()), optional_vars=Subscript(value=Name(id=&#39;Y&#39;, ctx=Store()), slice=Slice(), ctx=Store()))], body=[Assign(targets=[Name(id=&#39;b&#39;, ctx=Store()), Name(id=&#39;E&#39;, ctx=Store())], value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], type_comment=&quot;t&gt;A&quot;)
with set(), set() as K[:]: # type: f
    if set():
        return
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), optional_vars=Subscript(value=Name(id=&#39;K&#39;, ctx=Store()), slice=Slice(), ctx=Store()))], body=[If(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return(), Return()], type_comment=&quot;f&quot;)
with set(), set(), [], set() as r[:]: # type: n
    assert set()
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), withitem(context_expr=List(elts=[], ctx=Del())), withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), optional_vars=Subscript(value=Name(id=&#39;r&#39;, ctx=Store()), slice=Slice(), ctx=Store()))], body=[Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return(), Return()], type_comment=&#39;n&#39;)
with set() as v: # type: $5a?@c
    assert set(), set()
    return
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), optional_vars=Name(id=&#39;v&#39;, ctx=Store()))], body=[Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return(), Return(), Return()], type_comment=&quot;$5a?@c&quot;)
with set() as j: # type:  j
    return set()[:]()
    return
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), optional_vars=Name(id=&#39;j&#39;, ctx=Store()))], body=[Return(value=Call(func=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[])), Return(), Return(), Return()], type_comment=&#39; j&#39;)
with set(): # type: 
    J[:] &amp;= set() * set()
    h /= I
    return # With(items=[withitem(context_expr=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], body=[AugAssign(target=Subscript(value=Name(id=&#39;J&#39;, ctx=Store()), slice=Slice(), ctx=Store()), op=BitAnd(), value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), AugAssign(target=Name(id=&#39;h&#39;, ctx=Store()), op=Div(), value=Name(id=&#39;I&#39;, ctx=Load())), Return()], type_comment=&#39;&#39;)
</pre></div>
</div>
</div>
</div>
<p>Let us see if we can also <em>parse</em> code properly. Here is a sample:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">with_tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">with open(&#39;foo.txt&#39;) as myfile:</span>
<span class="s2">    content = myfile.readlines()</span>
<span class="s2">    if content is not None:</span>
<span class="s2">        print(content)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_stmts_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">)</span>
<span class="n">with_tree_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">with_tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># get the `With(...)` subtree</span>
<span class="nb">print</span><span class="p">(</span><span class="n">with_tree_str</span><span class="p">)</span>
<span class="n">with_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_stmts_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">with_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">with_tree_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>With(items=[withitem(context_expr=Call(func=Name(id=&#39;open&#39;, ctx=Load()), args=[Constant(value=&#39;foo.txt&#39;)], keywords=[]), optional_vars=Name(id=&#39;myfile&#39;, ctx=Store()))], body=[Assign(targets=[Name(id=&#39;content&#39;, ctx=Store())], value=Call(func=Attribute(value=Name(id=&#39;myfile&#39;, ctx=Load()), attr=&#39;readlines&#39;, ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id=&#39;content&#39;, ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id=&#39;print&#39;, ctx=Load()), args=[Name(id=&#39;content&#39;, ctx=Load())], keywords=[]))], orelse=[])])
</pre></div>
</div>
</div>
</div>
<p>It seems our grammar can also parse non-trivial code properly. We are doing well!</p>
</section>
<section id="id5">
<h3>End of Excursion<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-function-definitions">
<h3>Excursion: Function Definitions<a class="headerlink" href="#excursion-function-definitions" title="Link to this heading">#</a></h3>
<p>Now for function definitions.
Not too many surprises here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def f(a, b=1):</span>
<span class="s2">    pass</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Module(
    body=[
        FunctionDef(
            name=&#39;f&#39;,
            args=arguments(
                posonlyargs=[],
                args=[
                    arg(arg=&#39;a&#39;),
                    arg(arg=&#39;b&#39;)],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[
                    Constant(value=1)]),
            body=[
                Pass()],
            decorator_list=[])],
    type_ignores=[])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">:</span> <span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;stmt&gt;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span> <span class="p">],</span>

    <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;&lt;returns&gt;?&lt;type_comment&gt;?)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;decorator_list_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;, decorator_list=&lt;expr_list&gt;&#39;</span>
    <span class="p">],</span>

    <span class="s1">&#39;&lt;arguments&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;arguments(&lt;posonlyargs_param&gt;args=&lt;arg_list&gt;&lt;vararg&gt;?&lt;kwonlyargs_param&gt;&lt;kw_defaults_param&gt;&lt;kwarg&gt;?&lt;defaults_param&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;posonlyargs_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;posonlyargs=&lt;arg_list&gt;, &#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;kwonlyargs_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;, kwonlyargs=&lt;arg_list&gt;&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;kw_defaults_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;, kw_defaults=&lt;expr_list&gt;&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;defaults_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;, defaults=&lt;expr_list&gt;&#39;</span>
    <span class="p">],</span>


    <span class="s1">&#39;&lt;arg_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;args&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;args&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;arg&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;arg&gt;, &lt;arg&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;arg&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;arg(arg=&lt;identifier&gt;)&#39;</span> <span class="p">],</span>

    <span class="s1">&#39;&lt;vararg&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, vararg=&lt;arg&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;kwarg&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, kwarg=&lt;arg&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;returns&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, returns=&lt;expr&gt;&#39;</span> <span class="p">],</span>

    <span class="c1"># FIXME: Not handled: AsyncFunctionDef, ClassDef</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>In Python 3.12 and later, function definitions also have a <code class="docutils literal notranslate"><span class="pre">type_param</span></code> field:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
    <span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;&lt;returns&gt;?&lt;type_comment&gt;?&lt;type_params&gt;?)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;type_params&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;, type_params=&lt;type_param_list&gt;&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;type_param_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;type_param&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;type_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;TypeVar&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;ParamSpec&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;TypeVarTuple&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;TypeVar&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;TypeVar(name=&lt;identifier&gt;(, bound=&lt;expr&gt;)?)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;ParamSpec&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;ParamSpec(name=&lt;identifier&gt;)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;TypeVarTuple&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;TypeVarTuple(name=&lt;identifier&gt;)&#39;</span>
    <span class="p">]</span>
    <span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>In Python 3.13 and later, several <code class="docutils literal notranslate"><span class="pre">&lt;FunctionDef&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;arguments&gt;</span></code> attributes are optional:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;?&lt;returns&gt;?&lt;type_comment&gt;?&lt;type_params&gt;?)&#39;</span>
    <span class="p">],</span>
    <span class="s1">&#39;&lt;arguments&gt;&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;arguments(&lt;posonlyargs_param&gt;?args=&lt;arg_list&gt;&lt;vararg&gt;?&lt;kwonlyargs_param&gt;?&lt;kw_defaults_param&gt;?&lt;kwarg&gt;?&lt;defaults_param&gt;?)&#39;</span>
    <span class="p">],</span>
    <span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;arguments&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;arguments&gt;
i, /, Wr, x                              # arguments(posonlyargs=[arg(arg=&#39;i&#39;)], args=[arg(arg=&#39;Wr&#39;), arg(arg=&#39;x&#39;)], kwonlyargs=[], kw_defaults=[List(elts=[UnaryOp(op=UAdd(), operand=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Dict(keys=[], values=[]), Name(id=&#39;P&#39;, ctx=Load())], ctx=Load())], defaults=[])
G, /, h=, *e, u=set(), **R3              # arguments(posonlyargs=[arg(arg=&#39;G&#39;)], args=[arg(arg=&#39;h&#39;)], vararg=arg(arg=&#39;e&#39;), kwonlyargs=[arg(arg=&#39;u&#39;)], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Starred(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ctx=Del())], kwarg=arg(arg=&#39;R3&#39;), defaults=[BoolOp(op=Or(), values=[])])
n, C, /, s, T=set(), *S, L=set(), **j    # arguments(posonlyargs=[arg(arg=&#39;n&#39;), arg(arg=&#39;C&#39;)], args=[arg(arg=&#39;s&#39;), arg(arg=&#39;T&#39;)], vararg=arg(arg=&#39;S&#39;), kwonlyargs=[arg(arg=&#39;L&#39;)], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], kwarg=arg(arg=&#39;j&#39;), defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])
F, z, /, Q, N, *Y, X=set(), **g          # arguments(posonlyargs=[arg(arg=&#39;F&#39;), arg(arg=&#39;z&#39;)], args=[arg(arg=&#39;Q&#39;), arg(arg=&#39;N&#39;)], vararg=arg(arg=&#39;Y&#39;), kwonlyargs=[arg(arg=&#39;X&#39;), arg(arg=&#39;I&#39;)], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], kwarg=arg(arg=&#39;g&#39;), defaults=[])
A=set(), /, B=set(), f=set(), *O6, K=set(), **Z # arguments(posonlyargs=[arg(arg=&#39;A&#39;)], args=[arg(arg=&#39;B&#39;), arg(arg=&#39;f&#39;)], vararg=arg(arg=&#39;O6&#39;), kwonlyargs=[arg(arg=&#39;K&#39;)], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], kwarg=arg(arg=&#39;Z&#39;), defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])
p, y=set(), /, H=
set(), *l, Jo=set(), **V # arguments(posonlyargs=[arg(arg=&#39;p&#39;), arg(arg=&#39;y&#39;)], args=[arg(arg=&#39;H&#39;)], vararg=arg(arg=&#39;l&#39;), kwonlyargs=[arg(arg=&#39;Jo&#39;)], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], kwarg=arg(arg=&#39;V&#39;), defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Expr(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
m, /, U, c, *w, **o                      # arguments(posonlyargs=[arg(arg=&#39;m&#39;)], args=[arg(arg=&#39;U&#39;), arg(arg=&#39;c&#39;)], vararg=arg(arg=&#39;w&#39;), kwonlyargs=[arg(arg=&#39;b&#39;), arg(arg=&#39;q&#39;)], kw_defaults=[], kwarg=arg(arg=&#39;o&#39;), defaults=[])
k, v, /, E, t=set() % set(), *_, **rR    # arguments(posonlyargs=[arg(arg=&#39;k&#39;), arg(arg=&#39;v&#39;)], args=[arg(arg=&#39;E&#39;), arg(arg=&#39;t&#39;)], vararg=arg(arg=&#39;_&#39;), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg=&#39;rR&#39;), defaults=[BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))])
M, /, D, *d, a=set(), **Z                # arguments(posonlyargs=[arg(arg=&#39;M&#39;)], args=[arg(arg=&#39;D&#39;)], vararg=arg(arg=&#39;d&#39;), kwonlyargs=[arg(arg=&#39;a&#39;)], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;F&#39;, ctx=Del())], kwarg=arg(arg=&#39;Z&#39;), defaults=[])
n, Y, /, g, y=set(), *z, **U             # arguments(posonlyargs=[arg(arg=&#39;n&#39;), arg(arg=&#39;Y&#39;)], args=[arg(arg=&#39;g&#39;), arg(arg=&#39;y&#39;)], vararg=arg(arg=&#39;z&#39;), kwonlyargs=[], kw_defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], kwarg=arg(arg=&#39;U&#39;), defaults=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])

&lt;FunctionDef&gt;
def U():
    return                      # FunctionDef(name=&#39;U&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[])
def F():
    pass                        # FunctionDef(name=&#39;F&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])
def u() -&gt; set(): # type: 
    continue  # FunctionDef(name=&#39;u&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Continue()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), type_comment=&quot;&quot;)
def D() -&gt; set(): # type: 
    break     # FunctionDef(name=&#39;D&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Break()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), type_comment=&#39;&#39;)
def w(): # type: 
    return             # FunctionDef(name=&#39;w&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment=&#39;&#39;)
def g() -&gt; set(): # type: 
    return    # FunctionDef(name=&#39;g&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), type_comment=&#39;&#39;)
def q() -&gt; set(): # type: 
    return    # FunctionDef(name=&#39;q&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), type_comment=&#39;&#39;)
def W() -&gt; set():
    return             # FunctionDef(name=&#39;W&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))
def I() -&gt; set():
    return             # FunctionDef(name=&#39;I&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))
def n() -&gt; set(): # type: 
    return    # FunctionDef(name=&#39;n&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), type_comment=&quot;&quot;)
</pre></div>
</div>
</div>
</div>
</section>
<section id="id6">
<h3>End of Excursion<a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
</section>
<section id="excursion-modules">
<h3>Excursion: Modules<a class="headerlink" href="#excursion-modules" title="Link to this heading">#</a></h3>
<p>We close with <em>modules</em> – sequences of definitions.
After all the other definitions, this is now fairly straightforward.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;mod&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;mod&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;Module&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;Module&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Module(body=&lt;nonempty_stmt_list&gt;&lt;type_ignore_param&gt;)&#39;</span><span class="p">],</span>

    <span class="s1">&#39;&lt;type_ignore_param&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;, type_ignores=&lt;type_ignore_list&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;type_ignore_list&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;[&lt;type_ignores&gt;?]&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;type_ignores&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;&lt;type_ignore&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;type_ignore&gt;, &lt;type_ignore&gt;&#39;</span> <span class="p">],</span>
    <span class="s1">&#39;&lt;type_ignore&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;TypeIgnore(lineno=&lt;integer&gt;, tag=&lt;string&gt;)&#39;</span> <span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> \
        <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
        <span class="c1"># As of 3.13, the type_ignore parameter is optional</span>
        <span class="s1">&#39;&lt;Module&gt;&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="s1">&#39;Module(body=&lt;nonempty_stmt_list&gt;&lt;type_ignore_param&gt;?)&#39;</span><span class="p">],</span>
    <span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;Module&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Module&gt;
EESc9e.w @ {
[*(not set())[y():set():{}]], } # Module(body=[Expr(value=BinOp(left=Attribute(value=Name(id=&#39;EESc9e&#39;, ctx=Del()), attr=&#39;w&#39;, ctx=Load()), op=MatMult(), right=Set(elts=[Expr(value=List(elts=[Starred(value=Subscript(value=UnaryOp(op=Not(), operand=Compare(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])), slice=Slice(Call(func=Name(id=&#39;y&#39;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Dict(keys=[], values=[])), ctx=Load()), ctx=Load())], ctx=Del())), BoolOp(op=And(), values=[])])))], type_ignores=[])
while (None, &#39;&#39;):
    m = set()
    del 
    return
else:
    break
    with :
        return
    pass
return
continue # Module(body=[While(test=Tuple(elts=[Constant(value=None), Constant(value=&#39;&#39;)], ctx=Load()), body=[Assign(targets=[Name(id=&#39;m&#39;, ctx=Store())], value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Delete(targets=[]), Return()], orelse=[Break(), With(items=[], body=[Return()]), Pass()]), Return(), Continue()], type_ignores=[TypeIgnore(lineno=27, tag=&#39;&#39;), TypeIgnore(lineno=2, tag=&quot;h&quot;)])
for I.V in set()[:]: # type: 
    return # Module(body=[For(target=Attribute(value=Name(id=&#39;I&#39;, ctx=Store()), attr=&#39;V&#39;, ctx=Store()), iter=Subscript(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), body=[Return()], orelse=[], type_comment=&quot;&quot;)], type_ignores=[TypeIgnore(lineno=131, tag=&#39;[bm&#39;)])
def Q():
    return
assert set().a
return # Module(body=[FunctionDef(name=&#39;Q&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[]), Assert(test=Attribute(value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), attr=&#39;a&#39;, ctx=Del())), Return()], type_ignores=[TypeIgnore(lineno=56, tag=&quot;M&quot;)])
if set():
    return
*h &lt;&lt;= set()        # Module(body=[If(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), AugAssign(target=Starred(value=Name(id=&#39;h&#39;, ctx=Store()), ctx=Store()), op=LShift(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], type_ignores=[TypeIgnore(lineno=8, tag=&quot;&quot;), TypeIgnore(lineno=5, tag=&quot;&quot;)])
return [set()]
assert (set(), set()), [] # Module(body=[Return(value=List(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Load())), Assert(test=Tuple(elts=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])], ctx=Del()), msg=List(elts=[], ctx=Del()))], type_ignores=[TypeIgnore(lineno=89, tag=&quot;&quot;), TypeIgnore(lineno=0, tag=&quot;Q&quot;)])
D |= set()                               # Module(body=[AugAssign(target=Name(id=&#39;D&#39;, ctx=Store()), op=BitOr(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))], type_ignores=[TypeIgnore(lineno=74, tag=&#39;1&#39;), TypeIgnore(lineno=90, tag=&quot;&quot;)])
[o, j] += *set() % set() ** set()        # Module(body=[AugAssign(target=List(elts=[Name(id=&#39;o&#39;, ctx=Store()), Name(id=&#39;j&#39;, ctx=Store())], ctx=Store()), op=Add(), value=Starred(value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mod(), right=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))), ctx=Del()))], type_ignores=[TypeIgnore(lineno=3980, tag=&quot;7&#39;Z&quot;)])
x[:] /= set()
i -= set() &amp; set()         # Module(body=[AugAssign(target=Subscript(value=Name(id=&#39;x&#39;, ctx=Store()), slice=Slice(), ctx=Store()), op=Div(), value=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id=&#39;i&#39;, ctx=Store()), op=Sub(), value=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])))], type_ignores=[TypeIgnore(lineno=40, tag=&#39;W2j&#39;)])
s //= -(set() * set())                   # Module(body=[AugAssign(target=Name(id=&#39;s&#39;, ctx=Store()), op=FloorDiv(), value=UnaryOp(op=USub(), operand=BinOp(left=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))))], type_ignores=[TypeIgnore(lineno=665, tag=&quot;&quot;), TypeIgnore(lineno=5, tag=&quot;&quot;)])
</pre></div>
</div>
</div>
</div>
</section>
<section id="id7">
<h3>End of Excursion<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>At this point, we have covered (almost) all AST elements of Python.
There would be a few more Python elements to consider (marked as <code class="docutils literal notranslate"><span class="pre">FIXME</span></code>, above), but we’ll leave these to the reader.
Let us define <code class="docutils literal notranslate"><span class="pre">PYTHON_AST_GRAMMAR</span></code> as the official grammar coming out of this chapter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_GRAMMAR</span> <span class="o">=</span> <span class="n">PYTHON_AST_MODULE_GRAMMAR</span>
<span class="n">python_ast_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here are a few (very weird) examples of Python functions we can produce.
All of these are valid, but only <em>syntactically</em> – very few of the code samples produced this way will actually result in something meaningful.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;FunctionDef&gt;
def w():
    pass                        # FunctionDef(name=&#39;w&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])
def a():
    break                       # FunctionDef(name=&#39;a&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Break()], decorator_list=[])
def o():
    return                      # FunctionDef(name=&#39;o&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[])
def v(): # type: 
    continue           # FunctionDef(name=&#39;v&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Continue()], decorator_list=[], type_comment=&#39;&#39;)
def j(): # type: 
    return             # FunctionDef(name=&#39;j&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment=&quot;&quot;)
def k():
    return
    return           # FunctionDef(name=&#39;k&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(), Return()], decorator_list=[])
def Q() -&gt; set(): # type: 
    return    # FunctionDef(name=&#39;Q&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), type_comment=&#39;&#39;)
def d() -&gt; None:
    return
    assert set(), set()
    return # FunctionDef(name=&#39;d&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(), Assert(test=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])), Return()], decorator_list=[], returns=Constant(value=None))
def K() -&gt; set():
    return             # FunctionDef(name=&#39;K&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[]))
def y(): # type: 
    return             # FunctionDef(name=&#39;y&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment=&#39;&#39;)
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="a-class-for-fuzzing-python">
<h2>A Class for Fuzzing Python<a class="headerlink" href="#a-class-for-fuzzing-python" title="Link to this heading">#</a></h2>
<p>For convenience, let us introduce a class <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> that makes use of the above grammar in order to produce Python code. This will be fairly easy to use.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PythonFuzzer</span><span class="p">(</span><span class="n">ISLaSolver</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Produce Python code.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">start_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">grammar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Grammar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kw_params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce Python code. Parameters are:</span>

<span class="sd">        * `start_symbol`: The grammatical entity to be generated (default: `&lt;FunctionDef&gt;`)</span>
<span class="sd">        * `grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`); and</span>
<span class="sd">        * `constraint` an ISLa constraint (if any).</span>

<span class="sd">        Additional keyword parameters are passed to the `ISLaSolver` superclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_symbol</span> <span class="o">=</span> <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span>
        <span class="k">if</span> <span class="n">grammar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grammar</span> <span class="o">=</span> <span class="n">PYTHON_AST_GRAMMAR</span>
        <span class="k">assert</span> <span class="n">start_symbol</span> <span class="ow">in</span> <span class="n">grammar</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">start_symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">start_symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fuzz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce a Python code string.&quot;&quot;&quot;</span>
        <span class="n">abstract_syntax_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()))</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> will produce a <em>function definition</em> - that is, a function header and body.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def L():
    continue
</pre></div>
</div>
</div>
</div>
<p>By passing a start symbol as parameter, you can have <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> produce arbitrary Python elements:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="s1">&#39;&lt;While&gt;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>while (set()[set():set()], *(set())):
    if {}:
        while set():
            continue
        break
    else:
        del 
        return
</pre></div>
</div>
</div>
</div>
<p>Here is a list of all possible start symbols:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;Assert&gt;&#39;,
 &#39;&lt;Assign&gt;&#39;,
 &#39;&lt;Attribute&gt;&#39;,
 &#39;&lt;AugAssign&gt;&#39;,
 &#39;&lt;BinOp&gt;&#39;,
 &#39;&lt;BoolOp&gt;&#39;,
 &#39;&lt;Break&gt;&#39;,
 &#39;&lt;Call&gt;&#39;,
 &#39;&lt;Compare&gt;&#39;,
 &#39;&lt;Constant&gt;&#39;,
 &#39;&lt;Continue&gt;&#39;,
 &#39;&lt;Delete&gt;&#39;,
 &#39;&lt;Dict&gt;&#39;,
 &#39;&lt;EmptySet&gt;&#39;,
 &#39;&lt;Expr&gt;&#39;,
 &#39;&lt;For&gt;&#39;,
 &#39;&lt;FunctionDef&gt;&#39;,
 &#39;&lt;If&gt;&#39;,
 &#39;&lt;List&gt;&#39;,
 &#39;&lt;Module&gt;&#39;,
 &#39;&lt;Name&gt;&#39;,
 &#39;&lt;Pass&gt;&#39;,
 &#39;&lt;Return&gt;&#39;,
 &#39;&lt;Set&gt;&#39;,
 &#39;&lt;Slice&gt;&#39;,
 &#39;&lt;Starred&gt;&#39;,
 &#39;&lt;Subscript&gt;&#39;,
 &#39;&lt;Tuple&gt;&#39;,
 &#39;&lt;UnaryOp&gt;&#39;,
 &#39;&lt;While&gt;&#39;,
 &#39;&lt;With&gt;&#39;,
 &#39;&lt;arg&gt;&#39;,
 &#39;&lt;arg_list&gt;&#39;,
 &#39;&lt;args&gt;&#39;,
 &#39;&lt;args_param&gt;&#39;,
 &#39;&lt;arguments&gt;&#39;,
 &#39;&lt;bool&gt;&#39;,
 &#39;&lt;boolop&gt;&#39;,
 &#39;&lt;cmpop&gt;&#39;,
 &#39;&lt;cmpop_list&gt;&#39;,
 &#39;&lt;cmpops&gt;&#39;,
 &#39;&lt;decorator_list_param&gt;&#39;,
 &#39;&lt;defaults_param&gt;&#39;,
 &#39;&lt;digit&gt;&#39;,
 &#39;&lt;digits&gt;&#39;,
 &#39;&lt;expr&gt;&#39;,
 &#39;&lt;expr_list&gt;&#39;,
 &#39;&lt;exprs&gt;&#39;,
 &#39;&lt;float&gt;&#39;,
 &#39;&lt;func&gt;&#39;,
 &#39;&lt;id&gt;&#39;,
 &#39;&lt;id_continue&gt;&#39;,
 &#39;&lt;id_start&gt;&#39;,
 &#39;&lt;identifier&gt;&#39;,
 &#39;&lt;integer&gt;&#39;,
 &#39;&lt;keyword&gt;&#39;,
 &#39;&lt;keyword_list&gt;&#39;,
 &#39;&lt;keywords&gt;&#39;,
 &#39;&lt;keywords_param&gt;&#39;,
 &#39;&lt;kw_defaults_param&gt;&#39;,
 &#39;&lt;kwarg&gt;&#39;,
 &#39;&lt;kwonlyargs_param&gt;&#39;,
 &#39;&lt;lhs_Attribute&gt;&#39;,
 &#39;&lt;lhs_List&gt;&#39;,
 &#39;&lt;lhs_Name&gt;&#39;,
 &#39;&lt;lhs_Starred&gt;&#39;,
 &#39;&lt;lhs_Subscript&gt;&#39;,
 &#39;&lt;lhs_Tuple&gt;&#39;,
 &#39;&lt;lhs_expr&gt;&#39;,
 &#39;&lt;lhs_exprs&gt;&#39;,
 &#39;&lt;literal&gt;&#39;,
 &#39;&lt;mod&gt;&#39;,
 &#39;&lt;none&gt;&#39;,
 &#39;&lt;nonempty_expr_list&gt;&#39;,
 &#39;&lt;nonempty_lhs_expr_list&gt;&#39;,
 &#39;&lt;nonempty_stmt_list&gt;&#39;,
 &#39;&lt;nonzerodigit&gt;&#39;,
 &#39;&lt;not_double_quotes&gt;&#39;,
 &#39;&lt;not_single_quotes&gt;&#39;,
 &#39;&lt;operator&gt;&#39;,
 &#39;&lt;orelse_param&gt;&#39;,
 &#39;&lt;posonlyargs_param&gt;&#39;,
 &#39;&lt;returns&gt;&#39;,
 &#39;&lt;start&gt;&#39;,
 &#39;&lt;stmt&gt;&#39;,
 &#39;&lt;stmt_list&gt;&#39;,
 &#39;&lt;stmts&gt;&#39;,
 &#39;&lt;string&gt;&#39;,
 &#39;&lt;type_comment&gt;&#39;,
 &#39;&lt;type_ignore&gt;&#39;,
 &#39;&lt;type_ignore_list&gt;&#39;,
 &#39;&lt;type_ignore_param&gt;&#39;,
 &#39;&lt;type_ignores&gt;&#39;,
 &#39;&lt;unaryop&gt;&#39;,
 &#39;&lt;vararg&gt;&#39;,
 &#39;&lt;withitem&gt;&#39;,
 &#39;&lt;withitem_list&gt;&#39;,
 &#39;&lt;withitems&gt;&#39;]
</pre></div>
</div>
</div>
</div>
</section>
<section id="customizing-the-python-fuzzer">
<h2>Customizing the Python Fuzzer<a class="headerlink" href="#customizing-the-python-fuzzer" title="Link to this heading">#</a></h2>
<p>When fuzzing, you may be interested in <em>specific</em> properties of the produced output. How can we influence the code that <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> produces? We explore two ways:</p>
<ul class="simple">
<li><p>By adjusting the <em>grammar</em> to our needs</p></li>
<li><p>By adding <em>constraints</em> that customize the output for us.</p></li>
</ul>
<section id="adjusting-the-grammar">
<h3>Adjusting the Grammar<a class="headerlink" href="#adjusting-the-grammar" title="Link to this heading">#</a></h3>
<p>A simple way to adjust output generation is to <em>adapt the grammar</em>.</p>
<p>Let us assume you’d like to have function definitions without decorators.
To achieve this, you can <em>alter the rule that produces function definitions</em>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">[</span><span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;&lt;returns&gt;?&lt;type_comment&gt;?)&#39;]
</pre></div>
</div>
</div>
</div>
<p>As any AST rule, it comes in <em>abstract syntax</em>, so we first have to identify the element we’d like to adjust.
In our case, this is <code class="docutils literal notranslate"><span class="pre">decorator_list</span></code>.</p>
<p>Since decorator_list is a list, we can alter the rule to produce empty lists only.
To create a new adapted grammar, we do not alter the existing <code class="docutils literal notranslate"><span class="pre">PYTHON_AST_GRAMMAR</span></code>.
Instead, we use the <code class="docutils literal notranslate"><span class="pre">extend_grammar()</span></code> function to create a new grammar with a new, adapted rule for <code class="docutils literal notranslate"><span class="pre">&lt;FunctionDef&gt;</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_grammar_without_decorators</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">,</span>
<span class="p">{</span>
    <span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span> <span class="p">:</span>
        <span class="p">[</span><span class="s1">&#39;FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;, decorator_list=[])&#39;</span><span class="p">]</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>However, we’re not done yet.
We also need to ensure that our grammar is <em>valid</em>, as any misspelled nonterminal identifier will result in problems during production.
For this, we use the <code class="docutils literal notranslate"><span class="pre">is_valid_grammar()</span></code> function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ExpectError</span> <span class="kn">import</span> <span class="n">ExpectError</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;&lt;decorator_list_param&gt;&#39;: defined, but not used. Consider applying trim_grammar() on the grammar
&#39;&lt;returns&gt;&#39;: defined, but not used. Consider applying trim_grammar() on the grammar
&#39;&lt;decorator_list_param&gt;&#39;: unreachable from &lt;start&gt;. Consider applying trim_grammar() on the grammar
&#39;&lt;returns&gt;&#39;: unreachable from &lt;start&gt;. Consider applying trim_grammar() on the grammar
Traceback (most recent call last):
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_17604/3611578183.py&quot;, line 2, in &lt;module&gt;
    assert is_valid_grammar(python_ast_grammar_without_decorators)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError (expected)
</pre></div>
</div>
</div>
</div>
<p>We see that with our change, our grammar has an <em>orphaned rule</em>: The <code class="docutils literal notranslate"><span class="pre">&lt;returns&gt;</span></code> rule is no longer used.
This is because <code class="docutils literal notranslate"><span class="pre">&lt;returns&gt;</span></code> is part of the <code class="docutils literal notranslate"><span class="pre">&lt;type_annotation&gt;</span></code> we just have deleted.
(<code class="docutils literal notranslate"><span class="pre">&lt;type_annotation&gt;</span></code> is still used when defining types for variables.)</p>
<p>To fix this, we need to delete the <code class="docutils literal notranslate"><span class="pre">&lt;returns&gt;</span></code> rule from our grammar.
Fortunately, we have a function <code class="docutils literal notranslate"><span class="pre">trim_grammar()</span></code>, which deletes all orphaned rules:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_grammar_without_decorators</span> <span class="o">=</span> <span class="n">trim_grammar</span><span class="p">(</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With this, our grammar becomes valid…</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>… and we can use it for fuzzing - now without decorators:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">grammar</span><span class="o">=</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def X():
    break
</pre></div>
</div>
</div>
</div>
<p>Adjusting the grammar is straightforward once you understood the grammar structure, but the AST grammar is complex; also, your changes and extensions tie you closely to the grammar structure.
Carefully study how the individual rules are defined, above.</p>
</section>
<section id="using-constraints-for-customizing">
<h3>Using Constraints for Customizing<a class="headerlink" href="#using-constraints-for-customizing" title="Link to this heading">#</a></h3>
<p>A more elegant alternative to altering the grammar is to make use of <em>constraints</em> that tune the grammar to your needs.
Since <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> is derived from <code class="docutils literal notranslate"><span class="pre">ISLaSolver</span></code>, we can pass a <code class="docutils literal notranslate"><span class="pre">constraint</span></code> argument constraining the grammar, as discussed in the chapter on <a class="reference internal" href="FuzzingWithConstraints.html"><span class="std std-doc">fuzzing with constraints</span></a>.</p>
<p>If we want to have a function definition with 10 characters in each identifier, we make use of an ISLa constraint:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;str.len(&lt;id&gt;) = 10&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def yWOOLwypwp(): # type: 
    return
</pre></div>
</div>
</div>
</div>
<p>We can also constrain individual children – say, the actual identifier of the function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Also works (the &lt;identifier&gt; has quotes)</span>
<span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;&lt;FunctionDef&gt;.&lt;identifier&gt; = &quot;</span><span class="se">\&#39;</span><span class="s1">my_favorite_function</span><span class="se">\&#39;</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>@[set(), set()]
@set() | {}
@(-*set())[set():():
set()[:]()]
def my_favorite_function(dlFf=Qr, l1M=set(), *) -&gt; 942.5:
    return
</pre></div>
</div>
</div>
</div>
<p>Assume we want to test how the compiler handles large numbers. Let us define a constraint such that the function body (<code class="docutils literal notranslate"><span class="pre">&lt;nonempty_stmt_list&gt;</span></code>) contains at least one integer (<code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code>) with a value of at least 1000:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    exists &lt;integer&gt; x:</span>
<span class="sd">        (inside(x, &lt;nonempty_stmt_list&gt;) and str.to.int(x) &gt; 1000)</span>
<span class="sd">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>@[set(), +set(), 
set()]
@{set(): set(), set(): set()}
@(set(), *set() &amp; set())
def l(r, a, /, *uXLV, _=set()[:], **Z) -&gt; sdTYWE9b or {set(), set().R}.Vy != z1vw([]):
    del 1007
</pre></div>
</div>
</div>
</div>
<p>Assume we’d like to test compilers with non-trivial functions. Here’s how to define a constraint such that the function body has exactly <em>three</em> statements (<code class="docutils literal notranslate"><span class="pre">&lt;stmt&gt;</span></code>). Note that this can take more than a minute to resolve, but the result definitely is a nontrivial function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This will not work with ISLa 2</span>
<span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    forall &lt;FunctionDef&gt; def: count(def, &quot;&lt;stmt&gt;&quot;, &quot;3&quot;)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>@3.91
def V8(w, /, *, t=set(), C5D=set(), **foT6):
    if *{}.S[:] - ((set()) not in set() in set()):
        pass
    else:
        return
</pre></div>
</div>
</div>
</div>
<p>And finally, if we want the decorator list to be empty, as in our grammar-altering example, we can constrain the decorator list to be empty:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="c1"># with ExpectError(mute=True):</span>
<span class="c1">#     # Triggers an ISLa error (AssertionError)</span>
<span class="c1">#     fuzzer = PythonFuzzer(constraint=&#39;&#39;&#39;</span>
<span class="c1">#         str.contains(&lt;FunctionDef&gt;, &quot;decorator_list=[]&quot;)</span>
<span class="c1">#     &#39;&#39;&#39;)</span>
<span class="c1">#     print(fuzzer.fuzz())</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="c1"># with ExpectError(mute=True):</span>
<span class="c1">#     # Triggers an ISLa error (AssertionError)</span>
<span class="c1">#     fuzzer = PythonFuzzer(constraint=&#39;&lt;FunctionDef&gt;.&lt;expr_list&gt; = &quot;[]&quot;&#39;)</span>
<span class="c1">#     print(fuzzer.fuzz())</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s1">&#39;&lt;FunctionDef&gt;..&lt;expr_list&gt; = &quot;[]&quot;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def l(Jws4IzSPx_O2ajk687obQB3mflULCTJWnAv9GHg0YRtVNycueKFDMihZ5rXd1pqEo, /, *, **g):
    return
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="mutating-code">
<h2>Mutating Code<a class="headerlink" href="#mutating-code" title="Link to this heading">#</a></h2>
<p>When producing code for compilers (or actually, producing inputs in general), it is often a good idea to not just create <em>everything</em> from scratch, but rather to <em>mutate</em> existing inputs. This way, one can achieve a better balance between <em>common</em> inputs (the ones to mutate) and <em>uncommon inputs</em> (the new parts added via mutation).</p>
<section id="parsing-inputs">
<h3>Parsing Inputs<a class="headerlink" href="#parsing-inputs" title="Link to this heading">#</a></h3>
<p>To <em>mutate</em> inputs, we first need to be able to <em>parse</em> them. This is where a grammar is really put to test - can it really parse all possible code? This is why relying on an <em>existing</em> parser that is tried and proven (in our case the Python parser) and operating on an <em>abstraction</em> (in our case the AST) is really handy.</p>
<p>We already have seen how to parse code into an AST, using <code class="docutils literal notranslate"><span class="pre">ast.parse()</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>    <span class="c1"># A simple example</span>
    <span class="n">the_sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">the_sum</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_source</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
<span class="n">sum_tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sum_source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def sum(a, b):
    the_sum = a + b
    return the_sum
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
<span class="n">sum_str</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&quot;Module(body=[FunctionDef(name=&#39;sum&#39;, args=arguments(posonlyargs=[], args=[arg(arg=&#39;a&#39;), arg(arg=&#39;b&#39;)], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id=&#39;the_sum&#39;, ctx=Store())], value=BinOp(left=Name(id=&#39;a&#39;, ctx=Load()), op=Add(), right=Name(id=&#39;b&#39;, ctx=Load()))), Return(value=Name(id=&#39;the_sum&#39;, ctx=Load()))], decorator_list=[])], type_ignores=[])&quot;
</pre></div>
</div>
</div>
</div>
<p>Our grammar is able to parse this (non_trivial) string:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">sum_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To mutate the input, we first have to parse it into a <em>derivation tree</em> structure. This is (again) a tree representation of the code, but this time, using the elements of <em>our</em> grammar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sum_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us inspect what a derivation tree looks like. Alas, the string representation is very long and not that useful:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8737
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">repr</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)[:</span><span class="mi">200</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&quot;DerivationTree(&#39;&lt;start&gt;&#39;, (DerivationTree(&#39;&lt;mod&gt;&#39;, (DerivationTree(&#39;&lt;Module&gt;&#39;, (DerivationTree(&#39;Module(body=&#39;, (), id=495073), DerivationTree(&#39;&lt;nonempty_stmt_list&gt;&#39;, (DerivationTree(&#39;[&#39;, (), id=495071&quot;
</pre></div>
</div>
</div>
</div>
<p>However, we can <em>visualize</em> the derivation tree:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GrammarFuzzer</span> <span class="kn">import</span> <span class="n">display_tree</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display_tree</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/d829dcb486ecabd39d17a5f36a8d7e90194a28dc8b11cce9d78db1279237cf8d.svg" src="_images/d829dcb486ecabd39d17a5f36a8d7e90194a28dc8b11cce9d78db1279237cf8d.svg" />
</div>
</div>
<p>We see that a derivation tree consists of <em>nonterminal</em> nodes whose children make up an <em>expansion</em> from the grammar.
For instance, at the very top, we see that a <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> nonterminal expands into a <code class="docutils literal notranslate"><span class="pre">&lt;mod&gt;</span></code> nonterminal, which again expands into a <code class="docutils literal notranslate"><span class="pre">&lt;Module&gt;</span></code> nonterminal.
This comes right from the grammar rules</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;mod&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>and</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;mod&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;Module&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>The child of <code class="docutils literal notranslate"><span class="pre">&lt;mod&gt;</span></code> is a <code class="docutils literal notranslate"><span class="pre">&lt;Module&gt;</span></code>, which expands into the nodes</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(body=</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;nonempty_stmt_list&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">type_ignores=</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;type_ignore_list&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">)</span></code></p></li>
</ul>
<p>Here, nodes like <code class="docutils literal notranslate"><span class="pre">(body=</span></code> or <code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">type_ignores=</span></code> are called <em>terminal</em> nodes (because they have no more elements to expand).
The nonterminals like <code class="docutils literal notranslate"><span class="pre">&lt;nonempty_stmt_list&gt;</span></code> get expanded further below – notably, <code class="docutils literal notranslate"><span class="pre">&lt;nonempty_stmt_list&gt;</span></code> expands into a <code class="docutils literal notranslate"><span class="pre">&lt;FunctionDef&gt;</span></code> node that represents the <code class="docutils literal notranslate"><span class="pre">sum()</span></code> definition.</p>
<p>Again, the structure exactly follows the <code class="docutils literal notranslate"><span class="pre">&lt;Module&gt;</span></code> definition in our grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;Module&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;Module(body=&lt;nonempty_stmt_list&gt;&lt;type_ignore_param&gt;)&#39;]
</pre></div>
</div>
</div>
</div>
<p>If we traverse the tree depth-first, left to right, and only collect the terminal symbols, we obtain the original string we parsed.
Applying the <code class="docutils literal notranslate"><span class="pre">str()</span></code> function to the derivation tree gets us exactly that string:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&quot;Module(body=[FunctionDef(name=&#39;sum&#39;, args=arguments(posonlyargs=[], args=[arg(arg=&#39;a&#39;), arg(arg=&#39;b&#39;)], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id=&#39;the_sum&#39;, ctx=Store())], value=BinOp(left=Name(id=&#39;a&#39;, ctx=Load()), op=Add(), right=Name(id=&#39;b&#39;, ctx=Load()))), Return(value=Name(id=&#39;the_sum&#39;, ctx=Load()))], decorator_list=[])], type_ignores=[])&quot;
</pre></div>
</div>
</div>
</div>
<p>And again, we can convert this string into an AST and thus obtain our original function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_ast</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def sum(a, b):
    the_sum = a + b
    return the_sum
</pre></div>
</div>
</div>
</div>
</section>
<section id="mutating-inputs">
<h3>Mutating Inputs<a class="headerlink" href="#mutating-inputs" title="Link to this heading">#</a></h3>
<p>With derivation trees, we can have a <em>structured</em> representation of our input. In our case, we already have that with ASTs, so why bother introducing a new one? The answer is simple: Derivation trees also allow us to <em>synthesize</em> new inputs, because we have a <em>grammar</em> that describes their structure.</p>
<p>Most notably, we can mutate inputs as follows:</p>
<ol class="arabic simple">
<li><p>Parse the input into a derivation tree, as shown above.</p></li>
<li><p>Randomly choose some node <code class="docutils literal notranslate"><span class="pre">&lt;symbol&gt;</span></code> in the derivation tree to be mutated.</p></li>
<li><p>Use the grammar to produce a new expansion for <code class="docutils literal notranslate"><span class="pre">&lt;symbol&gt;</span></code>.</p></li>
<li><p>Replace the children of <code class="docutils literal notranslate"><span class="pre">&lt;symbol&gt;</span></code> by the expansion just generated.</p></li>
<li><p>Repeat the process as often as needed.</p></li>
</ol>
<p>This is a decent programming task, and if you’d like a blueprint, have a look at the <code class="docutils literal notranslate"><span class="pre">FragmentMutator</span></code> in this tutorial on <a class="reference external" href="https://www.fuzzingbook.org/html/GreyboxGrammarFuzzer.html">greybox fuzzing with grammars</a>.</p>
<p>Fortunately, ISLa already provides us with functionality that does exactly this.
The <code class="docutils literal notranslate"><span class="pre">ISLaSolver.mutate()</span></code> method takes an input and mutates it according to the rules in the grammar.
The input to mutate can be given as a derivation tree, or as a string; its output is a derivation tree (which can again be converted into a string).</p>
<p>Let us apply <code class="docutils literal notranslate"><span class="pre">mutate()</span></code> on our <code class="docutils literal notranslate"><span class="pre">sum()</span></code> function. The <code class="docutils literal notranslate"><span class="pre">min_mutations</span></code> and <code class="docutils literal notranslate"><span class="pre">max_mutations</span></code> parameters define how many mutation steps should be performed; we set both to 1 in order to have exactly one mutation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_mutated_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">sum_str</span><span class="p">,</span> <span class="n">min_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_mutated_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sum_mutated_tree</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_mutated_ast</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def sum(a, b):
    the_sum = a + b
    return the_sum
</pre></div>
</div>
</div>
</div>
<p>Toy with the above to see the effect of a mutation.
Note if one of the top-level nodes (like <code class="docutils literal notranslate"><span class="pre">&lt;FunctionDef&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;Module&gt;</span></code>) is selected for mutation, then <code class="docutils literal notranslate"><span class="pre">sum()</span></code> will be replaced by something entirely different. Otherwise, though, the code will still be pretty similar to the original <code class="docutils literal notranslate"><span class="pre">sum()</span></code> code.</p>
<p>Of course, the more we increase the number of mutations, the more different the code will look like:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_mutated_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">sum_str</span><span class="p">,</span> <span class="n">min_mutations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_mutations</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_mutated_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sum_mutated_tree</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_mutated_ast</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def sum(a, b):
    the_9GuWCvL4cpgyi37K5I_ = a + b
    return the_jXHPe1oqMG
</pre></div>
</div>
</div>
</div>
<p>By toying with the <code class="docutils literal notranslate"><span class="pre">mutate()</span></code> parameters, we can control how <em>common</em> and how <em>uncommon</em> our input should be.</p>
</section>
<section id="how-effective-is-mutation">
<h3>How Effective is Mutation?<a class="headerlink" href="#how-effective-is-mutation" title="Link to this heading">#</a></h3>
<p>Does mutating existing code help us in finding bugs?
Let us assume we have a buggy compiler that generates bad code for an expression of the form <code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;</span> <span class="pre">*</span> <span class="pre">(&lt;elem&gt;</span> <span class="pre">+</span> <span class="pre">&lt;elem&gt;)</span></code>.
The code in <code class="docutils literal notranslate"><span class="pre">has_distributive_law()</span></code> checks an AST for the presence of this bug:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">has_distributive_law</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">walk</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>  <span class="c1"># iterate over all nodes in `tree`</span>
        <span class="c1"># print(node)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<p>To understand how this works, a visualization of the AST comes in handy:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">show_ast</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 + (2 * 3)&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/75199040055e469f08bb36167077adc8629b8bd829e67bfec2a9571bb21aa71e.svg" src="_images/75199040055e469f08bb36167077adc8629b8bd829e67bfec2a9571bb21aa71e.svg" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 * (2 + 3)&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;(1 + 2) * 3&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 + (2 * 3)&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>False
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;def f(a, b):</span><span class="se">\n</span><span class="s2">    return a * (b + 10)&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>How many attempts does it take for each until we find a mutation that triggers the bug in <code class="docutils literal notranslate"><span class="pre">has_distributive_law()</span></code>?
Let us write a function that computes this number.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">how_many_mutations</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">)</span>

    <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="n">code_ast_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="n">code_derivation_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">code_ast_str</span><span class="p">)</span>
    <span class="n">mutations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mutated_code_ast</span> <span class="o">=</span> <span class="n">code_ast</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">mutated_code_ast</span><span class="p">):</span>
        <span class="n">mutations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">mutations</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mutations</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">mutated_code_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">code_derivation_tree</span><span class="p">))</span>
        <span class="n">mutated_code_ast</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">mutated_code_str</span><span class="p">)</span>
        <span class="c1"># mutated_code_ast = ast.fix_missing_locations(mutated_code_ast)</span>
        <span class="c1"># print(ast.dump(mutated_code_ast))</span>
        <span class="c1"># print(ast.unparse(mutated_code_ast))</span>

    <span class="k">return</span> <span class="n">mutations</span>
</pre></div>
</div>
</div>
</div>
<p>If we pass an input that already exhibits the bug, we do not need any mutation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">how_many_mutations</span><span class="p">(</span><span class="s1">&#39;1 * (2 + 3)&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</div>
</div>
<p>However, the further we are away from the bug, the more mutations (and the more time) it takes to find it.
Notably, mutating <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">2</span></code> until we have a distributive law still is much faster than mutating <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">how_many_mutations</span><span class="p">(</span><span class="s1">&#39;2 + 2&#39;</span><span class="p">)</span>    <span class="c1"># &lt;-- Note: this can take a minute</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>54
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">how_many_mutations</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>  <span class="c1"># &lt;-- Note: this can take several minutes</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100...200...300...400...500...600...700...800...900...1000...1100...1200...1300...1400...1500...1600...1700...1800...1900...2000...2100...2200...2300...2400...2500...
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2500
</pre></div>
</div>
</div>
</div>
<p>We conclude that mutating existing code can indeed be helpful, especially if it is syntactically <em>close to inputs that trigger bugs</em>.
If you want to have a good chance in finding bugs, focus on <em>inputs that have triggered bugs before</em> – sometimes a simple mutation of these already helps finding a new bug.</p>
</section>
</section>
<section id="evolutionary-fuzzing">
<h2>Evolutionary Fuzzing<a class="headerlink" href="#evolutionary-fuzzing" title="Link to this heading">#</a></h2>
<p>One interesting application of mutating inputs is to use mutations for <em>evolutionary fuzzing</em>.
The idea is to have a population of inputs, to apply <em>mutations</em> on them, and to check whether they improve on a particular goal (mostly code coverage).
Those inputs that <em>do</em> improve are being retained (“survival of the fittest”) as the next generation, and evolved further.
By repeating this process often enough, we may obtain inputs that cover large parts of code and thus improve chances to uncover bugs.</p>
<p>Let us assume we have a buggy compiler that generates bad code for an expression of the form <code class="docutils literal notranslate"><span class="pre">&lt;elem&gt;</span> <span class="pre">*</span> <span class="pre">(&lt;elem&gt;</span> <span class="pre">+</span> <span class="pre">&lt;elem&gt;)</span></code>.
The function <code class="docutils literal notranslate"><span class="pre">has_distributive_law()</span></code>, above, checks an AST for the presence of this bug.</p>
<p>Our aim is to detect this bug via fuzzing. But if we simply generate random inputs from scratch, it may take a long time until we generate the exact copmbination of operators that triggers the bug.</p>
<section id="getting-coverage">
<h3>Getting Coverage<a class="headerlink" href="#getting-coverage" title="Link to this heading">#</a></h3>
<p>To have our fuzzers guided by coverage, we first need to <em>measure</em> code coverage.
We make use of the <a class="reference external" href="https://www.fuzzingbook.org/html/Coverage.html">Coverage module from the Fuzzing Book</a>, which is particularly easy to use.
It simply uses a <code class="docutils literal notranslate"><span class="pre">with</span></code> clause to obtain coverage from the code in the <code class="docutils literal notranslate"><span class="pre">with</span></code> body.
Here is how to obtain coverage for our <code class="docutils literal notranslate"><span class="pre">has_distributive_law()</span></code> code, above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Coverage</span> <span class="kn">import</span> <span class="n">Coverage</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mult_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 * 2&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
    <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">mult_ast</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">coverage()</span></code> method tells us which lines in the code actually have been reached.
This includes lines from <code class="docutils literal notranslate"><span class="pre">has_distributive_law()</span></code>, but also lines from other functions called.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{(&#39;_handle_fromlist&#39;, 1217),
 (&#39;_handle_fromlist&#39;, 1218),
 (&#39;_handle_fromlist&#39;, 1225),
 (&#39;_handle_fromlist&#39;, 1229),
 (&#39;_handle_fromlist&#39;, 1241),
 (&#39;has_distributive_law&#39;, 2),
 (&#39;has_distributive_law&#39;, 4),
 (&#39;has_distributive_law&#39;, 5),
 (&#39;has_distributive_law&#39;, 6),
 (&#39;has_distributive_law&#39;, 10),
 (&#39;has_distributive_law&#39;, 14),
 (&#39;iter_child_nodes&#39;, 272),
 (&#39;iter_child_nodes&#39;, 273),
 (&#39;iter_child_nodes&#39;, 274),
 (&#39;iter_child_nodes&#39;, 275),
 (&#39;iter_child_nodes&#39;, 276),
 (&#39;iter_child_nodes&#39;, 277),
 (&#39;iter_child_nodes&#39;, 278),
 (&#39;iter_fields&#39;, 260),
 (&#39;iter_fields&#39;, 261),
 (&#39;iter_fields&#39;, 262),
 (&#39;walk&#39;, 386),
 (&#39;walk&#39;, 387),
 (&#39;walk&#39;, 388),
 (&#39;walk&#39;, 389),
 (&#39;walk&#39;, 390),
 (&#39;walk&#39;, 391)}
</pre></div>
</div>
</div>
</div>
<p>Which are the lines executed?
With a bit of code inspection, we can easily visualize the covered lines:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">show_coverage</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
    <span class="n">fun_lines</span><span class="p">,</span> <span class="n">fun_start</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
    <span class="n">fun_name</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">coverage</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fun_lines</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">line</span> <span class="o">+</span> <span class="n">fun_start</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coverage</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;# &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1"># covered lines</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1"># uncovered lines</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">fun_start</span><span class="p">,</span> <span class="n">fun_lines</span><span class="p">[</span><span class="n">line</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">show_coverage</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">has_distributive_law</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  1 def has_distributive_law(tree) -&gt; bool:
# 2     for node in walk(tree):  # iterate over all nodes in `tree`
  3         # print(node)
# 4         if isinstance(node, ast.BinOp):
# 5             if isinstance(node.op, ast.Mult):
# 6                 if isinstance(node.right, ast.BinOp):
  7                     if isinstance(node.right.op, ast.Add):
  8                         return True
  9 
# 10                 if isinstance(node.left, ast.BinOp):
  11                     if isinstance(node.left.op, ast.Add):
  12                         return True
  13 
# 14     return False
</pre></div>
</div>
</div>
</div>
<p>In this listing, a <code class="docutils literal notranslate"><span class="pre">#</span></code> indicates that the code has been executed (covered).
We see that our input “1 * 2” satisfies the conditions in Lines 4 and 5, but does not satisfy the conditions in later lines.</p>
</section>
<section id="fitness">
<h3>Fitness<a class="headerlink" href="#fitness" title="Link to this heading">#</a></h3>
<p>Let us now use coverage as a <em>fitness function</em> to guide evolution.
The higher the fitness (the coverage), the higher the chances of an input to be retained for further evolution.
Our <code class="docutils literal notranslate"><span class="pre">ast_fitness()</span></code> function simply counts the number of lines covered in <code class="docutils literal notranslate"><span class="pre">has_distributive_law()</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ast_fitness</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
        <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">has_distributive_law</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here is the fitness of a number of given inputs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 + 1&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 * 2&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;1 * (2 + 3)&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6
</pre></div>
</div>
</div>
</div>
<p>Now, let’s set up a fitness function that takes derivation trees.
Essentially, our <code class="docutils literal notranslate"><span class="pre">tree_fitness()</span></code> function is based on the <code class="docutils literal notranslate"><span class="pre">ast_fitness()</span></code> function, above;
however, we also add a small component <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">len(code_str)</span></code> to give extra fitness to shorter inputs.
Otherwise, our inputs may grow and keep on growing, making mutations inefficient.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tree_fitness</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">code_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">code_str</span><span class="p">))</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">ast_fitness</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="c1"># print(ast.unparse(code_ast), f&quot;\n=&gt; Fitness = {fitness}\n&quot;)</span>
    <span class="k">return</span> <span class="n">fitness</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">code_str</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree_fitness</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4.002666666666666
</pre></div>
</div>
</div>
</div>
</section>
<section id="evolving-inputs">
<h3>Evolving Inputs<a class="headerlink" href="#evolving-inputs" title="Link to this heading">#</a></h3>
<p>Let us now make use of our fitness function to implement a simple evolutionary fuzzing algorithm.
We start with <em>evolution</em> – that is, taking a population and adding offspring via mutations.
Our initial population consists of a single candidate – in our case, <code class="docutils literal notranslate"><span class="pre">sum_tree</span></code> reflecting the <code class="docutils literal notranslate"><span class="pre">sum()</span></code> function, above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">initial_population</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree_fitness</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span> <span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">initial_population</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<p>Our <code class="docutils literal notranslate"><span class="pre">evolve()</span></code> function adds two new children to each population member.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">OFFSPRING</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">min_fitness</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">OFFSPRING</span><span class="p">):</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">min_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">child_fitness</span> <span class="o">=</span> <span class="n">tree_fitness</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child_fitness</span> <span class="o">&gt;</span> <span class="n">min_fitness</span><span class="p">:</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">child_fitness</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">population</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
</pre></div>
</div>
</div>
</div>
<p>As we can evolve all these, too, we get an exponential growth.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>9
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>27
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>81
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>243
</pre></div>
</div>
</div>
</div>
</section>
<section id="survival-of-the-fittest">
<h3>Survival of the Fittest<a class="headerlink" href="#survival-of-the-fittest" title="Link to this heading">#</a></h3>
<p>No population can expand forever and still survive.
Let us thus limit the population to a certain size.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">POPULATION_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">select()</span></code> function implements survival of the fittest: It limits the population to at most <code class="docutils literal notranslate"><span class="pre">POPULATION_SIZE</span></code> elements, sorting them by their fitness (highest to lowest).
Members with low fitness beyond <code class="docutils literal notranslate"><span class="pre">POPULATION_SIZE</span></code> do not survive.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_fitness</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
    <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">fitness</span><span class="p">)</span> <span class="o">=</span> <span class="n">elem</span>
    <span class="k">return</span> <span class="n">fitness</span>

<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
    <span class="n">population</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_fitness</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">population</span>
</pre></div>
</div>
</div>
</div>
<p>We can use the following call to trim our <code class="docutils literal notranslate"><span class="pre">sum_population</span></code> to the fittest members:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_population</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100
</pre></div>
</div>
</div>
</div>
</section>
<section id="evolution">
<h3>Evolution<a class="headerlink" href="#evolution" title="Link to this heading">#</a></h3>
<p>We now have everything in place:</p>
<ul class="simple">
<li><p>We have a <em>population</em> (say, <code class="docutils literal notranslate"><span class="pre">sum_population</span></code>)</p></li>
<li><p>We can evolve the population (using <code class="docutils literal notranslate"><span class="pre">evolve()</span></code>)</p></li>
<li><p>We can have only the fittest survive (using <code class="docutils literal notranslate"><span class="pre">select()</span></code>)</p></li>
</ul>
<p>Let us repeat this process over several generations.
We track whenever we have found a new “best” candidate and log them.
If we find a candidate that triggers the bug, we stop.
Note that this may take a long time, and not necessarily yield a perfect result.</p>
<p>As common in search-based approaches, we stop and restart the search if we have not found a sufficient solution after a number of generations (here: <code class="docutils literal notranslate"><span class="pre">GENERATIONS</span></code>).
Other than that, we keep searching until we have a solution.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">GENERATIONS</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Upper bound</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trial</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">sum_population</span> <span class="o">=</span> <span class="n">initial_population</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
    <span class="n">prev_best_fitness</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">generation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">GENERATIONS</span><span class="p">):</span>
        <span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">,</span> <span class="n">min_fitness</span><span class="o">=</span><span class="n">prev_best_fitness</span><span class="p">)</span>
        <span class="n">sum_population</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
        <span class="n">best_candidate</span><span class="p">,</span> <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">sum_population</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">best_fitness</span> <span class="o">&gt;</span> <span class="n">prev_best_fitness</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generation </span><span class="si">{</span><span class="n">generation</span><span class="si">}</span><span class="s2">: found new best candidate (fitness=</span><span class="si">{</span><span class="n">best_fitness</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
            <span class="n">best_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">best_candidate</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">best_ast</span><span class="p">))</span>
            <span class="n">prev_best_fitness</span> <span class="o">=</span> <span class="n">best_fitness</span>

            <span class="k">if</span> <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">best_ast</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done!&quot;</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

    <span class="n">trial</span> <span class="o">=</span> <span class="n">trial</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Restarting; trial #</span><span class="si">{</span><span class="n">trial</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Generation 0: found new best candidate (fitness=4.002666666666666):
def sum(a, b):
    the_sum = a + b
    return the_sum
Generation 1: found new best candidate (fitness=4.0027027027027025):
def sum(a, b):
    the_sum = a + b
    return FE
Generation 4: found new best candidate (fitness=4.002865329512894):
def sum():
    the_sum = a + b
    return the_sum
Generation 5: found new best candidate (fitness=6.00094696969697):
if set()[:] * *set():

    def sum(a, b):
        mc = a + b
        return FE
else:
    M = set()
continue

set().f[set():set()]()
Generation 7: found new best candidate (fitness=7.002364066193853):
def sum(a, b):
    mc = (a + b) * ()
    return FE
Done!


Restarting; trial #2
</pre></div>
</div>
</div>
</div>
<p>Success! We found a piece of code that triggers the bug. Check for occurrences of the distributive law.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">best_ast</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def sum(a, b):
    mc = (a + b) * ()
    return FE
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">best_ast</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>You may note that not all of the code is required to trigger the bug.
We could run our evolutionary fuzzer a bit longer to see whether it can be further reduced,
or use a dedicated input reduction technique such as <a class="reference external" href="https://www.fuzzingbook.org/html/Reducer.html">Delta Debugging</a>.</p>
</section>
<section id="chances-of-evolutionary-fuzzing">
<h3>Chances of Evolutionary Fuzzing<a class="headerlink" href="#chances-of-evolutionary-fuzzing" title="Link to this heading">#</a></h3>
<p>Could the bug in <code class="docutils literal notranslate"><span class="pre">distributive_law()</span></code> have been found without evolutionary guidance - i.e., simply by applying one mutation to <code class="docutils literal notranslate"><span class="pre">sum()</span></code>?</p>
<p>When producing an expression (<code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code>), we calculate how big the chances are to</p>
<ul class="simple">
<li><p>Produce a binary operator, and</p></li>
<li><p>Produce a <code class="docutils literal notranslate"><span class="pre">*</span></code>, and</p></li>
<li><p>Produce another binary operator as one child, and</p></li>
<li><p>Produce a <code class="docutils literal notranslate"><span class="pre">+</span></code></p></li>
</ul>
<p>Let’s do a few queries on our grammar to compute the chances.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="s1">&#39;&lt;BinOp&gt;&#39;</span> <span class="ow">in</span> <span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>15
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="s1">&#39;Add()&#39;</span> <span class="ow">in</span> <span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;operator&gt;&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="s1">&#39;Mult()&#39;</span> <span class="ow">in</span> <span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;operator&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;operator&gt;&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>13
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">])</span>       <span class="c1"># chances of choosing a `BinOp`</span>
<span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;operator&gt;&#39;</span><span class="p">])</span>  <span class="c1"># chances of choosing a `*`</span>
<span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;expr&gt;&#39;</span><span class="p">])</span>      <span class="c1"># chances of choosing a `BinOp` as a child</span>
<span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;operator&gt;&#39;</span><span class="p">])</span>  <span class="c1"># chances of choosing a `+`</span>
<span class="o">/</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># two chances - one for the left child, one for the right</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>19012.5
</pre></div>
</div>
</div>
</div>
<p>On average, it would take about 19000 (non-evolutionary) runs until we have an expression that triggers the distributive law.
So it is definitely better to make use of additional information (say, coverage) in order to guide mutations towards a goal.</p>
</section>
</section>
<section id="id8">
<h2>Synopsis<a class="headerlink" href="#id8" title="Link to this heading">#</a></h2>
<p>This chapter provides a <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> class that allows producing arbitrary Python code elements:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>def R():
    break
</pre></div>
</div>
</div>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> produces a <em>function definition</em> – that is, a list of statements as above.
You can pass a <code class="docutils literal notranslate"><span class="pre">start_symbol</span></code> argument to state which Python element you’d like to have:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="s1">&#39;&lt;While&gt;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>while {set()[set():set():set()]}:
    C = set()
    D @= set()
    break
else:
    return
</pre></div>
</div>
</div>
</div>
<p>Here is a list of all possible start symbols. Their names reflect the nonterminals from the <a class="reference external" href="https://docs.python.org/3/library/ast.html">Python <code class="docutils literal notranslate"><span class="pre">ast</span></code> module documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;Assert&gt;&#39;,
 &#39;&lt;Assign&gt;&#39;,
 &#39;&lt;Attribute&gt;&#39;,
 &#39;&lt;AugAssign&gt;&#39;,
 &#39;&lt;BinOp&gt;&#39;,
 &#39;&lt;BoolOp&gt;&#39;,
 &#39;&lt;Break&gt;&#39;,
 &#39;&lt;Call&gt;&#39;,
 &#39;&lt;Compare&gt;&#39;,
 &#39;&lt;Constant&gt;&#39;,
 &#39;&lt;Continue&gt;&#39;,
 &#39;&lt;Delete&gt;&#39;,
 &#39;&lt;Dict&gt;&#39;,
 &#39;&lt;EmptySet&gt;&#39;,
 &#39;&lt;Expr&gt;&#39;,
 &#39;&lt;For&gt;&#39;,
 &#39;&lt;FunctionDef&gt;&#39;,
 &#39;&lt;If&gt;&#39;,
 &#39;&lt;List&gt;&#39;,
 &#39;&lt;Module&gt;&#39;,
 &#39;&lt;Name&gt;&#39;,
 &#39;&lt;Pass&gt;&#39;,
 &#39;&lt;Return&gt;&#39;,
 &#39;&lt;Set&gt;&#39;,
 &#39;&lt;Slice&gt;&#39;,
 &#39;&lt;Starred&gt;&#39;,
 &#39;&lt;Subscript&gt;&#39;,
 &#39;&lt;Tuple&gt;&#39;,
 &#39;&lt;UnaryOp&gt;&#39;,
 &#39;&lt;While&gt;&#39;,
 &#39;&lt;With&gt;&#39;,
 &#39;&lt;arg&gt;&#39;,
 &#39;&lt;arg_list&gt;&#39;,
 &#39;&lt;args&gt;&#39;,
 &#39;&lt;args_param&gt;&#39;,
 &#39;&lt;arguments&gt;&#39;,
 &#39;&lt;bool&gt;&#39;,
 &#39;&lt;boolop&gt;&#39;,
 &#39;&lt;cmpop&gt;&#39;,
 &#39;&lt;cmpop_list&gt;&#39;,
 &#39;&lt;cmpops&gt;&#39;,
 &#39;&lt;decorator_list_param&gt;&#39;,
 &#39;&lt;defaults_param&gt;&#39;,
 &#39;&lt;digit&gt;&#39;,
 &#39;&lt;digits&gt;&#39;,
 &#39;&lt;expr&gt;&#39;,
 &#39;&lt;expr_list&gt;&#39;,
 &#39;&lt;exprs&gt;&#39;,
 &#39;&lt;float&gt;&#39;,
 &#39;&lt;func&gt;&#39;,
 &#39;&lt;id&gt;&#39;,
 &#39;&lt;id_continue&gt;&#39;,
 &#39;&lt;id_start&gt;&#39;,
 &#39;&lt;identifier&gt;&#39;,
 &#39;&lt;integer&gt;&#39;,
 &#39;&lt;keyword&gt;&#39;,
 &#39;&lt;keyword_list&gt;&#39;,
 &#39;&lt;keywords&gt;&#39;,
 &#39;&lt;keywords_param&gt;&#39;,
 &#39;&lt;kw_defaults_param&gt;&#39;,
 &#39;&lt;kwarg&gt;&#39;,
 &#39;&lt;kwonlyargs_param&gt;&#39;,
 &#39;&lt;lhs_Attribute&gt;&#39;,
 &#39;&lt;lhs_List&gt;&#39;,
 &#39;&lt;lhs_Name&gt;&#39;,
 &#39;&lt;lhs_Starred&gt;&#39;,
 &#39;&lt;lhs_Subscript&gt;&#39;,
 &#39;&lt;lhs_Tuple&gt;&#39;,
 &#39;&lt;lhs_expr&gt;&#39;,
 &#39;&lt;lhs_exprs&gt;&#39;,
 &#39;&lt;literal&gt;&#39;,
 &#39;&lt;mod&gt;&#39;,
 &#39;&lt;none&gt;&#39;,
 &#39;&lt;nonempty_expr_list&gt;&#39;,
 &#39;&lt;nonempty_lhs_expr_list&gt;&#39;,
 &#39;&lt;nonempty_stmt_list&gt;&#39;,
 &#39;&lt;nonzerodigit&gt;&#39;,
 &#39;&lt;not_double_quotes&gt;&#39;,
 &#39;&lt;not_single_quotes&gt;&#39;,
 &#39;&lt;operator&gt;&#39;,
 &#39;&lt;orelse_param&gt;&#39;,
 &#39;&lt;posonlyargs_param&gt;&#39;,
 &#39;&lt;returns&gt;&#39;,
 &#39;&lt;start&gt;&#39;,
 &#39;&lt;stmt&gt;&#39;,
 &#39;&lt;stmt_list&gt;&#39;,
 &#39;&lt;stmts&gt;&#39;,
 &#39;&lt;string&gt;&#39;,
 &#39;&lt;type_comment&gt;&#39;,
 &#39;&lt;type_ignore&gt;&#39;,
 &#39;&lt;type_ignore_list&gt;&#39;,
 &#39;&lt;type_ignore_param&gt;&#39;,
 &#39;&lt;type_ignores&gt;&#39;,
 &#39;&lt;unaryop&gt;&#39;,
 &#39;&lt;vararg&gt;&#39;,
 &#39;&lt;withitem&gt;&#39;,
 &#39;&lt;withitem_list&gt;&#39;,
 &#39;&lt;withitems&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>If you’d like more control over Python code generation, here is what is happening behind the scenes.
The EBNF grammar <code class="docutils literal notranslate"><span class="pre">PYTHON_AST_GRAMMAR</span></code> can parse and produce <em>abstract syntax trees</em> for Python.
To produce a Python module without <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code>, you would take these steps:</p>
<p><strong>Step 1:</strong> Create a non-EBNF grammar suitable for <code class="docutils literal notranslate"><span class="pre">ISLaSolver</span></code> (or any other grammar fuzzer):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">python_ast_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Step 2:</strong>  Feed the resulting grammar into a grammar fuzzer such as ISLa:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">&#39;&lt;FunctionDef&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Step 3:</strong>  Have the grammar fuzzer produce a string. This string represents an AST.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="n">ast_string</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;FunctionDef(name=\&#39;y\&#39;, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[Call(func=Name(id=&quot;set&quot;, ctx=Load()), args=[], keywords=[])])&#39;
</pre></div>
</div>
</div>
</div>
<p><strong>Step 4:</strong>  Convert the AST into an actual Python AST data structure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">abstract_syntax_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">ast_string</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Step 5:</strong> Finally, convert the AST structure back into readable Python code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>@set()
def y():
    return
</pre></div>
</div>
</div>
</div>
<p>The chapter has many more applications, including parsing and mutating Python code, evolutionary fuzzing, and more.</p>
<p>Here are the details on the <code class="docutils literal notranslate"><span class="pre">PythonFuzzer</span></code> constructor:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">markdown</span>
<span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">HTML</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">PythonFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
<span class="n">sig_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="k">if</span> <span class="n">sig</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getdoc</span><span class="p">(</span><span class="n">PythonFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
<span class="n">HTML</span><span class="p">(</span><span class="n">markdown</span><span class="o">.</span><span class="n">markdown</span><span class="p">(</span><span class="s1">&#39;`PythonFuzzer&#39;</span> <span class="o">+</span> <span class="n">sig_str</span> <span class="o">+</span> <span class="s1">&#39;`</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">doc</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><p><code>PythonFuzzer(self, start_symbol: Optional[str] = None, *, grammar: Optional[Dict[str, List[Union[str, Tuple[str, Dict[str, Any]]]]]] = None, constraint: Optional[str] = None, **kw_params) -&gt; None</code></p>
<p>Produce Python code. Parameters are:</p>
<ul>
<li><code>start_symbol</code>: The grammatical entity to be generated (default: <code>&lt;FunctionDef&gt;</code>)</li>
<li><code>grammar</code>: The EBNF grammar to be used (default: <code>PYTHON__AST_GRAMMAR</code>); and</li>
<li><code>constraint</code> an ISLa constraint (if any).</li>
</ul>
<p>Additional keyword parameters are passed to the <code>ISLaSolver</code> superclass.</p></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">from</span> <span class="nn">ClassDiagram</span> <span class="kn">import</span> <span class="n">display_class_hierarchy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">display_class_hierarchy</span><span class="p">([</span><span class="n">PythonFuzzer</span><span class="p">],</span>
                        <span class="n">public_methods</span><span class="o">=</span><span class="p">[</span>
                            <span class="n">PythonFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span>
                            <span class="n">PythonFuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">,</span>
                            <span class="n">ISLaSolver</span><span class="o">.</span><span class="fm">__init__</span>
                        <span class="p">],</span>
                        <span class="n">project</span><span class="o">=</span><span class="s1">&#39;fuzzingbook&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="248pt" height="152pt"
 viewBox="0.00 0.00 248.12 152.25" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 148.25)">
<g id="a_graph0"><a xlink:title="PythonFuzzer class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-148.25 244.12,-148.25 244.12,4 -4,4"/>
</a>
</g>
<!-- PythonFuzzer -->
<g id="node1" class="node">
<title>PythonFuzzer</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class PythonFuzzer:&#10;Produce Python code.">
<polygon fill="none" stroke="black" points="0,-0.5 0,-60 103,-60 103,-0.5 0,-0.5"/>
<text text-anchor="start" x="8" y="-43.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">PythonFuzzer</text>
<polyline fill="none" stroke="black" points="0,-34 103,-34"/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="PythonFuzzer">
<g id="a_node1_1"><a xlink:href="#" xlink:title="__init__(self, start_symbol: Optional[str] = None, *, grammar: Optional[Dict[str, List[Union[str, Tuple[str, Dict[str, Any]]]]]] = None, constraint: Optional[str] = None, **kw_params) &#45;&gt; None:&#10;Produce Python code. Parameters are:&#10;&#10;* `start_symbol`: The grammatical entity to be generated (default: `&lt;FunctionDef&gt;`)&#10;* `grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`); and&#10;* `constraint` an ISLa constraint (if any).&#10;&#10;Additional keyword parameters are passed to the `ISLaSolver` superclass.">
<text text-anchor="start" x="21.5" y="-21.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="#" xlink:title="fuzz(self) &#45;&gt; str:&#10;Produce a Python code string.">
<text text-anchor="start" x="21.5" y="-8.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">fuzz()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- ISLaSolver -->
<g id="node2" class="node">
<title>ISLaSolver</title>
<g id="a_node2"><a xlink:href="isla.solver.ipynb" xlink:title="class ISLaSolver:&#10;The solver class for ISLa formulas/constraints. Its top&#45;level methods are&#10;&#10;:meth:`~isla.solver.ISLaSolver.solve`&#10;Use to generate solutions for an ISLa constraint.&#10;&#10;:meth:`~isla.solver.ISLaSolver.check`&#10;Use to check if an ISLa constraint is satisfied for a given input.&#10;&#10;:meth:`~isla.solver.ISLaSolver.parse`&#10;Use to parse and validate an input.&#10;&#10;:meth:`~isla.solver.ISLaSolver.repair`&#10;Use to repair an input such that it satisfies a constraint.&#10;&#10;:meth:`~isla.solver.ISLaSolver.mutate`&#10;Use to mutate an input such that the result satisfies a constraint.">
<polygon fill="none" stroke="black" points="10.88,-97 10.88,-143.75 92.12,-143.75 92.12,-97 10.88,-97"/>
<text text-anchor="start" x="18.88" y="-127.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ISLaSolver</text>
<polyline fill="none" stroke="black" points="10.88,-117.75 92.12,-117.75"/>
<g id="a_node2_3"><a xlink:href="#" xlink:title="ISLaSolver">
<g id="a_node2_4"><a xlink:href="isla.solver.ipynb" xlink:title="__init__(self, grammar: Union[Dict[str, List[str]], str], formula: Union[isla.language.Formula, str, NoneType] = None, structural_predicates: Set[isla.language.StructuralPredicate] = frozenset({StructuralPredicate(name=&#39;nth&#39;, arity=3, eval_fun=&lt;function is_nth at 0x120f1c360&gt;), StructuralPredicate(name=&#39;inside&#39;, arity=2, eval_fun=&lt;function in_tree at 0x120f1c400&gt;), StructuralPredicate(name=&#39;same_position&#39;, arity=2, eval_fun=&lt;function is_same_position at 0x120f1c0e0&gt;), StructuralPredicate(name=&#39;consecutive&#39;, arity=2, eval_fun=&lt;function consecutive at 0x120f1c4a0&gt;), StructuralPredicate(name=&#39;different_position&#39;, arity=2, eval_fun=&lt;function is_different_position at 0x120f1c2c0&gt;), StructuralPredicate(name=&#39;before&#39;, arity=2, eval_fun=&lt;function is_before at 0x120ae5080&gt;), StructuralPredicate(name=&#39;level&#39;, arity=4, eval_fun=&lt;function level_check at 0x120f1c540&gt;), StructuralPredicate(name=&#39;direct_child&#39;, arity=2, eval_fun=&lt;function is_direct_child at 0x120f1d580&gt;), StructuralPredicate(name=&#39;after&#39;, arity=2, eval_fun=&lt;function is_after at 0x120f13880&gt;)}), semantic_predicates: Set[isla.language.SemanticPredicate] = frozenset({SemanticPredicate(count, 3)}), max_number_free_instantiations: int = 10, max_number_smt_instantiations: int = 10, max_number_tree_insertion_results: int = 5, enforce_unique_trees_in_queue: bool = False, debug: bool = False, cost_computer: Optional[ForwardRef(&#39;CostComputer&#39;)] = None, timeout_seconds: Optional[int] = None, global_fuzzer: bool = False, predicates_unique_in_int_arg: Tuple[isla.language.SemanticPredicate, ...] = (SemanticPredicate(count, 3),), fuzzer_factory: Callable[[Dict[str, List[str]]], isla.fuzzer.GrammarFuzzer] = &lt;function SolverDefaults.&lt;lambda&gt; at 0x120f41760&gt;, tree_insertion_methods: Optional[int] = None, activate_unsat_support: bool = False, grammar_unwinding_threshold: int = 4, initial_tree: isla.helpers.Maybe[isla.derivation_tree.DerivationTree] = Maybe(a=None), enable_optimized_z3_queries: bool = True, start_symbol: Optional[str] = None):&#10;The constructor of :class:`~isla.solver.ISLaSolver` accepts a large number of&#10;parameters. However, all but the first one, :code:`grammar`, are *optional.*&#10;&#10;The simplest way to construct an ISLa solver is by only providing it with a&#10;grammar only; it then works like a grammar fuzzer.&#10;&#10;&gt;&gt;&gt; import random&#10;&gt;&gt;&gt; random.seed(1)&#10;&#10;&gt;&gt;&gt; import string&#10;&gt;&gt;&gt; LANG_GRAMMAR = {&#10;... &#160;&#160;&#160;&#160;&quot;&lt;start&gt;&quot;:&#10;... &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&quot;&lt;stmt&gt;&quot;],&#10;... &#160;&#160;&#160;&#160;&quot;&lt;stmt&gt;&quot;:&#10;... &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&quot;&lt;assgn&gt; ; &lt;stmt&gt;&quot;, &quot;&lt;assgn&gt;&quot;],&#10;... &#160;&#160;&#160;&#160;&quot;&lt;assgn&gt;&quot;:&#10;... &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&quot;&lt;var&gt; := &lt;rhs&gt;&quot;],&#10;... &#160;&#160;&#160;&#160;&quot;&lt;rhs&gt;&quot;:&#10;... &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[&quot;&lt;var&gt;&quot;, &quot;&lt;digit&gt;&quot;],&#10;... &#160;&#160;&#160;&#160;&quot;&lt;var&gt;&quot;: list(string.ascii_lowercase),&#10;... &#160;&#160;&#160;&#160;&quot;&lt;digit&gt;&quot;: list(string.digits)&#10;... }&#10;&gt;&gt;&gt;&#10;&gt;&gt;&gt; from isla.solver import ISLaSolver&#10;&gt;&gt;&gt; solver = ISLaSolver(LANG_GRAMMAR)&#10;&gt;&gt;&gt;&#10;&gt;&gt;&gt; str(solver.solve())&#10;&#39;d := 9&#39;&#10;&gt;&gt;&gt; str(solver.solve())&#10;&#39;v := n ; s := r&#39;&#10;&#10;:param grammar: The underlying grammar; either, as a &quot;Fuzzing Book&quot; dictionary&#10;or in BNF syntax.&#10;:param formula: The formula to solve; either a string or a readily parsed&#10;formula. If no formula is given, a default `true` constraint is assumed, and&#10;the solver falls back to a grammar fuzzer. The number of produced solutions&#10;will then be bound by `max_number_free_instantiations`.&#10;:param structural_predicates: Structural predicates to use when parsing a&#10;formula.&#10;:param semantic_predicates: Semantic predicates to use when parsing a formula.&#10;:param max_number_free_instantiations: Number of times that nonterminals that&#10;are not bound by any formula should be expanded by a coverage&#45;based fuzzer.&#10;:param max_number_smt_instantiations: Number of solutions of SMT formulas that&#10;should be produced.&#10;:param max_number_tree_insertion_results: The maximum number of results when&#10;solving existential quantifiers by tree insertion.&#10;:param enforce_unique_trees_in_queue: If true, states with the same tree as an&#10;already existing tree in the queue are discarded, irrespectively of the&#10;constraint.&#10;:param debug: If true, debug information about the evolution of states is&#10;collected, notably in the field state_tree. The root of the tree is in the&#10;field state_tree_root. The field costs stores the computed cost values for&#10;all new nodes.&#10;:param cost_computer: The `CostComputer` class for computing the cost relevant&#10;to placing states in ISLa&#39;s queue.&#10;:param timeout_seconds: Number of seconds after which the solver will terminate.&#10;:param global_fuzzer: If set to True, only one coverage&#45;guided grammar fuzzer&#10;object is used to finish off unconstrained open derivation trees throughout&#10;the whole generation time. This may be beneficial for some targets; e.g., we&#10;experienced that CSV works significantly faster. However, the achieved k&#45;path&#10;coverage can be lower with that setting.&#10;:param predicates_unique_in_int_arg: This is needed in certain cases for&#10;instantiating universal integer quantifiers. The supplied predicates should&#10;have exactly one integer argument, and hold for exactly one integer value&#10;once all other parameters are fixed.&#10;:param fuzzer_factory: Constructor of the fuzzer to use for instantiating&#10;&quot;free&quot; nonterminals.&#10;:param tree_insertion_methods: Combination of methods to use for existential&#10;quantifier elimination by tree insertion. Full selection: `DIRECT_EMBEDDING &amp;&#10;SELF_EMBEDDING &amp; CONTEXT_ADDITION`.&#10;:param activate_unsat_support: Set to True if you assume that a formula might&#10;be unsatisfiable. This triggers additional tests for unsatisfiability that&#10;reduce input generation performance, but might ensure termination (with a&#10;negative solver result) for unsatisfiable problems for which the solver could&#10;otherwise diverge.&#10;:param grammar_unwinding_threshold: When querying the SMT solver, ISLa passes a&#10;regular expression for the syntax of the involved nonterminals. If this&#10;syntax is not regular, we unwind the respective part in the reference grammar&#10;up to a depth of `grammar_unwinding_threshold`. If this is too shallow, it can&#10;happen that an equation etc. cannot be solved; if it is too deep, it can&#10;negatively impact performance (and quite tremendously so).&#10;:param initial_tree: An initial input tree for the queue, if the solver shall&#10;not start from the tree `(&lt;start&gt;, None)`.&#10;:param enable_optimized_z3_queries: Enables preprocessing of Z3 queries (mainly&#10;numeric problems concerning things like length). This can improve performance&#10;significantly; however, it might happen that certain problems cannot be solved&#10;anymore. In that case, this option can/should be deactivated.&#10;:param start_symbol: This is an alternative to `initial_tree` for starting with&#10;a start symbol different form `&lt;start&gt;`. If `start_symbol` is provided, a tree&#10;consisting of a single root node with the value of `start_symbol` is chosen as&#10;initial tree.">
<text text-anchor="start" x="21.5" y="-105.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- PythonFuzzer&#45;&gt;ISLaSolver -->
<g id="edge1" class="edge">
<title>PythonFuzzer&#45;&gt;ISLaSolver</title>
<path fill="none" stroke="black" d="M51.5,-60.11C51.5,-68.16 51.5,-76.98 51.5,-85.3"/>
<polygon fill="none" stroke="black" points="48,-85.09 51.5,-95.09 55,-85.09 48,-85.09"/>
</g>
<!-- Legend -->
<g id="node3" class="node">
<title>Legend</title>
<text text-anchor="start" x="120.88" y="-46.25" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="120.88" y="-36.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="126.88" y="-36.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="120.88" y="-26.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="126.88" y="-26.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="120.88" y="-16.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="126.88" y="-16.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="120.88" y="-7.2" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</div></div>
</div>
</section>
<section id="lessons-learned">
<h2>Lessons Learned<a class="headerlink" href="#lessons-learned" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>When creating and processing complex inputs such as program code,</p>
<ul>
<li><p>try to rely on existing infrastructure to <em>parse</em> inputs into some <em>abstract syntax</em>, and then</p></li>
<li><p>have your grammars <em>process that abstract syntax</em> rather than the concrete syntax.</p></li>
</ul>
</li>
<li><p>Specifically, program code is normally converted into <em>abstract syntax trees</em> before being compiled or interpreted, and you can (and should) make use of such conversions.</p></li>
<li><p>Once program code is turned into an AST, it is fairly easy to generate, mutate, and evolve despite its complexity.</p></li>
</ul>
</section>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading">#</a></h2>
<p>The seminal work on compiler testing is <em>Csmith</em> \cite{Yang2011}, a generator of C programs.
Csmith has been used to thoroughly test compilers such as Clang or GCC; beyond producing code that is syntactically correct, it also aims at <em>semantic</em> correctness as well as avoiding undefined and unspecified behaviors.
This is a must read for anyone in the field in compiler testing.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="Carver.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Carving Unit Tests</p>
      </div>
    </a>
    <a class="right-next"
       href="WebFuzzer.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Testing Web Applications</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-grammar-for-concrete-code">A Grammar for Concrete Code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#abstract-syntax-trees">Abstract Syntax Trees</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-grammar-for-asts">A Grammar for ASTs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#constants">Constants</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-composites">Excursion: Composites</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-excursion">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-expressions">Excursion: Expressions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-names-and-function-calls">Excursion: Names and Function Calls</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-attributes-and-subscripts">Excursion: Attributes and Subscripts</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-variable-assignments">Excursion: Variable Assignments</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-statements">Excursion: Statements</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-function-definitions">Excursion: Function Definitions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">End of Excursion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-modules">Excursion: Modules</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-class-for-fuzzing-python">A Class for Fuzzing Python</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#customizing-the-python-fuzzer">Customizing the Python Fuzzer</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adjusting-the-grammar">Adjusting the Grammar</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#using-constraints-for-customizing">Using Constraints for Customizing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mutating-code">Mutating Code</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing-inputs">Parsing Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mutating-inputs">Mutating Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-effective-is-mutation">How Effective is Mutation?</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#evolutionary-fuzzing">Evolutionary Fuzzing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-coverage">Getting Coverage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fitness">Fitness</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#evolving-inputs">Evolving Inputs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#survival-of-the-fittest">Survival of the Fittest</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#evolution">Evolution</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chances-of-evolutionary-fuzzing">Chances of Evolutionary Fuzzing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021-2025 CISPA Helmholtz Center for Information Security (www.cispa.de); © Copyright 2018-2020 Saarland University, authors, and contributors. All Rights Reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>