
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Tours through the Book &#8212; The Fuzzing Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=42e1b1a5" />
    <link rel="stylesheet" type="text/css" href="_static/mastodon-timeline.css?v=f82c2b23" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Tours';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Introduction to Software Testing" href="Intro_Testing.html" />
    <link rel="prev" title="The Fuzzing Book" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>
<aside class="bd-header-announcement" aria-label="Announcement">
  <div class="bd-header-announcement__content"><p>This is a beta version of fuzzingbook.org, currently in development. See the <a href="https://fuzzingbook.org/"  style="color:white!important;">classic site</a> for resources.</p></div>
</aside>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/fuzzingbook.png" class="logo__image only-light" alt="The Fuzzing Book - Home"/>
    <script>document.write(`<img src="_static/fuzzingbook.png" class="logo__image only-dark" alt="The Fuzzing Book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    The Fuzzing Book
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Tours through the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="Intro_Testing.html">Introduction to Software Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lexical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Fuzzer.html">Fuzzing: Breaking Things with Random Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Coverage.html">Code Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationFuzzer.html">Mutation-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GreyboxFuzzer.html">Greybox Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SearchBasedFuzzer.html">Search-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationAnalysis.html">Mutation Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Syntactical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Grammars.html">Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarFuzzer.html">Efficient Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarCoverageFuzzer.html">Grammar Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parser.html">Parsing Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="ProbabilisticGrammarFuzzer.html">Probabilistic Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeneratorGrammarFuzzer.html">Fuzzing with Generators</a></li>

<li class="toctree-l1"><a class="reference internal" href="GreyboxGrammarFuzzer.html">Greybox Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reducer.html">Reducing Failure-Inducing Inputs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Semantical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingWithConstraints.html">Fuzzing with Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarMiner.html">Mining Input Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="InformationFlow.html">Tracking Information Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConcolicFuzzer.html">Concolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SymbolicFuzzer.html">Symbolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DynamicInvariants.html">Mining Function Specifications</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Domain-Specific Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ConfigurationFuzzer.html">Testing Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="APIFuzzer.html">Fuzzing APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Carver.html">Carving Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="PythonFuzzer.html">Testing Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="WebFuzzer.html">Testing Web Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="GUIFuzzer.html">Testing Graphical User Interfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Managing Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingInTheLarge.html">Fuzzing in the Large</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhenToStopFuzzing.html">When To Stop Fuzzing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="AcademicPrototyping.html">Academic Prototyping</a></li>
<li class="toctree-l1"><a class="reference internal" href="PrototypingWithPython.html">Prototyping with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExpectError.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timer.html">Timer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timeout.html">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="ClassDiagram.html">Class Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="RailroadDiagrams.html">Railroad Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="ControlFlow.html">Control Flow Graph</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About This Book</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ReleaseNotes.html">Fuzzingbook Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Importing.html">Using Fuzzingbook Code in your own Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Guide_for_Authors.html">Guide for Authors</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?urlpath=tree/docs/notebooks/Tours.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook/issues/new?title=Issue%20on%20page%20%2FTours.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/Tours.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Tours through the Book</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-pragmatic-programmer-tour">The Pragmatic Programmer Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-page-by-page-tours">The Page-by-Page Tours</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-undergraduate-tour">The Undergraduate Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-graduate-tour">The Graduate Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-black-box-tour">The Black-Box Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-white-box-tour">The White-Box Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-researcher-tour">The Researcher Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-author-tour">The Author Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="tours-through-the-book">
<h1>Tours through the Book<a class="headerlink" href="#tours-through-the-book" title="Link to this heading">#</a></h1>
<p>This book is <em>massive</em>.  With more than 20,000 lines of code and 150,000 words of text, a printed version would cover more than 1,200 pages of text.  Obviously, we do not assume that everybody wants to read everything.</p>
<p>While the chapters of this book can be read one after the other, there are many possible paths through the book.  In this graph, an arrow <span class="math notranslate nohighlight">\(A \rightarrow B\)</span> means that chapter <span class="math notranslate nohighlight">\(A\)</span> is a prerequisite for chapter <span class="math notranslate nohighlight">\(B\)</span>.  You can pick arbitrary paths in this graph to get to the topics that interest you most:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">rich_output</span><span class="p">,</span> <span class="n">InteractiveSVG</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">sitemap</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">rich_output</span><span class="p">():</span>
    <span class="n">sitemap</span> <span class="o">=</span> <span class="n">InteractiveSVG</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;PICS/Sitemap.svg&#39;</span><span class="p">)</span>
<span class="n">sitemap</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="1482pt" height="622pt"
 viewBox="0.00 0.00 1481.88 622.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 618)">
<polygon fill="white" stroke="none" points="-4,4 -4,-618 1477.88,-618 1477.88,4 -4,4"/>
<!-- Fuzzer -->
<g id="node1" class="node">
<title>Fuzzer</title>
<g id="a_node1"><a xlink:href="Fuzzer.ipynb" xlink:title="Fuzzing: Breaking Things with Random Inputs (Fuzzer)&#10;&#10;In this chapter, we&#39;ll start with one of the simplest test generation techniques. &#160;The key idea of random text generation, also known as fuzzing, is to feed a string of random characters into a program in the hope to uncover failures.">
<polygon fill="white" stroke="black" points="975.62,-534 839.62,-534 839.62,-472 981.62,-472 981.62,-528 975.62,-534"/>
<polyline fill="none" stroke="black" points="975.62,-534 975.62,-528"/>
<polyline fill="none" stroke="black" points="981.62,-528 975.62,-528"/>
<text text-anchor="middle" x="910.62" y="-516.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing: Breaking</text>
<text text-anchor="middle" x="910.62" y="-498.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Things</text>
<text text-anchor="middle" x="910.62" y="-480.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">with Random Inputs</text>
</a>
</g>
</g>
<!-- Coverage -->
<g id="node2" class="node">
<title>Coverage</title>
<g id="a_node2"><a xlink:href="Coverage.ipynb" xlink:title="Code Coverage (Coverage)&#10;&#10;In the previous chapter, we introduced basic fuzzing – that is, generating random inputs to test programs. &#160;How do we measure the effectiveness of these tests? &#160;One way would be to check the number (and seriousness) of bugs found; but if bugs are scarce, we need a proxy for the likelihood of a test to uncover a bug. &#160;In this chapter, we introduce the concept of code coverage, measuring which parts of a program are actually executed during a test run. &#160;Measuring such coverage is also crucial for test generators that attempt to cover as much code as possible.">
<polygon fill="white" stroke="black" points="599,-352 498.25,-352 498.25,-316 605,-316 605,-346 599,-352"/>
<polyline fill="none" stroke="black" points="599,-352 599,-346"/>
<polyline fill="none" stroke="black" points="605,-346 599,-346"/>
<text text-anchor="middle" x="551.62" y="-329.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Code Coverage</text>
</a>
</g>
</g>
<!-- Fuzzer&#45;&gt;Coverage -->
<g id="edge1" class="edge">
<title>Fuzzer&#45;&gt;Coverage</title>
<path fill="none" stroke="black" d="M839.31,-488.4C793.27,-477.92 732.98,-460.95 683.62,-436 643.54,-415.74 603.4,-382.78 578.1,-360.05"/>
<polygon fill="black" stroke="black" points="580.65,-357.65 570.9,-353.5 575.94,-362.82 580.65,-357.65"/>
</g>
<!-- SearchBasedFuzzer -->
<g id="node3" class="node">
<title>SearchBasedFuzzer</title>
<g id="a_node3"><a xlink:href="SearchBasedFuzzer.ipynb" xlink:title="Search&#45;Based Fuzzing (SearchBasedFuzzer)&#10;&#10;Sometimes we are not only interested in fuzzing as many as possible diverse program inputs, but in deriving specific test inputs that achieve some objective, such as reaching specific statements in a program. When we have an idea of what we are looking for, then we can search for it. Search algorithms are at the core of computer science, but applying classic search algorithms like breadth or depth first search to search for tests is unrealistic, because these algorithms potentially require us to look at all possible inputs. However, domain&#45;knowledge can be used to overcome this problem. For example, if we can estimate which of several program inputs is closer to the one we are looking for, then this information can guide us to reach the target quicker – this information is known as a heuristic. The way heuristics are applied systematically is captured in meta&#45;heuristic search algorithms. The &quot;meta&quot; denotes that these algorithms are generic and can be instantiated differently to different problems. Meta&#45;heuristics often take inspiration from processes observed in nature. For example, there are algorithms mimicking evolutionary processes, swarm intelligence, or chemical reactions. In general, they are much more efficient than exhaustive search approaches such that they can be applied to vast search spaces – search spaces as vast as the domain of program inputs are no problem for them.">
<polygon fill="white" stroke="black" points="838.5,-432 692.75,-432 692.75,-396 844.5,-396 844.5,-426 838.5,-432"/>
<polyline fill="none" stroke="black" points="838.5,-432 838.5,-426"/>
<polyline fill="none" stroke="black" points="844.5,-426 838.5,-426"/>
<text text-anchor="middle" x="768.62" y="-409.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Search&#45;Based Fuzzing</text>
</a>
</g>
</g>
<!-- Fuzzer&#45;&gt;SearchBasedFuzzer -->
<g id="edge2" class="edge">
<title>Fuzzer&#45;&gt;SearchBasedFuzzer</title>
<path fill="none" stroke="black" d="M860.96,-471.57C843.04,-460.59 823.13,-448.39 806.39,-438.14"/>
<polygon fill="black" stroke="black" points="808.59,-435.38 798.24,-433.14 804.93,-441.35 808.59,-435.38"/>
</g>
<!-- Grammars -->
<g id="node4" class="node">
<title>Grammars</title>
<g id="a_node4"><a xlink:href="Grammars.ipynb" xlink:title="Fuzzing with Grammars (Grammars)&#10;&#10;In the chapter on &quot;Mutation&#45;Based Fuzzing&quot;, we have seen how to use extra hints – such as sample input files – to speed up test generation. &#160;In this chapter, we take this idea one step further, by providing a specification of the legal inputs to a program. &#160;Specifying inputs via a grammar allows for very systematic and efficient test generation, in particular for complex input formats. &#160;Grammars also serve as the base for configuration fuzzing, API fuzzing, GUI fuzzing, and many more.">
<polygon fill="white" stroke="black" points="952.75,-436 862.5,-436 862.5,-392 958.75,-392 958.75,-430 952.75,-436"/>
<polyline fill="none" stroke="black" points="952.75,-436 952.75,-430"/>
<polyline fill="none" stroke="black" points="958.75,-430 952.75,-430"/>
<text text-anchor="middle" x="910.62" y="-418.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing with</text>
<text text-anchor="middle" x="910.62" y="-400.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammars</text>
</a>
</g>
</g>
<!-- Fuzzer&#45;&gt;Grammars -->
<g id="edge3" class="edge">
<title>Fuzzer&#45;&gt;Grammars</title>
<path fill="none" stroke="black" d="M910.62,-471.57C910.62,-463.83 910.62,-455.47 910.62,-447.62"/>
<polygon fill="black" stroke="black" points="914.13,-447.76 910.63,-437.76 907.13,-447.76 914.13,-447.76"/>
</g>
<!-- SymbolicFuzzer -->
<g id="node5" class="node">
<title>SymbolicFuzzer</title>
<g id="a_node5"><a xlink:href="SymbolicFuzzer.ipynb" xlink:title="Symbolic Fuzzing (SymbolicFuzzer)&#10;&#10;One of the problems with traditional methods of fuzzing is that they fail to exercise all the possible behaviors that a system can have, especially when the input space is large. Quite often the execution of a specific branch of execution may happen only with very specific inputs, which could represent a minimal fraction of the input space. The traditional fuzzing methods relies on chance to produce inputs they need. However, relying on randomness to generate values that we want is a bad idea when the space to be explored is huge. For example, a function that accepts a string, even if one only considers the first $10$ characters, already has $2^{80}$ possible inputs. If one is looking for a specific string, random generation of values will take a few thousand years even in one of the super computers.">
<polygon fill="white" stroke="black" points="1094.62,-432 976.62,-432 976.62,-396 1100.62,-396 1100.62,-426 1094.62,-432"/>
<polyline fill="none" stroke="black" points="1094.62,-432 1094.62,-426"/>
<polyline fill="none" stroke="black" points="1100.62,-426 1094.62,-426"/>
<text text-anchor="middle" x="1038.62" y="-409.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Symbolic Fuzzing</text>
</a>
</g>
</g>
<!-- Fuzzer&#45;&gt;SymbolicFuzzer -->
<g id="edge4" class="edge">
<title>Fuzzer&#45;&gt;SymbolicFuzzer</title>
<path fill="none" stroke="black" d="M955.39,-471.57C971.24,-460.8 988.83,-448.85 1003.73,-438.72"/>
<polygon fill="black" stroke="black" points="1005.54,-441.72 1011.85,-433.2 1001.61,-435.93 1005.54,-441.72"/>
</g>
<!-- FuzzingInTheLarge -->
<g id="node6" class="node">
<title>FuzzingInTheLarge</title>
<g id="a_node6"><a xlink:href="FuzzingInTheLarge.ipynb" xlink:title="Fuzzing in the Large (FuzzingInTheLarge)&#10;&#10;In the past chapters, we have always looked at fuzzing taking place on one machine for a few seconds only. &#160;In the real world, however, fuzzers are run on dozens or even thousands of machines; for hours, days and weeks; for one program or dozens of programs. &#160;In such contexts, one needs an infrastructure to collect failure data from the individual fuzzer runs, and to aggregate such data in a central repository. &#160;In this chapter, we will examine such an infrastructure, the FuzzManager framework from Mozilla.">
<polygon fill="white" stroke="black" points="1252.5,-432 1118.75,-432 1118.75,-396 1258.5,-396 1258.5,-426 1252.5,-432"/>
<polyline fill="none" stroke="black" points="1252.5,-432 1252.5,-426"/>
<polyline fill="none" stroke="black" points="1258.5,-426 1252.5,-426"/>
<text text-anchor="middle" x="1188.62" y="-409.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing in the Large</text>
</a>
</g>
</g>
<!-- Fuzzer&#45;&gt;FuzzingInTheLarge -->
<g id="edge5" class="edge">
<title>Fuzzer&#45;&gt;FuzzingInTheLarge</title>
<path fill="none" stroke="black" d="M981.86,-479.71C1025.07,-466.18 1079.85,-449.04 1122.17,-435.8"/>
<polygon fill="black" stroke="black" points="1122.98,-439.21 1131.48,-432.88 1120.89,-432.53 1122.98,-439.21"/>
</g>
<!-- MutationFuzzer -->
<g id="node8" class="node">
<title>MutationFuzzer</title>
<g id="a_node8"><a xlink:href="MutationFuzzer.ipynb" xlink:title="Mutation&#45;Based Fuzzing (MutationFuzzer)&#10;&#10;Most randomly generated inputs are syntactically invalid and thus are quickly rejected by the processing program. &#160;To exercise functionality beyond input processing, we must increase chances to obtain valid inputs. &#160;One such way is so&#45;called mutational fuzzing – that is, introducing small changes to existing inputs that may still keep the input valid, yet exercise new behavior. &#160;We show how to create such mutations, and how to guide them towards yet uncovered code, applying central concepts from the popular AFL fuzzer.">
<polygon fill="white" stroke="black" points="604.25,-276 493,-276 493,-232 610.25,-232 610.25,-270 604.25,-276"/>
<polyline fill="none" stroke="black" points="604.25,-276 604.25,-270"/>
<polyline fill="none" stroke="black" points="610.25,-270 604.25,-270"/>
<text text-anchor="middle" x="551.62" y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Mutation&#45;Based</text>
<text text-anchor="middle" x="551.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;MutationFuzzer -->
<g id="edge7" class="edge">
<title>Coverage&#45;&gt;MutationFuzzer</title>
<path fill="none" stroke="black" d="M551.62,-315.69C551.62,-307.46 551.62,-297.33 551.62,-287.73"/>
<polygon fill="black" stroke="black" points="555.13,-287.95 551.63,-277.95 548.13,-287.95 555.13,-287.95"/>
</g>
<!-- MutationAnalysis -->
<g id="node9" class="node">
<title>MutationAnalysis</title>
<g id="a_node9"><a xlink:href="MutationAnalysis.ipynb" xlink:title="Mutation Analysis (MutationAnalysis)&#10;&#10;In the chapter on coverage, we showed how one can identify which parts of the program are executed by a program, and hence get a sense of the effectiveness of a set of test cases in covering the program structure. &#160;However, coverage alone may not be the best measure for the effectiveness of a test, as one can have great coverage without ever checking a result for correctness. &#160;In this chapter, we introduce another means for assessing the effectiveness of a test suite: After injecting mutations – artificial faults – into the code, we check whether a test suite can detect these artificial faults. &#160;The idea is that if it fails to detect such mutations, it will also miss real bugs.">
<polygon fill="white" stroke="black" points="294.25,-272 171,-272 171,-236 300.25,-236 300.25,-266 294.25,-272"/>
<polyline fill="none" stroke="black" points="294.25,-272 294.25,-266"/>
<polyline fill="none" stroke="black" points="300.25,-266 294.25,-266"/>
<text text-anchor="middle" x="235.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Mutation Analysis</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;MutationAnalysis -->
<g id="edge8" class="edge">
<title>Coverage&#45;&gt;MutationAnalysis</title>
<path fill="none" stroke="black" d="M497.88,-320.46C449.79,-309.15 377.39,-291.89 314.62,-276 313.63,-275.75 312.63,-275.49 311.63,-275.24"/>
<polygon fill="black" stroke="black" points="312.71,-271.9 302.16,-272.8 310.97,-278.68 312.71,-271.9"/>
</g>
<!-- GrammarCoverageFuzzer -->
<g id="node10" class="node">
<title>GrammarCoverageFuzzer</title>
<g id="a_node10"><a xlink:href="GrammarCoverageFuzzer.ipynb" xlink:title="Grammar Coverage (GrammarCoverageFuzzer)&#10;&#10;Producing inputs from grammars gives all possible expansions of a rule the same likelihood. &#160;For producing a comprehensive test suite, however, it makes more sense to maximize variety – for instance, by not repeating the same expansions over and over again. &#160;In this chapter, we explore how to systematically cover elements of a grammar such that we maximize variety and do not miss out individual elements.">
<polygon fill="white" stroke="black" points="1101.25,-272 972,-272 972,-236 1107.25,-236 1107.25,-266 1101.25,-272"/>
<polyline fill="none" stroke="black" points="1101.25,-272 1101.25,-266"/>
<polyline fill="none" stroke="black" points="1107.25,-266 1101.25,-266"/>
<text text-anchor="middle" x="1039.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammar Coverage</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;GrammarCoverageFuzzer -->
<g id="edge9" class="edge">
<title>Coverage&#45;&gt;GrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M605.34,-327.86C684.36,-319.78 836.33,-302.27 963.62,-276 965.22,-275.67 966.82,-275.33 968.44,-274.97"/>
<polygon fill="black" stroke="black" points="968.81,-278.48 977.76,-272.8 967.23,-271.66 968.81,-278.48"/>
</g>
<!-- ProbabilisticGrammarFuzzer -->
<g id="node11" class="node">
<title>ProbabilisticGrammarFuzzer</title>
<g id="a_node11"><a xlink:href="ProbabilisticGrammarFuzzer.ipynb" xlink:title="Probabilistic Grammar Fuzzing (ProbabilisticGrammarFuzzer)&#10;&#10;Let us give grammars even more power by assigning probabilities to individual expansions. &#160;This allows us to control how many of each element should be produced, and thus allows us to target our generated tests towards specific functionality. &#160;We also show how to learn such probabilities from given sample inputs, and specifically direct our tests towards input features that are uncommon in these samples.">
<polygon fill="white" stroke="black" points="466.75,-196 346.5,-196 346.5,-152 472.75,-152 472.75,-190 466.75,-196"/>
<polyline fill="none" stroke="black" points="466.75,-196 466.75,-190"/>
<polyline fill="none" stroke="black" points="472.75,-190 466.75,-190"/>
<text text-anchor="middle" x="409.62" y="-178.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Probabilistic</text>
<text text-anchor="middle" x="409.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammar Fuzzing</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;ProbabilisticGrammarFuzzer -->
<g id="edge10" class="edge">
<title>Coverage&#45;&gt;ProbabilisticGrammarFuzzer</title>
<path fill="none" stroke="black" d="M498.09,-325.43C443.97,-316.56 365.8,-299.95 347.62,-276 335.8,-260.42 339.76,-249.91 347.62,-232 352.25,-221.46 359.9,-212.01 368.27,-203.97"/>
<polygon fill="black" stroke="black" points="370.5,-206.68 375.67,-197.43 365.86,-201.44 370.5,-206.68"/>
</g>
<!-- ConcolicFuzzer -->
<g id="node12" class="node">
<title>ConcolicFuzzer</title>
<g id="a_node12"><a xlink:href="ConcolicFuzzer.ipynb" xlink:title="Concolic Fuzzing (ConcolicFuzzer)&#10;&#10;In the chapter on information flow, we have seen how one can use dynamic taints to produce more intelligent test cases than simply looking for program crashes. We have also seen how one can use the taints to update the grammar, and hence focus more on the dangerous methods.">
<polygon fill="white" stroke="black" points="946,-112 833.25,-112 833.25,-76 952,-76 952,-106 946,-112"/>
<polyline fill="none" stroke="black" points="946,-112 946,-106"/>
<polyline fill="none" stroke="black" points="952,-106 946,-106"/>
<text text-anchor="middle" x="892.62" y="-89.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Concolic Fuzzing</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;ConcolicFuzzer -->
<g id="edge11" class="edge">
<title>Coverage&#45;&gt;ConcolicFuzzer</title>
<path fill="none" stroke="black" d="M579.14,-315.62C593.05,-305.57 609.16,-291.79 619.62,-276 651.47,-227.95 615.2,-191.02 657.62,-152 713.2,-100.9 750.56,-135.01 823.62,-116 824.29,-115.83 824.95,-115.65 825.62,-115.48"/>
<polygon fill="black" stroke="black" points="826.44,-118.88 835.16,-112.86 824.6,-112.13 826.44,-118.88"/>
</g>
<!-- DynamicInvariants -->
<g id="node13" class="node">
<title>DynamicInvariants</title>
<g id="a_node13"><a xlink:href="DynamicInvariants.ipynb" xlink:title="Mining Function Specifications (DynamicInvariants)&#10;&#10;When testing a program, one not only needs to cover its several behaviors; one also needs to check whether the result is as expected. &#160;In this chapter, we introduce a technique that allows us to mine function specifications from a set of given executions, resulting in abstract and formal descriptions of what the function expects and what it delivers.">
<polygon fill="white" stroke="black" points="468.62,-276 356.62,-276 356.62,-232 474.62,-232 474.62,-270 468.62,-276"/>
<polyline fill="none" stroke="black" points="468.62,-276 468.62,-270"/>
<polyline fill="none" stroke="black" points="474.62,-270 468.62,-270"/>
<text text-anchor="middle" x="415.62" y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Mining Function</text>
<text text-anchor="middle" x="415.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Specifications</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;DynamicInvariants -->
<g id="edge12" class="edge">
<title>Coverage&#45;&gt;DynamicInvariants</title>
<path fill="none" stroke="black" d="M521.44,-315.69C504.25,-305.83 482.33,-293.26 462.9,-282.11"/>
<polygon fill="black" stroke="black" points="464.74,-279.13 454.32,-277.19 461.25,-285.2 464.74,-279.13"/>
</g>
<!-- PythonFuzzer -->
<g id="node14" class="node">
<title>PythonFuzzer</title>
<g id="a_node14"><a xlink:href="PythonFuzzer.ipynb" xlink:title="Testing Compilers (PythonFuzzer)&#10;&#10;In this chapter, we will make use of grammars and grammar&#45;based testing to systematically generate program code – for instance, to test a compiler or an interpreter. Not very surprisingly, we use Python and the Python interpreter as our domain.">
<polygon fill="white" stroke="black" points="786.38,-272 666.88,-272 666.88,-236 792.38,-236 792.38,-266 786.38,-272"/>
<polyline fill="none" stroke="black" points="786.38,-272 786.38,-266"/>
<polyline fill="none" stroke="black" points="792.38,-266 786.38,-266"/>
<text text-anchor="middle" x="729.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing Compilers</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;PythonFuzzer -->
<g id="edge13" class="edge">
<title>Coverage&#45;&gt;PythonFuzzer</title>
<path fill="none" stroke="black" d="M591.13,-315.69C617.19,-304.27 651.56,-289.21 679.54,-276.95"/>
<polygon fill="black" stroke="black" points="680.78,-280.22 688.54,-273 677.97,-273.81 680.78,-280.22"/>
</g>
<!-- WhenToStopFuzzing -->
<g id="node15" class="node">
<title>WhenToStopFuzzing</title>
<g id="a_node15"><a xlink:href="WhenToStopFuzzing.ipynb" xlink:title="When To Stop Fuzzing (WhenToStopFuzzing)&#10;&#10;In the past chapters, we have discussed several fuzzing techniques. &#160;Knowing what to do is important, but it is also important to know when to stop doing things. &#160;In this chapter, we will learn when to stop fuzzing – and use a prominent example for this purpose: The Enigma machine that was used in the second world war by the navy of Nazi Germany to encrypt communications, and how Alan Turing and I.J. Good used fuzzing techniques to crack ciphers for the Naval Enigma machine.">
<polygon fill="white" stroke="black" points="147.25,-272 0,-272 0,-236 153.25,-236 153.25,-266 147.25,-272"/>
<polyline fill="none" stroke="black" points="147.25,-272 147.25,-266"/>
<polyline fill="none" stroke="black" points="153.25,-266 147.25,-266"/>
<text text-anchor="middle" x="76.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">When To Stop Fuzzing</text>
</a>
</g>
</g>
<!-- Coverage&#45;&gt;WhenToStopFuzzing -->
<g id="edge14" class="edge">
<title>Coverage&#45;&gt;WhenToStopFuzzing</title>
<path fill="none" stroke="black" d="M498.04,-326.84C422.61,-317.79 280.98,-299.41 161.62,-276 159.73,-275.63 157.81,-275.24 155.88,-274.84"/>
<polygon fill="black" stroke="black" points="156.69,-271.44 146.17,-272.75 155.21,-278.28 156.69,-271.44"/>
</g>
<!-- GrammarFuzzer -->
<g id="node18" class="node">
<title>GrammarFuzzer</title>
<g id="a_node18"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="Efficient Grammar Fuzzing (GrammarFuzzer)&#10;&#10;In the chapter on grammars, we have seen how to use grammars for very effective and efficient testing. &#160;In this chapter, we refine the previous string&#45;based algorithm into a tree&#45;based algorithm, which is much faster and allows for much more control over the production of fuzz inputs.">
<polygon fill="white" stroke="black" points="1029.25,-356 906,-356 906,-312 1035.25,-312 1035.25,-350 1029.25,-356"/>
<polyline fill="none" stroke="black" points="1029.25,-356 1029.25,-350"/>
<polyline fill="none" stroke="black" points="1035.25,-350 1029.25,-350"/>
<text text-anchor="middle" x="970.62" y="-338.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Efficient Grammar</text>
<text text-anchor="middle" x="970.62" y="-320.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing</text>
</a>
</g>
</g>
<!-- Grammars&#45;&gt;GrammarFuzzer -->
<g id="edge17" class="edge">
<title>Grammars&#45;&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M927.02,-391.69C933.3,-383.52 940.6,-374.04 947.4,-365.19"/>
<polygon fill="black" stroke="black" points="950,-367.55 953.33,-357.49 944.46,-363.28 950,-367.55"/>
</g>
<!-- Intro_Testing -->
<g id="node7" class="node">
<title>Intro_Testing</title>
<g id="a_node7"><a xlink:href="Intro_Testing.ipynb" xlink:title="Introduction to Software Testing (Intro_Testing)&#10;&#10;Before we get to the central parts of the book, let us introduce essential concepts of software testing. &#160;Why is it necessary to test software at all? &#160;How does one test software? &#160;How can one tell whether a test has been successful? &#160;How does one know if one has tested enough? &#160;In this chapter, let us recall the most important concepts, and at the same time get acquainted with Python and interactive notebooks.">
<polygon fill="white" stroke="black" points="965.12,-614 850.12,-614 850.12,-570 971.12,-570 971.12,-608 965.12,-614"/>
<polyline fill="none" stroke="black" points="965.12,-614 965.12,-608"/>
<polyline fill="none" stroke="black" points="971.12,-608 965.12,-608"/>
<text text-anchor="middle" x="910.62" y="-596.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Introduction to</text>
<text text-anchor="middle" x="910.62" y="-578.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Software Testing</text>
</a>
</g>
</g>
<!-- Intro_Testing&#45;&gt;Fuzzer -->
<g id="edge6" class="edge">
<title>Intro_Testing&#45;&gt;Fuzzer</title>
<path fill="none" stroke="black" d="M910.62,-569.94C910.62,-562.61 910.62,-554.11 910.62,-545.7"/>
<polygon fill="black" stroke="black" points="914.13,-545.92 910.63,-535.92 907.13,-545.92 914.13,-545.92"/>
</g>
<!-- GreyboxFuzzer -->
<g id="node16" class="node">
<title>GreyboxFuzzer</title>
<g id="a_node16"><a xlink:href="GreyboxFuzzer.ipynb" xlink:title="Greybox Fuzzing (GreyboxFuzzer)&#10;&#10;In the previous chapter, we have introduced mutation&#45;based fuzzing, a technique that generates fuzz inputs by applying small mutations to given inputs. In this chapter, we show how to guide these mutations towards specific goals such as coverage. The algorithms in this chapter stem from the popular American Fuzzy Lop (AFL) fuzzer, in particular from its AFLFast and AFLGo flavors. We will explore the greybox fuzzing algorithm behind AFL and how we can exploit it to solve various problems for automated vulnerability detection.">
<polygon fill="white" stroke="black" points="604.38,-192 490.88,-192 490.88,-156 610.38,-156 610.38,-186 604.38,-192"/>
<polyline fill="none" stroke="black" points="604.38,-192 604.38,-186"/>
<polyline fill="none" stroke="black" points="610.38,-186 604.38,-186"/>
<text text-anchor="middle" x="550.62" y="-169.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Greybox Fuzzing</text>
</a>
</g>
</g>
<!-- MutationFuzzer&#45;&gt;GreyboxFuzzer -->
<g id="edge15" class="edge">
<title>MutationFuzzer&#45;&gt;GreyboxFuzzer</title>
<path fill="none" stroke="black" d="M551.35,-231.69C551.24,-223.09 551.11,-213.05 550.99,-203.82"/>
<polygon fill="black" stroke="black" points="554.49,-203.81 550.87,-193.86 547.5,-203.9 554.49,-203.81"/>
</g>
<!-- GrammarMiner -->
<g id="node24" class="node">
<title>GrammarMiner</title>
<g id="a_node24"><a xlink:href="GrammarMiner.ipynb" xlink:title="Mining Input Grammars (GrammarMiner)&#10;&#10;So far, the grammars we have seen have been mostly specified manually – that is, you (or the person knowing the input format) had to design and write a grammar in the first place. &#160;While the grammars we have seen so far have been rather simple, creating a grammar for complex inputs can involve quite some effort. &#160;In this chapter, we therefore introduce techniques that automatically mine grammars from programs – by executing the programs and observing how they process which parts of the input. &#160;In conjunction with a grammar fuzzer, this allows us to &#10;1. take a program, &#10;2. extract its input grammar, and &#10;3. fuzz it with high efficiency and effectiveness, using the concepts in this book.">
<polygon fill="white" stroke="black" points="1093.12,-116 1002.12,-116 1002.12,-72 1099.12,-72 1099.12,-110 1093.12,-116"/>
<polyline fill="none" stroke="black" points="1093.12,-116 1093.12,-110"/>
<polyline fill="none" stroke="black" points="1099.12,-110 1093.12,-110"/>
<text text-anchor="middle" x="1050.62" y="-98.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Mining Input</text>
<text text-anchor="middle" x="1050.62" y="-80.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammars</text>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;GrammarMiner -->
<g id="edge25" class="edge">
<title>GrammarCoverageFuzzer&#45;&gt;GrammarMiner</title>
<path fill="none" stroke="black" d="M1068,-235.53C1081.15,-225.71 1095.45,-212.18 1102.62,-196 1110.56,-178.13 1109.69,-170.23 1102.62,-152 1098.75,-142 1092.21,-132.68 1085.06,-124.6"/>
<polygon fill="black" stroke="black" points="1087.64,-122.23 1078.2,-117.43 1082.58,-127.07 1087.64,-122.23"/>
</g>
<!-- ConfigurationFuzzer -->
<g id="node25" class="node">
<title>ConfigurationFuzzer</title>
<g id="a_node25"><a xlink:href="ConfigurationFuzzer.ipynb" xlink:title="Testing Configurations (ConfigurationFuzzer)&#10;&#10;The behavior of a program is not only governed by its data. &#160;The configuration of a program – that is, the settings that govern the execution of a program on its (regular) input data, as set by options or configuration files – just as well influences behavior, and thus can and should be tested. &#160;In this chapter, we explore how to systematically test and cover software configurations. &#160;By automatically inferring configuration options, we can apply these techniques out of the box, with no need for writing a grammar. &#160;Finally, we show how to systematically cover combinations of configuration options, quickly detecting unwanted interferences.">
<polygon fill="white" stroke="black" points="1087.75,-196 985.5,-196 985.5,-152 1093.75,-152 1093.75,-190 1087.75,-196"/>
<polyline fill="none" stroke="black" points="1087.75,-196 1087.75,-190"/>
<polyline fill="none" stroke="black" points="1093.75,-190 1087.75,-190"/>
<text text-anchor="middle" x="1039.62" y="-178.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing</text>
<text text-anchor="middle" x="1039.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Configurations</text>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;ConfigurationFuzzer -->
<g id="edge26" class="edge">
<title>GrammarCoverageFuzzer&#45;&gt;ConfigurationFuzzer</title>
<path fill="none" stroke="black" d="M1039.62,-235.69C1039.62,-227.46 1039.62,-217.33 1039.62,-207.73"/>
<polygon fill="black" stroke="black" points="1043.13,-207.95 1039.63,-197.95 1036.13,-207.95 1043.13,-207.95"/>
</g>
<!-- Carver -->
<g id="node26" class="node">
<title>Carver</title>
<g id="a_node26"><a xlink:href="Carver.ipynb" xlink:title="Carving Unit Tests (Carver)&#10;&#10;So far, we have always generated system input, i.e. data that the program as a whole obtains via its input channels. &#160;If we are interested in testing only a small set of functions, having to go through the system can be very inefficient. &#160;This chapter introduces a technique known as carving, which, given a system test, automatically extracts a set of unit tests that replicate the calls seen during the system test. &#160;The key idea is to record such calls such that we can replay them later – as a whole or selectively. &#160;On top, we also explore how to synthesize API grammars from carved unit tests; this means that we can synthesize API tests without having to write a grammar at all.">
<polygon fill="white" stroke="black" points="937.25,-36 814,-36 814,0 943.25,0 943.25,-30 937.25,-36"/>
<polyline fill="none" stroke="black" points="937.25,-36 937.25,-30"/>
<polyline fill="none" stroke="black" points="943.25,-30 937.25,-30"/>
<text text-anchor="middle" x="878.62" y="-13.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Carving Unit Tests</text>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;Carver -->
<g id="edge27" class="edge">
<title>GrammarCoverageFuzzer&#45;&gt;Carver</title>
<path fill="none" stroke="black" d="M1078.36,-235.55C1094.18,-226.24 1110.8,-213.13 1119.62,-196 1131.56,-172.84 1113.2,-77 1108.62,-72 1088.01,-49.45 1013.36,-35.18 954.62,-27.2"/>
<polygon fill="black" stroke="black" points="955.35,-23.77 944.98,-25.94 954.44,-30.71 955.35,-23.77"/>
</g>
<!-- GUIFuzzer -->
<g id="node27" class="node">
<title>GUIFuzzer</title>
<g id="a_node27"><a xlink:href="GUIFuzzer.ipynb" xlink:title="Testing Graphical User Interfaces (GUIFuzzer)&#10;&#10;In this chapter, we explore how to generate tests for Graphical User Interfaces (GUIs), abstracting from our previous examples on Web testing. &#160;Building on general means to extract user interface elements and activate them, our techniques generalize to arbitrary graphical user interfaces, from rich Web applications to mobile apps, and systematically explore user interfaces through forms and navigation elements.">
<polygon fill="white" stroke="black" points="1394.25,-196 1277,-196 1277,-152 1400.25,-152 1400.25,-190 1394.25,-196"/>
<polyline fill="none" stroke="black" points="1394.25,-196 1394.25,-190"/>
<polyline fill="none" stroke="black" points="1400.25,-190 1394.25,-190"/>
<text text-anchor="middle" x="1338.62" y="-178.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing Graphical</text>
<text text-anchor="middle" x="1338.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">User Interfaces</text>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;GUIFuzzer -->
<g id="edge28" class="edge">
<title>GrammarCoverageFuzzer&#45;&gt;GUIFuzzer</title>
<path fill="none" stroke="black" d="M1103.47,-235.51C1107.92,-234.31 1112.34,-233.13 1116.62,-232 1166.34,-218.84 1222.45,-204.44 1265.81,-193.4"/>
<polygon fill="black" stroke="black" points="1266.54,-196.83 1275.37,-190.97 1264.82,-190.05 1266.54,-196.83"/>
</g>
<!-- APIFuzzer -->
<g id="node29" class="node">
<title>APIFuzzer</title>
<g id="a_node29"><a xlink:href="APIFuzzer.ipynb" xlink:title="Fuzzing APIs (APIFuzzer)&#10;&#10;So far, we have always generated system input, i.e. data that the program as a whole obtains via its input channels. &#160;However, we can also generate inputs that go directly into individual functions, gaining flexibility and speed in the process. &#160;In this chapter, we explore the use of grammars to synthesize code for function calls, which allows you to generate program code that very efficiently invokes functions directly.">
<polygon fill="white" stroke="black" points="640.38,-112 550.88,-112 550.88,-76 646.38,-76 646.38,-106 640.38,-112"/>
<polyline fill="none" stroke="black" points="640.38,-112 640.38,-106"/>
<polyline fill="none" stroke="black" points="646.38,-106 640.38,-106"/>
<text text-anchor="middle" x="598.62" y="-89.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing APIs</text>
</a>
</g>
</g>
<!-- ProbabilisticGrammarFuzzer&#45;&gt;APIFuzzer -->
<g id="edge32" class="edge">
<title>ProbabilisticGrammarFuzzer&#45;&gt;APIFuzzer</title>
<path fill="none" stroke="black" d="M461.52,-151.58C487.74,-140.76 519.5,-127.66 545.84,-116.78"/>
<polygon fill="black" stroke="black" points="547.09,-120.06 554.99,-113.01 544.42,-113.59 547.09,-120.06"/>
</g>
<!-- GreyboxGrammarFuzzer -->
<g id="node17" class="node">
<title>GreyboxGrammarFuzzer</title>
<g id="a_node17"><a xlink:href="GreyboxGrammarFuzzer.ipynb" xlink:title="Greybox Fuzzing with Grammars (GreyboxGrammarFuzzer)&#10;&#10;In this chapter, we introduce important extensions to our syntactic fuzzing techniques, all leveraging syntactic parts of existing inputs.">
<polygon fill="white" stroke="black" points="809.12,-116 664.12,-116 664.12,-72 815.12,-72 815.12,-110 809.12,-116"/>
<polyline fill="none" stroke="black" points="809.12,-116 809.12,-110"/>
<polyline fill="none" stroke="black" points="815.12,-110 809.12,-110"/>
<text text-anchor="middle" x="739.62" y="-98.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Greybox Fuzzing with</text>
<text text-anchor="middle" x="739.62" y="-80.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammars</text>
</a>
</g>
</g>
<!-- GreyboxFuzzer&#45;&gt;GreyboxGrammarFuzzer -->
<g id="edge16" class="edge">
<title>GreyboxFuzzer&#45;&gt;GreyboxGrammarFuzzer</title>
<path fill="none" stroke="black" d="M592.57,-155.69C617.45,-145.42 649.46,-132.21 677.25,-120.74"/>
<polygon fill="black" stroke="black" points="678.37,-124.07 686.28,-117.02 675.7,-117.6 678.37,-124.07"/>
</g>
<!-- GrammarFuzzer&#45;&gt;GrammarCoverageFuzzer -->
<g id="edge18" class="edge">
<title>GrammarFuzzer&#45;&gt;GrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M989.48,-311.69C997.94,-302.13 1007.98,-290.77 1016.85,-280.74"/>
<polygon fill="black" stroke="black" points="1019.27,-283.29 1023.28,-273.48 1014.03,-278.65 1019.27,-283.29"/>
</g>
<!-- GrammarFuzzer&#45;&gt;PythonFuzzer -->
<g id="edge23" class="edge">
<title>GrammarFuzzer&#45;&gt;PythonFuzzer</title>
<path fill="none" stroke="black" d="M905.72,-311.99C871.26,-300.84 829.01,-287.17 794.54,-276.01"/>
<polygon fill="black" stroke="black" points="795.67,-272.7 785.08,-272.95 793.52,-279.36 795.67,-272.7"/>
</g>
<!-- Parser -->
<g id="node19" class="node">
<title>Parser</title>
<g id="a_node19"><a xlink:href="Parser.ipynb" xlink:title="Parsing Inputs (Parser)&#10;&#10;In the chapter on Grammars, we discussed how grammars can be&#10;used to represent various languages. We also saw how grammars can be used to&#10;generate strings of the corresponding language. Grammars can also perform the&#10;reverse. That is, given a string, one can decompose the string into its&#10;constituent parts that correspond to the parts of grammar used to generate it&#10;– the derivation tree of that string. These parts (and parts from other similar&#10;strings) can later be recombined using the same grammar to produce new strings.">
<polygon fill="white" stroke="black" points="948.25,-272 849,-272 849,-236 954.25,-236 954.25,-266 948.25,-272"/>
<polyline fill="none" stroke="black" points="948.25,-272 948.25,-266"/>
<polyline fill="none" stroke="black" points="954.25,-266 948.25,-266"/>
<text text-anchor="middle" x="901.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Parsing Inputs</text>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;Parser -->
<g id="edge19" class="edge">
<title>GrammarFuzzer&#45;&gt;Parser</title>
<path fill="none" stroke="black" d="M951.77,-311.69C943.31,-302.13 933.27,-290.77 924.4,-280.74"/>
<polygon fill="black" stroke="black" points="927.22,-278.65 917.97,-273.48 921.98,-283.29 927.22,-278.65"/>
</g>
<!-- GeneratorGrammarFuzzer -->
<g id="node20" class="node">
<title>GeneratorGrammarFuzzer</title>
<g id="a_node20"><a xlink:href="GeneratorGrammarFuzzer.ipynb" xlink:title="Fuzzing with Generators (GeneratorGrammarFuzzer)&#10;&#10;In this chapter, we show how to extend grammars with functions – pieces of code that get executed during grammar expansion, and that can generate, check, or change elements produced. &#160;Adding functions to a grammar allows for very versatile test generation, bringing together the best of grammar generation and programming.">
<polygon fill="white" stroke="black" points="756.75,-196 666.5,-196 666.5,-152 762.75,-152 762.75,-190 756.75,-196"/>
<polyline fill="none" stroke="black" points="756.75,-196 756.75,-190"/>
<polyline fill="none" stroke="black" points="762.75,-190 756.75,-190"/>
<text text-anchor="middle" x="714.62" y="-178.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing with</text>
<text text-anchor="middle" x="714.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Generators</text>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;GeneratorGrammarFuzzer -->
<g id="edge20" class="edge">
<title>GrammarFuzzer&#45;&gt;GeneratorGrammarFuzzer</title>
<path fill="none" stroke="black" d="M905.9,-311.54C883.72,-302.49 859.5,-290.63 839.62,-276 818.81,-260.68 821.06,-249.02 801.62,-232 789.49,-221.37 775.23,-211.22 761.81,-202.51"/>
<polygon fill="black" stroke="black" points="763.83,-199.64 753.51,-197.25 760.08,-205.56 763.83,-199.64"/>
</g>
<!-- Reducer -->
<g id="node21" class="node">
<title>Reducer</title>
<g id="a_node21"><a xlink:href="Reducer.ipynb" xlink:title="Reducing Failure&#45;Inducing Inputs (Reducer)&#10;&#10;By construction, fuzzers create inputs that may be hard to read. &#160;This causes issues during debugging, when a human has to analyze the exact cause of the failure. &#160;In this chapter, we present techniques that automatically reduce and simplify failure&#45;inducing inputs to a minimum in order to ease debugging.">
<polygon fill="white" stroke="black" points="1357.62,-276 1239.62,-276 1239.62,-232 1363.62,-232 1363.62,-270 1357.62,-276"/>
<polyline fill="none" stroke="black" points="1357.62,-276 1357.62,-270"/>
<polyline fill="none" stroke="black" points="1363.62,-270 1357.62,-270"/>
<text text-anchor="middle" x="1301.62" y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Reducing Failure&#45;</text>
<text text-anchor="middle" x="1301.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Inducing Inputs</text>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;Reducer -->
<g id="edge21" class="edge">
<title>GrammarFuzzer&#45;&gt;Reducer</title>
<path fill="none" stroke="black" d="M1035.57,-320.11C1085.78,-309.84 1157.22,-294.56 1228.4,-276.5"/>
<polygon fill="black" stroke="black" points="1229.07,-279.94 1237.89,-274.07 1227.34,-273.16 1229.07,-279.94"/>
</g>
<!-- FuzzingWithConstraints -->
<g id="node22" class="node">
<title>FuzzingWithConstraints</title>
<g id="a_node22"><a xlink:href="FuzzingWithConstraints.ipynb" xlink:title="Fuzzing with Constraints (FuzzingWithConstraints)&#10;&#10;In previous chapters, we have seen how Grammar&#45;Based Fuzzing allows us to efficiently generate myriads of syntactically valid inputs.&#10;However, there are semantic input features that cannot be expressed in a context&#45;free grammar, such as">
<polygon fill="white" stroke="black" points="1215.75,-276 1125.5,-276 1125.5,-232 1221.75,-232 1221.75,-270 1215.75,-276"/>
<polyline fill="none" stroke="black" points="1215.75,-276 1215.75,-270"/>
<polyline fill="none" stroke="black" points="1221.75,-270 1215.75,-270"/>
<text text-anchor="middle" x="1173.62" y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing with</text>
<text text-anchor="middle" x="1173.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Constraints</text>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;FuzzingWithConstraints -->
<g id="edge22" class="edge">
<title>GrammarFuzzer&#45;&gt;FuzzingWithConstraints</title>
<path fill="none" stroke="black" d="M1026.36,-311.58C1053.84,-301.03 1086.98,-288.29 1114.85,-277.58"/>
<polygon fill="black" stroke="black" points="1115.76,-280.98 1123.84,-274.13 1113.25,-274.45 1115.76,-280.98"/>
</g>
<!-- WebFuzzer -->
<g id="node23" class="node">
<title>WebFuzzer</title>
<g id="a_node23"><a xlink:href="WebFuzzer.ipynb" xlink:title="Testing Web Applications (WebFuzzer)&#10;&#10;In this chapter, we explore how to generate tests for Graphical User Interfaces (GUIs), notably on Web interfaces. &#160;We set up a (vulnerable) Web server and demonstrate how to systematically explore its behavior – first with handwritten grammars, then with grammars automatically inferred from the user interface. &#160;We also show how to conduct systematic attacks on these servers, notably with code and SQL injection.">
<polygon fill="white" stroke="black" points="1467.88,-276 1381.38,-276 1381.38,-232 1473.88,-232 1473.88,-270 1467.88,-276"/>
<polyline fill="none" stroke="black" points="1467.88,-276 1467.88,-270"/>
<polyline fill="none" stroke="black" points="1473.88,-270 1467.88,-270"/>
<text text-anchor="middle" x="1427.62" y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing Web</text>
<text text-anchor="middle" x="1427.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Applications</text>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;WebFuzzer -->
<g id="edge24" class="edge">
<title>GrammarFuzzer&#45;&gt;WebFuzzer</title>
<path fill="none" stroke="black" d="M1035.55,-328.29C1113.41,-321.65 1247.76,-307.04 1370.01,-276.41"/>
<polygon fill="black" stroke="black" points="1370.76,-279.84 1379.58,-273.97 1369.03,-273.05 1370.76,-279.84"/>
</g>
<!-- Parser&#45;&gt;ProbabilisticGrammarFuzzer -->
<g id="edge29" class="edge">
<title>Parser&#45;&gt;ProbabilisticGrammarFuzzer</title>
<path fill="none" stroke="black" d="M848.6,-240.89C833.48,-237.7 816.95,-234.47 801.62,-232 663.91,-209.84 623.97,-223.41 484.21,-196.35"/>
<polygon fill="black" stroke="black" points="485.05,-192.95 474.57,-194.44 483.7,-199.82 485.05,-192.95"/>
</g>
<!-- Parser&#45;&gt;GreyboxGrammarFuzzer -->
<g id="edge30" class="edge">
<title>Parser&#45;&gt;GreyboxGrammarFuzzer</title>
<path fill="none" stroke="black" d="M866.5,-235.72C848.27,-225.7 826.38,-211.92 809.62,-196 788.09,-175.54 769.28,-147.47 756.59,-126.11"/>
<polygon fill="black" stroke="black" points="759.67,-124.44 751.63,-117.53 753.61,-127.94 759.67,-124.44"/>
</g>
<!-- InformationFlow -->
<g id="node28" class="node">
<title>InformationFlow</title>
<g id="a_node28"><a xlink:href="InformationFlow.ipynb" xlink:title="Tracking Information Flow (InformationFlow)&#10;&#10;We have explored how one could generate better inputs that can penetrate deeper into the program in question. While doing so, we have relied on program crashes to tell us that we have succeeded in finding problems in the program. However, that is rather simplistic. What if the behavior of the program is simply incorrect, but does not lead to a crash? Can one do better?">
<polygon fill="white" stroke="black" points="961,-196 818.25,-196 818.25,-152 967,-152 967,-190 961,-196"/>
<polyline fill="none" stroke="black" points="961,-196 961,-190"/>
<polyline fill="none" stroke="black" points="967,-190 961,-190"/>
<text text-anchor="middle" x="892.62" y="-178.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Tracking Information</text>
<text text-anchor="middle" x="892.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Flow</text>
</a>
</g>
</g>
<!-- Parser&#45;&gt;InformationFlow -->
<g id="edge31" class="edge">
<title>Parser&#45;&gt;InformationFlow</title>
<path fill="none" stroke="black" d="M899.63,-235.69C898.68,-227.46 897.51,-217.33 896.4,-207.73"/>
<polygon fill="black" stroke="black" points="899.9,-207.48 895.27,-197.94 892.94,-208.28 899.9,-207.48"/>
</g>
<!-- GeneratorGrammarFuzzer&#45;&gt;APIFuzzer -->
<g id="edge33" class="edge">
<title>GeneratorGrammarFuzzer&#45;&gt;APIFuzzer</title>
<path fill="none" stroke="black" d="M682.93,-151.69C667.71,-141.45 649.42,-129.15 633.77,-118.63"/>
<polygon fill="black" stroke="black" points="635.93,-115.87 625.68,-113.19 632.02,-121.68 635.93,-115.87"/>
</g>
<!-- WebFuzzer&#45;&gt;GUIFuzzer -->
<g id="edge37" class="edge">
<title>WebFuzzer&#45;&gt;GUIFuzzer</title>
<path fill="none" stroke="black" d="M1403.31,-231.69C1393.49,-223.09 1382.02,-213.03 1371.49,-203.8"/>
<polygon fill="black" stroke="black" points="1373.88,-201.24 1364.05,-197.29 1369.27,-206.51 1373.88,-201.24"/>
</g>
<!-- InformationFlow&#45;&gt;ConcolicFuzzer -->
<g id="edge35" class="edge">
<title>InformationFlow&#45;&gt;ConcolicFuzzer</title>
<path fill="none" stroke="black" d="M892.62,-151.69C892.62,-143.09 892.62,-133.05 892.62,-123.82"/>
<polygon fill="black" stroke="black" points="896.13,-123.86 892.63,-113.86 889.13,-123.86 896.13,-123.86"/>
</g>
<!-- InformationFlow&#45;&gt;GrammarMiner -->
<g id="edge34" class="edge">
<title>InformationFlow&#45;&gt;GrammarMiner</title>
<path fill="none" stroke="black" d="M935.8,-151.69C954.71,-142.35 977.09,-131.3 997.04,-121.45"/>
<polygon fill="black" stroke="black" points="998.45,-124.66 1005.87,-117.09 995.36,-118.38 998.45,-124.66"/>
</g>
<!-- APIFuzzer&#45;&gt;Carver -->
<g id="edge36" class="edge">
<title>APIFuzzer&#45;&gt;Carver</title>
<path fill="none" stroke="black" d="M643.69,-75.54C647.37,-74.29 651.05,-73.09 654.62,-72 703.33,-57.17 759.04,-43.97 802.72,-34.46"/>
<polygon fill="black" stroke="black" points="803.32,-37.91 812.36,-32.38 801.85,-31.07 803.32,-37.91"/>
</g>
</g>
</svg>
</div></div>
</div>
<p>But since even this map can be overwhelming, here are a few <em>tours</em> to get you started.  Each of these tours allows you to focus on a particular view, depending on whether you are a programmer, student, or researcher.</p>
<section id="the-pragmatic-programmer-tour">
<h2>The Pragmatic Programmer Tour<a class="headerlink" href="#the-pragmatic-programmer-tour" title="Link to this heading">#</a></h2>
<p>You have a program to test.  You want to generate tests as quickly as possible and as thoroughly as possible. You don’t care so much <em>how</em> something is implemented, but it should get the job done.  You want to learn how to <em>use</em> things.</p>
<ol class="arabic simple">
<li><p><strong>Start with <a class="reference internal" href="Intro_Testing.html"><span class="std std-doc">Introduction to Testing</span></a> to get the basic concepts.</strong>  (You would know most of these anyway, but it can’t hurt to get quick reminders).</p></li>
<li><p><strong>Use the simple fuzzers from <a class="reference internal" href="Fuzzer.html"><span class="std std-doc">the chapter on Fuzzers</span></a></strong> to test your program against the first random inputs.</p></li>
<li><p><strong>Get <a class="reference internal" href="Coverage.html"><span class="std std-doc">coverage</span></a> from your program</strong> and use coverage information to <a class="reference internal" href="GreyboxFuzzer.html"><span class="std std-doc">guide test generation towards code coverage</span></a>.</p></li>
<li><p><strong>Define an <a class="reference internal" href="Grammars.html"><span class="std std-doc">input grammar</span></a> for your program</strong> and use this grammar to thoroughly fuzz your program with syntactically correct inputs.  As fuzzer, we would recommend a <a class="reference internal" href="GrammarCoverageFuzzer.html"><span class="doc std std-doc">grammar coverage fuzzer</span></a>, as this ensures coverage of input elements.</p></li>
<li><p>If you want <strong>more control over the generated inputs,</strong> consider <a class="reference internal" href="ProbabilisticGrammarFuzzer.html"><span class="std std-doc">probabilistic fuzzing</span></a> and <a class="reference internal" href="GeneratorGrammarFuzzer.html"><span class="std std-doc">fuzzing with generator functions</span></a>.</p></li>
<li><p>If you want to <strong>deploy a large set of fuzzers</strong>, learn how to <a class="reference internal" href="FuzzingInTheLarge.html"><span class="std std-doc">manage a large set of fuzzers</span></a>.</p></li>
</ol>
<p>In each of these chapters, start with the “Synopsis” parts; these will give you quick introductions on how to use things, as well as point you to relevant usage examples.  With this, enough said.  Get back to work and enjoy!</p>
</section>
<section id="the-page-by-page-tours">
<h2>The Page-by-Page Tours<a class="headerlink" href="#the-page-by-page-tours" title="Link to this heading">#</a></h2>
<p>These tours are how the book is organized.  Having gone through the <a class="reference internal" href="Intro_Testing.html"><span class="std std-doc">Introduction to Testing</span></a> for the basic concepts, you can read your way through these parts:</p>
<ol class="arabic simple">
<li><p><strong>The <a class="reference internal" href="02_Lexical_Fuzzing.html"><span class="std std-doc">lexical tour</span></a></strong> focuses on <em>lexical</em> test generation techniques, i.e. techniques that compose an input character by character and byte by byte.  Very fast and robust techniques with a minimum of bias.</p></li>
<li><p><strong>The <a class="reference internal" href="03_Syntactical_Fuzzing.html"><span class="std std-doc">syntactical tour</span></a></strong> focuses on <em>grammars</em> as a means to specify the syntax of inputs.  The resulting test generators produce syntactically correct inputs, making tests much faster, and provide lots of control mechanisms for the tester.</p></li>
<li><p><strong>The <a class="reference internal" href="04_Semantical_Fuzzing.html"><span class="std std-doc">semantic tour</span></a></strong> makes use of <em>code semantics</em> to shape and guide test generation.  Advanced techniques include extracting input grammars, mining function specifications, and symbolic constraint solving to cover as many code paths as possible.</p></li>
<li><p><strong>The <a class="reference internal" href="05_Domain-Specific_Fuzzing.html"><span class="std std-doc">application tour</span></a></strong> applies the techniques defined in the earlier parts on domains such as Web servers, user interfaces, APIs, or configurations.</p></li>
<li><p><strong>The <a class="reference internal" href="06_Managing_Fuzzing.html"><span class="std std-doc">management tour</span></a></strong> finally focuses on how to handle and organize large sets of test generators, and when to stop fuzzing.</p></li>
</ol>
<p>Most of these chapters start with a “Synopsis” section that explains how to use the most important concepts.  You can choose whether you want a “usage” perspective (then just read the synopsis) or an “understanding” perspective (then read on).</p>
</section>
<section id="the-undergraduate-tour">
<h2>The Undergraduate Tour<a class="headerlink" href="#the-undergraduate-tour" title="Link to this heading">#</a></h2>
<p>You are a student of computer science and/or software engineering.  You want to know basics of testing and related fields. Beyond just <em>using</em> techniques, you want to dig deeper into algorithms and implementations.  We have the following recommendation for you:</p>
<ol class="arabic simple">
<li><p>Start with <a class="reference internal" href="Intro_Testing.html"><span class="std std-doc">Introduction to Testing</span></a> and <a class="reference internal" href="Coverage.html"><span class="std std-doc">Coverage</span></a> to get the <strong>basic concepts.</strong> (You may know some of these already, but hey, you’re a student, right?)</p></li>
<li><p><strong>Learn how simple fuzzers work</strong> from <a class="reference internal" href="Fuzzer.html"><span class="std std-doc">the chapter on Fuzzers</span></a>.  This already gives you tools that took down 30% of UNIX utilities in the 90s.  What happens if you test some tool that has never been fuzzed before?</p></li>
<li><p><strong><a class="reference internal" href="MutationFuzzer.html"><span class="std std-doc">Mutation-based fuzzing</span></a></strong> is pretty much the standard in fuzzing today: Take a set of seeds, and mutate them until we find a bug.</p></li>
<li><p><strong>Learn how <a class="reference internal" href="Grammars.html"><span class="std std-doc">grammars</span></a> can be used to generate syntactically correct inputs.</strong> This makes test generation much more efficient, but you have to write (or <a class="reference internal" href="GrammarMiner.html"><span class="std std-doc">mine</span></a>) a grammar in the first place.</p></li>
<li><p><strong>Learn how to <a class="reference internal" href="APIFuzzer.html"><span class="std std-doc">fuzz APIs</span></a> and <a class="reference internal" href="GUIFuzzer.html"><span class="std std-doc">graphical user interfaces</span></a></strong>. Both of these are important domains for software test generation.</p></li>
<li><p><strong>Learn how to <a class="reference internal" href="Reducer.html"><span class="std std-doc">reduce failure-inducing inputs</span></a> to a minimum automatically</strong>.  This is a great time saver for debugging, especially in conjunction with automated testing.</p></li>
</ol>
<p>For all these chapters, experiment with the implementations to understand their concepts.  Feel free to experiment as you wish.</p>
<p>If you are a teacher, the above chapters can be useful in programming and/or software engineering courses.  Make use of slides and/or live programming, and have students work on exercises.</p>
</section>
<section id="the-graduate-tour">
<h2>The Graduate Tour<a class="headerlink" href="#the-graduate-tour" title="Link to this heading">#</a></h2>
<p>On top of the “Undergraduate” tour, you want to get deeper into test generation techniques, including techniques that are more demanding.</p>
<ol class="arabic simple">
<li><p><strong><a class="reference internal" href="SearchBasedFuzzer.html"><span class="std std-doc">Search-based testing</span></a></strong> allows you to guide test generation towards specific goals, such as code coverage.  Robust and efficient.</p></li>
<li><p>Get an introduction to <strong><a class="reference internal" href="ConfigurationFuzzer.html"><span class="std std-doc">configuration testing</span></a></strong>.  How does one test and cover a system that comes with multiple configuration options?</p></li>
<li><p><strong><a class="reference internal" href="MutationAnalysis.html"><span class="std std-doc">Mutation analysis</span></a></strong> seeds synthetic defects (mutations) into program code to check whether the tests find them.  If the tests do not find mutations, they likely won’t find real bugs either.</p></li>
<li><p><strong>Learn how to <a class="reference internal" href="Parser.html"><span class="std std-doc">parse</span></a> inputs</strong> using grammars.  If you want to analyze, decompose, mutate existing inputs, you need a parser for that.</p></li>
<li><p><strong><a class="reference internal" href="ConcolicFuzzer.html"><span class="std std-doc">Concolic</span></a> and <a class="reference internal" href="SymbolicFuzzer.html"><span class="std std-doc">symbolic</span></a> fuzzing</strong> solve constraints along program paths to reach code that is hard to test.  Used wherever reliability is paramount; also a hot research topic.</p></li>
<li><p><strong>Learn how to <a class="reference internal" href="WhenToStopFuzzing.html"><span class="std std-doc">estimate when to stop fuzzing</span></a></strong>.  There has to be a stop at some point, right?</p></li>
</ol>
<p>For all these chapters, experiment with the code; feel free to create your own variations and extensions.  This is how we get to research!</p>
<p>If you are a teacher, the above chapters can be useful in advanced courses on software engineering and testing.  Again, you can make use of slides and/or live programming, and have students work on exercises.</p>
</section>
<section id="the-black-box-tour">
<h2>The Black-Box Tour<a class="headerlink" href="#the-black-box-tour" title="Link to this heading">#</a></h2>
<p>This tour focuses on <em>black-box fuzzing</em> – that is, techniques that work without feedback from the program under test. Have a look at</p>
<ol class="arabic simple">
<li><p><strong><a class="reference internal" href="Fuzzer.html"><span class="std std-doc">Basic fuzzing</span></a></strong>.  This already gives you tools that took down 30% of UNIX utilities in the 90s.  What happens if you test some tool that has never been fuzzed before?</p></li>
<li><p><strong><a class="reference internal" href="03_Syntactical_Fuzzing.html"><span class="std std-doc">Syntactical fuzzing</span></a></strong> focuses on <em>grammars</em> as a means to specify the syntax of inputs.  The resulting test generators produce syntactically correct inputs, making tests much faster, and provide lots of control mechanisms for the tester.</p></li>
<li><p><strong><span class="xref myst">Semantic fuzzing</span></strong> attaches <em>constraints</em> to grammars, making inputs not only syntactically valid, but also <em>semantically</em> valid - and empowering you to shape test inputs just like you want them,</p></li>
<li><p><strong><a class="reference internal" href="05_Domain-Specific_Fuzzing.html"><span class="std std-doc">Domain-specific fuzzing</span></a></strong> showing a number of applications of these techniques, from configurations to graphical user interfaces.</p></li>
<li><p>If you want to <strong>deploy a large set of fuzzers</strong>, learn how to <a class="reference internal" href="FuzzingInTheLarge.html"><span class="std std-doc">manage a large set of fuzzers</span></a>.</p></li>
</ol>
</section>
<section id="the-white-box-tour">
<h2>The White-Box Tour<a class="headerlink" href="#the-white-box-tour" title="Link to this heading">#</a></h2>
<p>This tour focuses on <em>white-box fuzzing</em> – that is, techniques that leverage feedback from the program under test. Have a look at</p>
<ol class="arabic simple">
<li><p><strong><a class="reference internal" href="Coverage.html"><span class="std std-doc">Coverage</span></a></strong> to get the basic concepts of coverage and how to measure it for Python.</p></li>
<li><p><strong><a class="reference internal" href="MutationFuzzer.html"><span class="std std-doc">Mutation-based fuzzing</span></a></strong> is pretty much the standard in fuzzing today: Take a set of seeds, and mutate them until we find a bug.</p></li>
<li><p><strong><a class="reference internal" href="GreyboxFuzzer.html"><span class="std std-doc">Greybox fuzzing</span></a></strong> with algorithms from the popular American Fuzzy Lop (AFL) fuzzer.</p></li>
<li><p><strong><a class="reference internal" href="InformationFlow.html"><span class="std std-doc">Information Flow</span></a></strong> and <strong><a class="reference internal" href="ConcolicFuzzer.html"><span class="std std-doc">Concolic Fuzzing</span></a></strong> showing how to capture information flow in Python programs and how to leverage it to produce more intelligent test cases.</p></li>
<li><p><strong><a class="reference internal" href="SymbolicFuzzer.html"><span class="std std-doc">Symbolic Fuzzing</span></a></strong>, reasoning about the behavior of a program without executing it.</p></li>
</ol>
</section>
<section id="the-researcher-tour">
<h2>The Researcher Tour<a class="headerlink" href="#the-researcher-tour" title="Link to this heading">#</a></h2>
<p>On top of the “Graduate” tour, you are looking for techniques that are somewhere between lab stage and widespread usage – in particular, techniques where there is still room for lots of improvement.  If you look for research ideas, go for these topics.</p>
<ol class="arabic simple">
<li><p><strong><a class="reference internal" href="DynamicInvariants.html"><span class="std std-doc">Mining function specifications</span></a></strong> is a hot topic in research: Given a function, how can we infer an abstract model that describes its behavior?  The conjunction with test generation offers several opportunities here, in particular for dynamic specification mining.</p></li>
<li><p><strong><a class="reference internal" href="GrammarMiner.html"><span class="std std-doc">Mining input grammars</span></a></strong> promises to join the robustness and ease of use of lexical fuzzing with the efficiency and speed of syntactical fuzzing.  The idea is to mine an input grammar from a program automatically, which then serves as base for syntactical fuzzing.  Still in an early stage, but lots of potential.</p></li>
<li><p><strong><a class="reference internal" href="ProbabilisticGrammarFuzzer.html"><span class="std std-doc">Probabilistic grammar fuzzing</span></a></strong> gives programmers lots of control over which elements should be generated.  Plenty of research possibilities at the intersection of probabilistic fuzzing and mining data from given tests, as sketched in this chapter.</p></li>
<li><p><strong><a class="reference internal" href="GeneratorGrammarFuzzer.html"><span class="std std-doc">Fuzzing with generators</span></a></strong> and <strong><a class="reference internal" href="FuzzingWithConstraints.html"><span class="std std-doc">Fuzzing with constraints</span></a></strong> gives programmers the ultimate control over input generation, namely by allowing them to define their own generator functions or to define their own input constraints.  The big challenge is: How can one best exploit the power of syntactic descriptions with a minimum of contextual constraints?</p></li>
<li><p><strong><a class="reference internal" href="Carver.html"><span class="std std-doc">Carving unit tests</span></a></strong> brings the promise of speeding up test execution (and generation) dramatically, by extracting unit tests from program executions that replay only individual function calls (possibly with new, generated arguments).  In Python, carving is simple to realize; here’s plenty of potential to toy with.</p></li>
<li><p><strong>Testing <a class="reference internal" href="WebFuzzer.html"><span class="std std-doc">web servers</span></a> and <a class="reference internal" href="GUIFuzzer.html"><span class="std std-doc">GUIs</span></a></strong> is a hot research field, fueled by the need of practitioners to test and secure their interfaces (and the need of other practitioners to break through these interfaces).  Again, there’s still lots of unexplored potential here.</p></li>
<li><p><strong><a class="reference internal" href="GreyboxFuzzer.html"><span class="std std-doc">Greybox fuzzing</span></a> and <a class="reference internal" href="GreyboxGrammarFuzzer.html"><span class="std std-doc">greybox fuzzing with grammars</span></a></strong> bring in <em>statistical estimators</em> to guide test generation towards inputs and input properties that are most likely to discover new bugs.  The intersection of testing, program analysis, and statistics offers lots of possibilities for future research.</p></li>
</ol>
<p>For all these topics, having Python source available that implements and demonstrates the concepts is a major asset.  You can easily extend the implementations with your own ideas and run evaluations right in a notebook.  Once your approach is stable, consider porting it to a language with a wider range of available subjects (such as C, for example).</p>
</section>
<section id="the-author-tour">
<h2>The Author Tour<a class="headerlink" href="#the-author-tour" title="Link to this heading">#</a></h2>
<p>This is the ultimate tour – you have learned everything there is and want to contribute to the book.  Then, you should read two more chapters:</p>
<ol class="arabic simple">
<li><p>The <strong><a class="reference internal" href="Guide_for_Authors.html"><span class="std std-doc">guide for authors</span></a></strong> gives an introduction on how to contribute to this book (coding styles, writing styles, conventions, and more).</p></li>
<li><p>The <strong><a class="reference internal" href="Template.html"><span class="std std-doc">template chapter</span></a></strong> serves as a blueprint for your chapter.</p></li>
</ol>
<p>If you want to contribute, feel free to contact us – preferably before writing, but after writing is fine just as well.  We will be happy to incorporate your material.</p>
</section>
<section id="lessons-learned">
<h2>Lessons Learned<a class="headerlink" href="#lessons-learned" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>You can go through the book from beginning to end…</p></li>
<li><p>…but it may be preferable to follow a specific tour, based on your needs and resources.</p></li>
<li><p>Now <a class="reference internal" href="index.html"><span class="std std-doc">go and explore generating software tests</span></a>!</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">The Fuzzing Book</p>
      </div>
    </a>
    <a class="right-next"
       href="Intro_Testing.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Introduction to Software Testing</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-pragmatic-programmer-tour">The Pragmatic Programmer Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-page-by-page-tours">The Page-by-Page Tours</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-undergraduate-tour">The Undergraduate Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-graduate-tour">The Graduate Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-black-box-tour">The Black-Box Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-white-box-tour">The White-Box Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-researcher-tour">The Researcher Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-author-tour">The Author Tour</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021-2025 CISPA Helmholtz Center for Information Security (www.cispa.de); © Copyright 2018-2020 Saarland University, authors, and contributors. All Rights Reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>