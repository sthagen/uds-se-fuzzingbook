
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Probabilistic Grammar Fuzzing &#8212; The Fuzzing Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=42e1b1a5" />
    <link rel="stylesheet" type="text/css" href="_static/mastodon-timeline.css?v=f82c2b23" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ProbabilisticGrammarFuzzer';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Fuzzing with Generators" href="GeneratorGrammarFuzzer.html" />
    <link rel="prev" title="Parsing Inputs" href="Parser.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>
<aside class="bd-header-announcement" aria-label="Announcement">
  <div class="bd-header-announcement__content"><p>This is a beta version of fuzzingbook.org, currently in development. See the <a href="https://fuzzingbook.org/"  style="color:white!important;">classic site</a> for resources.</p></div>
</aside>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/fuzzingbook.png" class="logo__image only-light" alt="The Fuzzing Book - Home"/>
    <script>document.write(`<img src="_static/fuzzingbook.png" class="logo__image only-dark" alt="The Fuzzing Book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    The Fuzzing Book
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tours.html">Tours through the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="Intro_Testing.html">Introduction to Software Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lexical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Fuzzer.html">Fuzzing: Breaking Things with Random Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Coverage.html">Code Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationFuzzer.html">Mutation-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GreyboxFuzzer.html">Greybox Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SearchBasedFuzzer.html">Search-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationAnalysis.html">Mutation Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Syntactical Fuzzing</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Grammars.html">Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarFuzzer.html">Efficient Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarCoverageFuzzer.html">Grammar Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parser.html">Parsing Inputs</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Probabilistic Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeneratorGrammarFuzzer.html">Fuzzing with Generators</a></li>

<li class="toctree-l1"><a class="reference internal" href="GreyboxGrammarFuzzer.html">Greybox Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reducer.html">Reducing Failure-Inducing Inputs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Semantical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingWithConstraints.html">Fuzzing with Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarMiner.html">Mining Input Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="InformationFlow.html">Tracking Information Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConcolicFuzzer.html">Concolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SymbolicFuzzer.html">Symbolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DynamicInvariants.html">Mining Function Specifications</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Domain-Specific Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ConfigurationFuzzer.html">Testing Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="APIFuzzer.html">Fuzzing APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Carver.html">Carving Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="PythonFuzzer.html">Testing Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="WebFuzzer.html">Testing Web Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="GUIFuzzer.html">Testing Graphical User Interfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Managing Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingInTheLarge.html">Fuzzing in the Large</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhenToStopFuzzing.html">When To Stop Fuzzing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="AcademicPrototyping.html">Academic Prototyping</a></li>
<li class="toctree-l1"><a class="reference internal" href="PrototypingWithPython.html">Prototyping with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExpectError.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timer.html">Timer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timeout.html">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="ClassDiagram.html">Class Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="RailroadDiagrams.html">Railroad Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="ControlFlow.html">Control Flow Graph</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About This Book</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ReleaseNotes.html">Fuzzingbook Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Importing.html">Using Fuzzingbook Code in your own Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Guide_for_Authors.html">Guide for Authors</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?urlpath=tree/docs/notebooks/ProbabilisticGrammarFuzzer.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook/issues/new?title=Issue%20on%20page%20%2FProbabilisticGrammarFuzzer.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/ProbabilisticGrammarFuzzer.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Probabilistic Grammar Fuzzing</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-law-of-leading-digits">The Law of Leading Digits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specifying-probabilities">Specifying Probabilities</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-probabilities">Computing Probabilities</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#distributing-probabilities">Distributing Probabilities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-probabilities">Checking Probabilities</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#expanding-by-probability">Expanding by Probability</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#directed-fuzzing">Directed Fuzzing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probabilities-in-context">Probabilities in Context</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-probabilities-from-samples">Learning Probabilities from Samples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#counting-expansions">Counting Expansions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#assigning-probabilities">Assigning Probabilities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-common-features">Testing Common Features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-uncommon-features">Testing Uncommon Features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-probabilities-from-input-slices">Learning Probabilities from Input Slices</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#detecting-unnatural-numbers">Detecting Unnatural Numbers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-probabilistic-fuzzing-with-coverage">Exercise 1: Probabilistic Fuzzing with Coverage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-learning-from-past-bugs">Exercise 2: Learning from Past Bugs</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="probabilistic-grammar-fuzzing">
<h1>Probabilistic Grammar Fuzzing<a class="headerlink" href="#probabilistic-grammar-fuzzing" title="Link to this heading">#</a></h1>
<p>Let us give grammars even more power by assigning <em>probabilities</em> to individual expansions.  This allows us to control how many of each element should be produced, and thus allows us to <em>target</em> our generated tests towards specific functionality.  We also show how to learn such probabilities from given sample inputs, and specifically direct our tests towards input features that are uncommon in these samples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;9htOliNwopc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="640"
            height="360"
            src="https://www.youtube-nocookie.com/embed/9htOliNwopc"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
<p><strong>Prerequisites</strong></p>
<ul class="simple">
<li><p>You should have read the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>.</p></li>
<li><p>Our implementation hooks into the grammar-based fuzzer introduced in <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">“Efficient Grammar Fuzzing”</span></a></p></li>
<li><p>For learning probabilities from samples, we make use of <a class="reference internal" href="Parser.html"><span class="std std-doc">parsers</span></a>.</p></li>
</ul>
<section id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Link to this heading">#</a></h2>
<!-- Automatically generated. Do not edit. -->
<p>To <a class="reference internal" href="Importing.html"><span class="std std-doc">use the code provided in this chapter</span></a>, write</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fuzzingbook.ProbabilisticGrammarFuzzer</span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>and then make use of the following features.</p>
<p>A <em>probabilistic</em> grammar allows attaching individual <em>probabilities</em> to production rules.  To set the probability of an individual expansion <code class="docutils literal notranslate"><span class="pre">S</span></code> to the value <code class="docutils literal notranslate"><span class="pre">X</span></code> (between 0 and 1), replace it with a pair</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="n">X</span><span class="p">))</span>
</pre></div>
</div>
<p>If we want to ensure that 90% of phone numbers generated have an area code starting with <code class="docutils literal notranslate"><span class="pre">9</span></code>, we can write:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">US_PHONE_GRAMMAR</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">opts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PROBABILISTIC_US_PHONE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="s2">&quot;&lt;lead-digit&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>                          <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                          <span class="p">(</span><span class="s2">&quot;9&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.9</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span>                      <span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">})</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarFuzzer</span></code> will extract and interpret these options.  Here is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">probabilistic_us_phone_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">PROBABILISTIC_US_PHONE_GRAMMAR</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">probabilistic_us_phone_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[&#39;(918)925-2501&#39;,</span>
<span class="go"> &#39;(981)925-0792&#39;,</span>
<span class="go"> &#39;(934)995-5029&#39;,</span>
<span class="go"> &#39;(955)999-7801&#39;,</span>
<span class="go"> &#39;(964)927-0877&#39;]</span>
</pre></div>
</div>
<p>As you can see, the large majority of area codes now starts with <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
<p><img alt="" src="_images/ProbabilisticGrammarFuzzer-synopsis-1.svg" /></p>
</section>
<section id="the-law-of-leading-digits">
<h2>The Law of Leading Digits<a class="headerlink" href="#the-law-of-leading-digits" title="Link to this heading">#</a></h2>
<p>In all our examples so far, you may have noted that inputs generated by a program differ quite a bit from “natural” inputs as they occur in real life.  This is true even for innocuous elements such as numbers – yes, the numbers we have generated so far actually <em>differ</em> from numbers in the real world.  This is because in real-life sets of numerical data, the <em>leading significant digit</em> is likely to be small: Actually, on average, the leading digit <code class="docutils literal notranslate"><span class="pre">1</span></code> occurs more than <em>six times</em> as often as the leading digit <code class="docutils literal notranslate"><span class="pre">8</span></code> or <code class="docutils literal notranslate"><span class="pre">9</span></code>.  It has been shown that this result applies to a wide variety of data sets, including electricity bills, street addresses, stock prices, house prices, population numbers, death rates, lengths of rivers, physical and mathematical constants (Wikipedia).</p>
<p>This law of leading digits was first observed by Newcomb \cite{Newcomb1881} and later formalized by Benford in \cite{Benford1938}.  Let us take a look at the conditions that determine the first digit of a number.  We can easily compute the first digit by converting the number into a string and take the first character:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">first_digit_via_string</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">first_digit_via_string</span><span class="p">(</span><span class="mi">2001</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>To do this mathematically, though, we have to take the fractional part of their logarithm, or formally</p>
<div class="math notranslate nohighlight">
\[
d = 10^{\{\log_{10}(x)\}}
\]</div>
<p>where <span class="math notranslate nohighlight">\(\{x\}\)</span> is the fractional part of <span class="math notranslate nohighlight">\(x\)</span> (i.e. <span class="math notranslate nohighlight">\(\{1.234\} = 0.234\)</span>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">first_digit_via_log</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">frac</span><span class="p">,</span> <span class="n">whole</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">frac</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">first_digit_via_log</span><span class="p">(</span><span class="mi">2001</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Most sets of “naturally” occurring numbers should not have any bias in the fractional parts of their logarithms, and hence, the fractional part <span class="math notranslate nohighlight">\(\{\log_{10}(x)\}\)</span> is typically uniformly distributed.  However, the fractional parts for the individual digits are <em>not</em> evenly distributed.</p>
<p>For a number to start with a digit <span class="math notranslate nohighlight">\(d\)</span>, the condition <span class="math notranslate nohighlight">\(d &lt; 10^{\{\log_{10}(x)\}} &lt; d + 1\)</span> must hold.  To start with the digit 1, the fractional part <span class="math notranslate nohighlight">\(\{\log_{10}(x)\}\)</span> must thus be in the range</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.3010299956639812)
</pre></div>
</div>
</div>
</div>
<p>To start with the digit 2, though, it must be in the range</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.3010299956639812, 0.47712125471966244)
</pre></div>
</div>
</div>
</div>
<p>which is much smaller.  Formally, the probability <span class="math notranslate nohighlight">\(P(d)\)</span> for a leading digit <span class="math notranslate nohighlight">\(d\)</span> (again, assuming uniformly distributed fractional parts) is known as Benford’s law:
$<span class="math notranslate nohighlight">\(
P(d) = \log_{10}(d + 1) - \log_{10}(d)
\)</span>$
which gives us:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prob_leading_digit</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let us compute these probabilities for all digits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_probs</span> <span class="o">=</span> <span class="p">[</span><span class="n">prob_leading_digit</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">digit_probs</span><span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(1, &#39;0.30&#39;),
 (2, &#39;0.18&#39;),
 (3, &#39;0.12&#39;),
 (4, &#39;0.10&#39;),
 (5, &#39;0.08&#39;),
 (6, &#39;0.07&#39;),
 (7, &#39;0.06&#39;),
 (8, &#39;0.05&#39;),
 (9, &#39;0.05&#39;)]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">digit_probs</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">autopct</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.1f%%</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">counterclock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">startangle</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1f8bba9052c4a1aa830ef94a324db8601eab40b1c6b38f4024850ee2905efec6.png" src="_images/1f8bba9052c4a1aa830ef94a324db8601eab40b1c6b38f4024850ee2905efec6.png" />
</div>
</div>
<p>We see that a leading 1 is indeed six times as probable as a leading 9.</p>
<p>Benford’s law has a number of applications.  Most notably, it can be used to detect “non-natural” numbers, i.e. numbers that apparently were created randomly rather than coming from a “natural” source.  if you write a scientific paper and fake data by putting in random numbers (for instance, <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">using our grammar fuzzer</span></a> on integers), you will likely violate Benford’s law, and this can indeed be spotted.  On the other hand, how would we proceed if we <em>wanted</em> to create numbers that adhere to Benford’s law?  To this end, we need to be able to <em>encode</em> probabilities such as the above in our grammar, such that we can ensure that a leading digit is indeed a <code class="docutils literal notranslate"><span class="pre">1</span></code> in 30% of all cases.</p>
</section>
<section id="specifying-probabilities">
<h2>Specifying Probabilities<a class="headerlink" href="#specifying-probabilities" title="Link to this heading">#</a></h2>
<p>The goal of this chapter is to assign <em>probabilities</em> to individual expansions in the grammar, such that we can express that some expansion alternatives should be favored over others.  This is not only useful to generate “natural”-looking numbers, but even more so to <em>direct</em> test generation towards a specific goal.  If you recently have changed some code in your program, you would probably like to generate inputs that exercise precisely this code.  By raising the probabilities on the input elements associated with the changed code, you will get more tests that exercise the changed code.</p>
<p>Our concept for expressing probabilities is to <em>annotate</em> individual expansions with attributes such as probabilities, using the annotation mechanism introduced in <a class="reference internal" href="Grammars.html"><span class="std std-doc">the chapter on grammars</span></a>.  To this end, we allow that an expansion cannot only be a string, but also a <em>pair</em> of a string and a set of attributes, as in</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span>
        <span class="p">[(</span><span class="s2">&quot;&lt;term&gt; + &lt;expr&gt;&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;&lt;term&gt; - &lt;expr&gt;&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)),</span>
         <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">opts()</span></code> function would allow us to express probabilities for choosing the individual expansions.  The addition would have a probability of 10%, the subtraction of 20%.  The remaining probability (in this case 70%) is equally distributed over the non-attributed expansions (in this case the single last one).</p>
<p>We can now use pairs with <code class="docutils literal notranslate"><span class="pre">opts()</span></code> to assign probabilities to our expression grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bookutils.setup</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Fuzzer</span> <span class="kn">import</span> <span class="n">Fuzzer</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GrammarFuzzer</span> <span class="kn">import</span> <span class="n">GrammarFuzzer</span><span class="p">,</span> <span class="n">all_terminals</span><span class="p">,</span> <span class="n">display_tree</span><span class="p">,</span> <span class="n">DerivationTree</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">crange</span>
<span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">opts</span><span class="p">,</span> <span class="n">exp_string</span><span class="p">,</span> <span class="n">exp_opt</span><span class="p">,</span> <span class="n">set_opts</span>
<span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">Expansion</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">:</span>
        <span class="p">[(</span><span class="s2">&quot;&lt;term&gt; + &lt;expr&gt;&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;&lt;term&gt; - &lt;expr&gt;&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)),</span>
         <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">:</span>
        <span class="p">[(</span><span class="s2">&quot;&lt;factor&gt; * &lt;term&gt;&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;&lt;factor&gt; / &lt;term&gt;&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)),</span>
         <span class="s2">&quot;&lt;factor&gt;&quot;</span>
         <span class="p">],</span>

    <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;+&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;-&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&lt;expr&gt;)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&lt;leadinteger&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;leadinteger&gt;.&lt;integer&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;leadinteger&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;leaddigit&gt;&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">],</span>

    <span class="c1"># Benford&#39;s law: frequency distribution of leading digits</span>
    <span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">:</span>
        <span class="p">[(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.301</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.176</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.125</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.097</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.079</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.067</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.058</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.051</span><span class="p">)),</span>
         <span class="p">(</span><span class="s2">&quot;9&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.046</span><span class="p">)),</span>
         <span class="p">],</span>

    <span class="c1"># Remaining digits are equally distributed</span>
    <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">],</span>

    <span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">supported_opts</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;prob&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>This is how the grammar expansions are represented internally:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">leaddigits</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expansion</span><span class="p">]</span> <span class="o">=</span> <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">]</span>
<span class="n">leaddigits</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;1&#39;, {&#39;prob&#39;: 0.301}),
 (&#39;2&#39;, {&#39;prob&#39;: 0.176}),
 (&#39;3&#39;, {&#39;prob&#39;: 0.125}),
 (&#39;4&#39;, {&#39;prob&#39;: 0.097}),
 (&#39;5&#39;, {&#39;prob&#39;: 0.079}),
 (&#39;6&#39;, {&#39;prob&#39;: 0.067}),
 (&#39;7&#39;, {&#39;prob&#39;: 0.058}),
 (&#39;8&#39;, {&#39;prob&#39;: 0.051}),
 (&#39;9&#39;, {&#39;prob&#39;: 0.046})]
</pre></div>
</div>
</div>
</div>
<p>However, we typically access the expansion string and the associated probability via designated helper functions, <code class="docutils literal notranslate"><span class="pre">exp_string()</span></code> (from the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on Grammars</span></a>) and <code class="docutils literal notranslate"><span class="pre">exp_prob()</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">leaddigit_expansion</span> <span class="o">=</span> <span class="n">leaddigits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">leaddigit_expansion</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(&#39;1&#39;, {&#39;prob&#39;: 0.301})
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp_string</span><span class="p">(</span><span class="n">leaddigit_expansion</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;1&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">exp_prob</span><span class="p">(</span><span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the options of an expansion&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">exp_opt</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="s1">&#39;prob&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp_prob</span><span class="p">(</span><span class="n">leaddigit_expansion</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.301
</pre></div>
</div>
</div>
</div>
<p>Our existing fuzzers are all set up to work with grammars annotated this way.  They simply ignore all annotations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;4 + ++--7.0 - -7 - +++7.3 * (1 * 3 + 5 / 3 / 5 + 2) * 38 * (2 + 8)&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GrammarCoverageFuzzer</span> <span class="kn">import</span> <span class="n">GrammarCoverageFuzzer</span>  <span class="c1"># minor dependency</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;1.30&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="computing-probabilities">
<h2>Computing Probabilities<a class="headerlink" href="#computing-probabilities" title="Link to this heading">#</a></h2>
<p>Let us define functions that access probabilities for given expansions.  While doing so, they also check for inconsistencies.</p>
<section id="distributing-probabilities">
<h3>Distributing Probabilities<a class="headerlink" href="#distributing-probabilities" title="Link to this heading">#</a></h3>
<p>Here is how we distribute probabilities for expansions without specified probabilities. Given an expansion rule</p>
<div class="math notranslate nohighlight">
\[S ::= a_1\:|\: a_2 \:|\: \dots \:|\: a_n \:|\: u_1 \:|\: u_2 \:|\: \dots u_m\]</div>
<p>with <span class="math notranslate nohighlight">\(n \ge 0\)</span> alternatives <span class="math notranslate nohighlight">\(a_i\)</span> for which the probability <span class="math notranslate nohighlight">\(p(a_i)\)</span> is <em>specified</em> and
<span class="math notranslate nohighlight">\(m \ge 0\)</span> alternatives <span class="math notranslate nohighlight">\(u_j\)</span> for which the probability <span class="math notranslate nohighlight">\(p(u_j)\)</span> is <em>unspecified</em>,
the “remaining” probability is distributed equally over all <span class="math notranslate nohighlight">\(u_j\)</span>; in other words,</p>
<div class="math notranslate nohighlight">
\[p(u_j) = \frac{1 - \sum_{i = 1}^{n}p(a_i)}{m}\]</div>
<p>If no probabilities are specified (<span class="math notranslate nohighlight">\(n = 0\)</span>), then all expansions have the same probability.</p>
<p>The overall sum of probabilities must be 1:</p>
<div class="math notranslate nohighlight">
\[\sum_{i = 1}^{n} p(a_i) + \sum_{j = 1}^{m} p(u_i) = 1\]</div>
<p>We check these properties while distributing probabilities.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">exp_probabilities()</span></code> returns a mapping of all expansions in a rule to their respective probabilities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">exp_probabilities</span><span class="p">(</span><span class="n">expansions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expansion</span><span class="p">],</span>
                      <span class="n">nonterminal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;&lt;symbol&gt;&quot;</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Expansion</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_prob</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span> <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">expansions</span><span class="p">]</span>
    <span class="n">prob_dist</span> <span class="o">=</span> <span class="n">prob_distribution</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="n">prob_mapping</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Expansion</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expansions</span><span class="p">)):</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="n">exp_string</span><span class="p">(</span><span class="n">expansions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">prob_mapping</span><span class="p">[</span><span class="n">expansion</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">prob_mapping</span>
</pre></div>
</div>
</div>
</div>
<p>The gist of <code class="docutils literal notranslate"><span class="pre">exp_probabilities()</span></code> is handled in <code class="docutils literal notranslate"><span class="pre">prob_distribution()</span></code>, which does the actual checking and computation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">prob_distribution</span><span class="p">(</span><span class="n">probabilities</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
                      <span class="n">nonterminal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;symbol&gt;&quot;</span><span class="p">):</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.00001</span>

    <span class="n">number_of_unspecified_probabilities</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">number_of_unspecified_probabilities</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sum_probabilities</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sum_probabilities</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">,</span> \
            <span class="n">nonterminal</span> <span class="o">+</span> <span class="s2">&quot;: sum of probabilities must be 1.0&quot;</span>
        <span class="k">return</span> <span class="n">probabilities</span>

    <span class="n">sum_of_specified_probabilities</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probabilities</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sum_of_specified_probabilities</span> <span class="o">+=</span> <span class="n">p</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sum_of_specified_probabilities</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> \
        <span class="n">nonterminal</span> <span class="o">+</span> <span class="s2">&quot;: sum of specified probabilities must be between 0.0 and 1.0&quot;</span>

    <span class="n">default_probability</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">sum_of_specified_probabilities</span><span class="p">)</span>
                           <span class="o">/</span> <span class="n">number_of_unspecified_probabilities</span><span class="p">)</span>
    <span class="n">all_probabilities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probabilities</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">default_probability</span>
        <span class="n">all_probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">all_probabilities</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span>
    <span class="k">return</span> <span class="n">all_probabilities</span>
</pre></div>
</div>
</div>
</div>
<p>Here’s the mapping <code class="docutils literal notranslate"><span class="pre">exp_probabilities()</span></code> returns for the annotated <code class="docutils literal notranslate"><span class="pre">&lt;leaddigit&gt;</span></code> element:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">exp_probabilities</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;1&#39;: 0.301, &#39;2&#39;: 0.176, &#39;3&#39;: 0.125, &#39;4&#39;: 0.097, &#39;5&#39;: 0.079, &#39;6&#39;: 0.067, &#39;7&#39;: 0.058, &#39;8&#39;: 0.051, &#39;9&#39;: 0.046}
</pre></div>
</div>
</div>
</div>
<p>If no expansion is annotated, all expansions have the same likelihood of being selected, as in our previous grammar fuzzers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">exp_probabilities</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;0&#39;: 0.1, &#39;1&#39;: 0.1, &#39;2&#39;: 0.1, &#39;3&#39;: 0.1, &#39;4&#39;: 0.1, &#39;5&#39;: 0.1, &#39;6&#39;: 0.1, &#39;7&#39;: 0.1, &#39;8&#39;: 0.1, &#39;9&#39;: 0.1}
</pre></div>
</div>
</div>
</div>
<p>Here’s how <code class="docutils literal notranslate"><span class="pre">exp_probabilities()</span></code> distributes any remaining probability across non-annotated expansions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">exp_probabilities</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;term&gt; + &lt;expr&gt;&#39;: 0.1, &#39;&lt;term&gt; - &lt;expr&gt;&#39;: 0.2, &#39;&lt;term&gt;&#39;: 0.7}
</pre></div>
</div>
</div>
</div>
</section>
<section id="checking-probabilities">
<h3>Checking Probabilities<a class="headerlink" href="#checking-probabilities" title="Link to this heading">#</a></h3>
<p>We can use the checking capabilities of <code class="docutils literal notranslate"><span class="pre">exp_probabilities()</span></code> to check a probabilistic grammar for consistency:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
                                   <span class="n">start_symbol</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">START_SYMBOL</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">nonterminal</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
        <span class="n">expansions</span> <span class="o">=</span> <span class="n">grammar</span><span class="p">[</span><span class="n">nonterminal</span><span class="p">]</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">exp_probabilities</span><span class="p">(</span><span class="n">expansions</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ExpectError</span> <span class="kn">import</span> <span class="n">ExpectError</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">({</span><span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))]})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/1729613243.py&quot;, line 2, in &lt;module&gt;
    assert is_valid_probabilistic_grammar({&quot;&lt;start&gt;&quot;: [(&quot;1&quot;, opts(prob=0.5))]})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/3185228479.py&quot;, line 8, in is_valid_probabilistic_grammar
    _ = exp_probabilities(expansions, nonterminal)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/4013279880.py&quot;, line 5, in exp_probabilities
    prob_dist = prob_distribution(probabilities, nonterminal)  # type: ignore
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/1431748745.py&quot;, line 8, in prob_distribution
    assert abs(sum_probabilities - 1.0) &lt; epsilon, \
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: &lt;start&gt;: sum of probabilities must be 1.0 (expected)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)),</span> <span class="s2">&quot;2&quot;</span><span class="p">]})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Traceback (most recent call last):
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/2913569331.py&quot;, line 2, in &lt;module&gt;
    assert is_valid_probabilistic_grammar(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/3185228479.py&quot;, line 8, in is_valid_probabilistic_grammar
    _ = exp_probabilities(expansions, nonterminal)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/4013279880.py&quot;, line 5, in exp_probabilities
    prob_dist = prob_distribution(probabilities, nonterminal)  # type: ignore
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11325/1431748745.py&quot;, line 16, in prob_distribution
    assert 0 &lt;= sum_of_specified_probabilities &lt;= 1.0, \
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: &lt;start&gt;: sum of specified probabilities must be between 0.0 and 1.0 (expected)
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="expanding-by-probability">
<h2>Expanding by Probability<a class="headerlink" href="#expanding-by-probability" title="Link to this heading">#</a></h2>
<p>Now that we have seen how to specify probabilities for a grammar, we can actually implement probabilistic expansion.  In our <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarFuzzer</span></code>, it suffices to overload one method, namely <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code>.  For each of the children we can choose from (typically all expansions of a symbol), we determine their probability (using <code class="docutils literal notranslate"><span class="pre">exp_probabilities()</span></code> defined above), and make a weighted choice using <code class="docutils literal notranslate"><span class="pre">random.choices()</span></code> with a <code class="docutils literal notranslate"><span class="pre">weight</span></code> argument.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">GrammarFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A grammar-based fuzzer respecting probabilities in grammars.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">check_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">check_grammar</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">supported_opts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">()</span> <span class="o">|</span> <span class="p">{</span><span class="s1">&#39;prob&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">ProbabilisticGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">expansions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">exp_probabilities</span><span class="p">(</span><span class="n">expansions</span><span class="p">)</span>

        <span class="n">weights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">children_alternatives</span><span class="p">:</span>
            <span class="n">expansion</span> <span class="o">=</span> <span class="n">all_terminals</span><span class="p">((</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
            <span class="n">children_weight</span> <span class="o">=</span> <span class="n">probabilities</span><span class="p">[</span><span class="n">expansion</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">expansion</span><span class="p">),</span> <span class="s2">&quot;p =&quot;</span><span class="p">,</span> <span class="n">children_weight</span><span class="p">)</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">children_weight</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># No alternative (probably expanding at minimum cost)</span>
            <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)),</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Our probabilistic grammar fuzzer works just like the non-probabilistic grammar fuzzer, except that it actually respects probability annotations.  Let us generate a couple of “natural” numbers that respect Benford’s law:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">natural_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
    <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;leadinteger&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">natural_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;2588&#39;, &#39;106&#39;, &#39;10&#39;, &#39;2&#39;, &#39;7&#39;, &#39;1&#39;, &#39;95&#39;, &#39;4&#39;, &#39;192&#39;, &#39;8&#39;, &#39;2&#39;, &#39;1&#39;, &#39;1&#39;, &#39;2&#39;, &#39;2&#39;, &#39;208&#39;, &#39;1036&#39;, &#39;5592&#39;, &#39;157&#39;, &#39;1442&#39;]
</pre></div>
</div>
</div>
</div>
<p>In contrast, these numbers are pure random:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">integer_fuzzer</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span>
    <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;leadinteger&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">integer_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;3&#39;, &#39;1&#39;, &#39;56&#39;, &#39;5&#39;, &#39;408251024&#39;, &#39;7&#39;, &#39;27&#39;, &#39;2&#39;, &#39;9&#39;, &#39;6456&#39;, &#39;7&#39;, &#39;32&#39;, &#39;1&#39;, &#39;4&#39;, &#39;7&#39;, &#39;19&#39;, &#39;2&#39;, &#39;6&#39;, &#39;2&#39;, &#39;5&#39;]
</pre></div>
</div>
</div>
</div>
<p>Are the “natural” numbers really more “natural” than the random ones?  To show that <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarFuzzer</span></code> indeed respects  the probabilistic annotations, let us create a specific fuzzer for the lead digit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">leaddigit_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
    <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">)</span>
<span class="n">leaddigit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;8&#39;
</pre></div>
</div>
</div>
</div>
<p>If we generate thousands of lead digits, their distribution should again follow Benford’s law:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trials</span> <span class="o">=</span> <span class="mi">10000</span>

<span class="n">count</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">crange</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">):</span>
    <span class="n">count</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">count</span><span class="p">[</span><span class="n">leaddigit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">([(</span><span class="n">digit</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">digit</span><span class="p">]</span> <span class="o">/</span> <span class="n">trials</span><span class="p">)</span> <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="n">count</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;0&#39;, 0.0), (&#39;1&#39;, 0.3003), (&#39;2&#39;, 0.1756), (&#39;3&#39;, 0.1222), (&#39;4&#39;, 0.0938), (&#39;5&#39;, 0.0816), (&#39;6&#39;, 0.0651), (&#39;7&#39;, 0.06), (&#39;8&#39;, 0.0537), (&#39;9&#39;, 0.0477)]
</pre></div>
</div>
</div>
</div>
<p>Quod erat demonstrandum! The distribution is pretty much exactly as originally specified.  We now have a fuzzer where we can exercise control by specifying probabilities.</p>
</section>
<section id="directed-fuzzing">
<h2>Directed Fuzzing<a class="headerlink" href="#directed-fuzzing" title="Link to this heading">#</a></h2>
<p>Assigning probabilities to individual expansions gives us great control over which inputs should be generated.  By choosing probabilities wisely, we can <em>direct</em> fuzzing towards specific functions and features – for instance, towards functions that are particularly critical, prone to failures, or that have been recently changed.</p>
<p>As an example, consider the URL grammar from the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>.  Let us assume we have just made a change to our implementation of the secure FTP protocol.  By assigning a higher probability to the <code class="docutils literal notranslate"><span class="pre">ftps</span></code> scheme, we can generate more URLs that will specifically test this functionality.</p>
<p>First, let us define a helper function that sets a particular option:</p>
<p>Here’s a specialization just for probabilities:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_prob</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
             <span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">,</span> <span class="n">prob</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the probability of the given expansion of grammar[symbol]&quot;&quot;&quot;</span>
    <span class="n">set_opts</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">expansion</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="n">prob</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Let us use <code class="docutils literal notranslate"><span class="pre">set_prob()</span></code> to give the <code class="docutils literal notranslate"><span class="pre">ftps</span></code> expansion a probability of 80%:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">URL_GRAMMAR</span><span class="p">,</span> <span class="n">extend_grammar</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_url_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">URL_GRAMMAR</span><span class="p">)</span>
<span class="n">set_prob</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;scheme&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;ftps&quot;</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;scheme&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;http&#39;, &#39;https&#39;, &#39;ftp&#39;, (&#39;ftps&#39;, {&#39;prob&#39;: 0.8})]
</pre></div>
</div>
</div>
</div>
<p>If we use this grammar for fuzzing, we will get plenty of <code class="docutils literal notranslate"><span class="pre">ftps:</span></code> prefixes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prob_url_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prob_url_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ftps://cispa.saarland:80
ftps://user:password@cispa.saarland/
ftps://fuzzingbook.com/abc
ftps://fuzzingbook.com/x48
ftps://user:password@fuzzingbook.com/
ftps://www.google.com:2?x18=8
ftps://user:password@www.google.com:6
ftps://user:password@cispa.saarland/def
ftps://user:password@cispa.saarland/def?def=52
ftps://user:password@cispa.saarland/
</pre></div>
</div>
</div>
</div>
<p>In a similar vein, we can direct URL generation towards specific hosts or ports; we can favor URLs with queries, fragments, or logins – or URLs without these.  All it takes is to set appropriate probabilities.</p>
<p>By setting the probability of an expansion to zero, we can effectively disable specific expansions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">set_prob</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;scheme&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;ftps&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prob_url_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prob_url_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ftp://user:password@cispa.saarland/x00
https://user:password@www.google.com/?def=6&amp;def=x18&amp;def=def
https://user:password@fuzzingbook.com:7/?def=abc
https://user:password@www.google.com:8080/
ftp://www.google.com/?abc=36&amp;x34=5
http://user:password@cispa.saarland/
https://www.google.com/
https://user:password@www.google.com:85/?def=18
http://user:password@www.google.com:80/
http://fuzzingbook.com:80/?abc=def
</pre></div>
</div>
</div>
</div>
<p>Note that even if we set the probability of an expansion to zero, we may still see the expansion taken. This can happen during the “closing” phase of <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">our grammar fuzzer</span></a>, when the expansion is closed at minimum cost.  At this stage, even expansions with “zero” probability will be taken if this is necessary for closing the expansion.</p>
<p>Let us illustrate this feature using the <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> rule from our expression grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">probabilistic_expr_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;term&gt; + &lt;expr&gt;&#39;, &#39;&lt;term&gt; - &lt;expr&gt;&#39;, &#39;&lt;term&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>If we set the probability of the <code class="docutils literal notranslate"><span class="pre">&lt;term&gt;</span></code> expansion to zero, the string should expand again and again.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">set_prob</span><span class="p">(</span><span class="n">probabilistic_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">probabilistic_expr_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Still, in the “closing” phase, subexpressions will eventually expand into <code class="docutils literal notranslate"><span class="pre">&lt;term&gt;</span></code>, as it is the only way to close the expansion.  Tracking <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code> shows that it is invoked with only one possible expansion <code class="docutils literal notranslate"><span class="pre">&lt;term&gt;</span></code>, which has to be taken even though its specified probability is zero.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prob_expr_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">probabilistic_expr_grammar</span><span class="p">)</span>
<span class="n">prob_expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;44 / 7 / 1 * 3 / 6 - +1.63 + 3 * 7 + 1 - 2&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="probabilities-in-context">
<h2>Probabilities in Context<a class="headerlink" href="#probabilities-in-context" title="Link to this heading">#</a></h2>
<p>While specified probabilities give us a means to control which expansions are taken how often, this control by itself may not be enough.  As an example, consider the following grammar for IPv4 addresses:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decrange</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Expansion</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list with string representations of numbers in the range [start, end)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;&lt;start&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;address&gt;&quot;</span><span class="p">],</span>
    <span class="s2">&quot;&lt;address&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;octet&gt;.&lt;octet&gt;.&lt;octet&gt;.&lt;octet&gt;&quot;</span><span class="p">],</span>
    <span class="c1"># [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ..., &quot;255&quot;]</span>
    <span class="s2">&quot;&lt;octet&gt;&quot;</span><span class="p">:</span> <span class="n">decrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;octet&gt;&quot;</span><span class="p">][:</span><span class="mi">20</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;11&#39;, &#39;12&#39;, &#39;13&#39;, &#39;14&#39;, &#39;15&#39;, &#39;16&#39;, &#39;17&#39;, &#39;18&#39;, &#39;19&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can easily use this grammar to create IP addresses:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ip_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">)</span>
<span class="n">ip_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;34.155.77.136&#39;
</pre></div>
</div>
</div>
</div>
<p>However, if we want to assign a specific probability to one of the four octets, we are out of luck.  All we can do is to assign the same probability distribution for all four octets:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_address_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">)</span>
<span class="n">set_prob</span><span class="p">(</span><span class="n">probabilistic_ip_address_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;octet&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;127&quot;</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
    <span class="n">probabilistic_ip_address_grammar</span><span class="p">)</span>
<span class="n">probabilistic_ip_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;127.127.127.127&#39;
</pre></div>
</div>
</div>
</div>
<p>If we want to assign <em>different</em> probabilities to each of the four octets, what do we do?</p>
<p>The answer lies in the concept of <em>context</em>, which we already have seen <a class="reference internal" href="GrammarCoverageFuzzer.html"><span class="std std-doc">while discussing coverage-driven fuzzers</span></a>.  As with coverage-driven fuzzing, the idea is to <em>duplicate</em> the element whose probability we want to set dependent on its context.  In our case, this means to duplicate the <code class="docutils literal notranslate"><span class="pre">&lt;octet&gt;</span></code> element to four individual ones, each of which can then get an individual probability distribution.  We can do this programmatically, using the <code class="docutils literal notranslate"><span class="pre">duplicate_context()</span></code> method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GrammarCoverageFuzzer</span> <span class="kn">import</span> <span class="n">duplicate_context</span>  <span class="c1"># minor dependency</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_address_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">probabilistic_ip_address_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;address&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_address_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;address&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;octet-1&gt;.&lt;octet-2&gt;.&lt;octet-3&gt;.&lt;octet-4&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>We can now assign different probabilities to each of the <code class="docutils literal notranslate"><span class="pre">&lt;octet&gt;</span></code> symbols.  For instance, we can force specific expansions by setting their probability to 100%:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">set_prob</span><span class="p">(</span><span class="n">probabilistic_ip_address_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;octet-1&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;127&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">set_prob</span><span class="p">(</span><span class="n">probabilistic_ip_address_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;octet-2&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">probabilistic_ip_address_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The remaining two octets <code class="docutils literal notranslate"><span class="pre">&lt;octet-3&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;octet-4&gt;</span></code> have no specific probabilities set.  During fuzzing, all their expansions (all octets) are thus still available:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
    <span class="n">probabilistic_ip_address_grammar</span><span class="p">)</span>
<span class="p">[</span><span class="n">probabilistic_ip_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;127.0.201.77&#39;,
 &#39;127.0.98.36&#39;,
 &#39;127.0.12.232&#39;,
 &#39;127.0.146.161&#39;,
 &#39;127.0.245.151&#39;]
</pre></div>
</div>
</div>
</div>
<p>Just as with coverage, we can duplicate grammar rules arbitrarily often to get more and more finer-grained control over probabilities.  However, this finer-grained control also comes at the cost of having to maintain these probabilities.  In the next section, we will therefore discuss means to assign and tune such probabilities automatically.</p>
</section>
<section id="learning-probabilities-from-samples">
<h2>Learning Probabilities from Samples<a class="headerlink" href="#learning-probabilities-from-samples" title="Link to this heading">#</a></h2>
<p>Probabilities need not be set manually all the time.  They can also be <em>learned</em> from other sources, notably by counting <em>how frequently individual expansions occur in a given set of inputs</em>.  This is useful in a number of situations, including:</p>
<ol class="arabic simple">
<li><p>Test <em>common</em> features.  The idea is that during testing, one may want to focus on frequently occurring (or frequently used) features first, to ensure correct functionality for the most common usages.</p></li>
<li><p>Test <em>uncommon</em> features.  Here, the idea is to have test generation focus on features that are rarely seen (or not seen at all) in inputs.  This is the same motivation as with <a class="reference internal" href="GrammarCoverageFuzzer.html"><span class="std std-doc">grammar coverage</span></a>, but from a probabilistic standpoint.</p></li>
<li><p>Focus on specific <em>slices</em>.  One may have a set of inputs that is of particular interest (for instance, because they exercise a critical functionality, or recently have discovered bugs).  Using this learned distribution for fuzzing allows us to <em>focus</em> on precisely these functionalities of interest.</p></li>
</ol>
<p>Let us first introduce counting expansions and learning probabilities, and then detail these scenarios.</p>
<section id="counting-expansions">
<h3>Counting Expansions<a class="headerlink" href="#counting-expansions" title="Link to this heading">#</a></h3>
<p>We start with implementing a means to take a set of inputs and determine the number of expansions in that set.  To this end, we need the <em>parsers</em> introduced <a class="reference internal" href="Parser.html"><span class="std std-doc">in the previous chapter</span></a> to transform a string input into a derivation tree.  For our IP address grammar, this is how this works:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Parser</span> <span class="kn">import</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">EarleyParser</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">IP_ADDRESS_TOKENS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&lt;octet&gt;&quot;</span><span class="p">}</span>  <span class="c1"># EarleyParser needs explicit tokens</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/7740ed02c36ecefef1ac9dd20c52be2595d5f26dc716f7a4057c738044f562ef.svg" src="_images/7740ed02c36ecefef1ac9dd20c52be2595d5f26dc716f7a4057c738044f562ef.svg" />
</div>
</div>
<p>In a tree such as this one, we can now <em>count</em> individual expansions.  In the above tree, for instance, we have two expansions of <code class="docutils literal notranslate"><span class="pre">&lt;octet&gt;</span></code> into <code class="docutils literal notranslate"><span class="pre">0</span></code>, one into <code class="docutils literal notranslate"><span class="pre">1</span></code>, and one into <code class="docutils literal notranslate"><span class="pre">127</span></code>.  The expansion <code class="docutils literal notranslate"><span class="pre">&lt;octet&gt;</span></code> into <code class="docutils literal notranslate"><span class="pre">0</span></code> makes up 50% of all expansions seen; the expansions into <code class="docutils literal notranslate"><span class="pre">127</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> make up 25% each, and the other ones 0%.  These are the probabilities we’d like to assign to our “learned” grammar.</p>
<p>We introduce a class <code class="docutils literal notranslate"><span class="pre">ExpansionCountMiner</span></code> which allows us to count how frequently individual expansions take place.  Its initialization method takes a parser (say, an <code class="docutils literal notranslate"><span class="pre">EarleyParser</span></code>) that would be initialized with the appropriate grammar.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">GrammarCoverageFuzzer</span> <span class="kn">import</span> <span class="n">expansion_key</span>  <span class="c1"># minor dependency</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">is_nonterminal</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpansionCountMiner</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">:</span> <span class="n">Parser</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">Parser</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">grammar</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">expansion_counts</span></code> holds the expansions seen; adding a tree with <code class="docutils literal notranslate"><span class="pre">add_tree()</span></code> traverses the given tree and adds all expansions seen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpansionCountMiner</span><span class="p">(</span><span class="n">ExpansionCountMiner</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expansion_counts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion_counts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expansion_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expansion_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">add_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">assert</span> <span class="n">children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">direct_children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span> 
            <span class="k">else</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coverage</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">direct_children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">count_expansions()</span></code> is the one facing the public; it takes a list of inputs, parses them, and processes the resulting trees.  The method <code class="docutils literal notranslate"> <span class="pre">counts()</span></code> returns the counts found.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpansionCountMiner</span><span class="p">(</span><span class="n">ExpansionCountMiner</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">count_expansions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion_counts</span>
</pre></div>
</div>
</div>
</div>
<p>Let us try this out on our IP address grammar.  We create an <code class="docutils literal notranslate"><span class="pre">ExpansionCountMiner</span></code> for our IP address grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_count_miner</span> <span class="o">=</span> <span class="n">ExpansionCountMiner</span><span class="p">(</span><span class="n">EarleyParser</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We parse a (small) set of IP addresses and count the expansions occurring:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_count_miner</span><span class="o">.</span><span class="n">count_expansions</span><span class="p">([</span><span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="s2">&quot;1.2.3.4&quot;</span><span class="p">])</span>
<span class="n">expansion_count_miner</span><span class="o">.</span><span class="n">counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt; -&gt; &lt;address&gt;&#39;: 2,
 &#39;&lt;address&gt; -&gt; &lt;octet&gt;.&lt;octet&gt;.&lt;octet&gt;.&lt;octet&gt;&#39;: 2,
 &#39;&lt;octet&gt; -&gt; 127&#39;: 1,
 &#39;&lt;octet&gt; -&gt; 0&#39;: 2,
 &#39;&lt;octet&gt; -&gt; 1&#39;: 2,
 &#39;&lt;octet&gt; -&gt; 2&#39;: 1,
 &#39;&lt;octet&gt; -&gt; 3&#39;: 1,
 &#39;&lt;octet&gt; -&gt; 4&#39;: 1}
</pre></div>
</div>
</div>
</div>
<p>You see that we have one expansion into <code class="docutils literal notranslate"><span class="pre">127</span></code>, and two into <code class="docutils literal notranslate"><span class="pre">0</span></code>.  These are the counts we can use to assign probabilities.</p>
</section>
<section id="assigning-probabilities">
<h3>Assigning Probabilities<a class="headerlink" href="#assigning-probabilities" title="Link to this heading">#</a></h3>
<p>The distribution of counts, as determined by <code class="docutils literal notranslate"><span class="pre">ExpansionCountMiner</span></code> is what we can use to assign probabilities to our grammar.  To this end, we introduce a subclass <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarMiner</span></code> whose method <code class="docutils literal notranslate"><span class="pre">set_expansion_probabilities()</span></code> processes all expansions of a given symbol, checks whether it occurs in a given count distribution, and assigns probabilities using the following formula.</p>
<p>Given a set <span class="math notranslate nohighlight">\(T\)</span> of derivation trees (as mined from samples), we determine the probabilities <span class="math notranslate nohighlight">\(p_i\)</span> for each alternative <span class="math notranslate nohighlight">\(a_i\)</span> of a symbol <span class="math notranslate nohighlight">\(S \rightarrow a_1 | \dots | a_n\)</span> as</p>
<div class="math notranslate nohighlight">
\[p_i = \frac{\text{Expansions of $S \rightarrow a_i$ in $T$}}{\text{Expansions of $S$ in $T$}}\]</div>
<p>Should <span class="math notranslate nohighlight">\(S\)</span> not occur at all in <span class="math notranslate nohighlight">\(T\)</span>, then <span class="math notranslate nohighlight">\(p_i\)</span> is <em>unspecified</em>.</p>
<p>Here is the implementation of <code class="docutils literal notranslate"><span class="pre">set_expansion_probabilities()</span></code>, implementing the above formula:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProbabilisticGrammarMiner</span><span class="p">(</span><span class="n">ExpansionCountMiner</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_expansion_probabilities</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_expansion_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">counts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="n">expansions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expansions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">set_prob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">expansions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">expansion_counts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">expansion_key</span><span class="p">(</span>
                    <span class="n">symbol</span><span class="p">,</span>
                    <span class="n">expansion</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">expansions</span><span class="p">]</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">expansion_counts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expansions</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">expansion_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">total</span> <span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="c1"># if self.log:</span>
            <span class="c1">#     print(&quot;Setting&quot;, expansion_key(symbol, expansion), p)</span>
            <span class="n">set_prob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">expansion</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The typical use of <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarMiner</span></code> is through <code class="docutils literal notranslate"><span class="pre">mine_probabilistic_grammar()</span></code>, which first determines a distribution from a set of inputs, and then sets the probabilities accordingly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProbabilisticGrammarMiner</span><span class="p">(</span><span class="n">ProbabilisticGrammarMiner</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">mine_probabilistic_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_expansions</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span>
</pre></div>
</div>
</div>
</div>
<p>Let us put this to use.  We create a grammar miner for IP addresses:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_grammar_miner</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarMiner</span><span class="p">(</span>
    <span class="n">EarleyParser</span><span class="p">(</span><span class="n">IP_ADDRESS_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We now use <code class="docutils literal notranslate"><span class="pre">mine_probabilistic_grammar()</span></code> to mine the grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_address_grammar</span> <span class="o">=</span> <span class="n">probabilistic_grammar_miner</span><span class="o">.</span><span class="n">mine_probabilistic_grammar</span><span class="p">([</span>
                                                                                          <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="s2">&quot;1.2.3.4&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">probabilistic_ip_address_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here’s the resulting distribution of octets in our grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">expansion</span> <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">probabilistic_ip_address_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;octet&gt;&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">exp_prob</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;0&#39;, {&#39;prob&#39;: 0.25}),
 (&#39;1&#39;, {&#39;prob&#39;: 0.25}),
 (&#39;2&#39;, {&#39;prob&#39;: 0.125}),
 (&#39;3&#39;, {&#39;prob&#39;: 0.125}),
 (&#39;4&#39;, {&#39;prob&#39;: 0.125}),
 (&#39;127&#39;, {&#39;prob&#39;: 0.125})]
</pre></div>
</div>
</div>
</div>
<p>If we use these probabilities for fuzzing, we will get the same distribution of octets as in our sample:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_ip_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
    <span class="n">probabilistic_ip_address_grammar</span><span class="p">)</span>
<span class="p">[</span><span class="n">probabilistic_ip_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;4.2.2.0&#39;,
 &#39;2.1.4.0&#39;,
 &#39;0.1.3.127&#39;,
 &#39;0.3.0.127&#39;,
 &#39;4.0.2.1&#39;,
 &#39;3.127.0.0&#39;,
 &#39;2.2.1.1&#39;,
 &#39;4.0.1.0&#39;,
 &#39;2.4.0.1&#39;,
 &#39;0.0.3.127&#39;]
</pre></div>
</div>
</div>
</div>
<p>By learning from a sample, we can thus adjust our fuzzing towards the (syntactic) properties of this very sample.</p>
</section>
<section id="testing-common-features">
<h3>Testing Common Features<a class="headerlink" href="#testing-common-features" title="Link to this heading">#</a></h3>
<p>Let us now get to our three usage scenarios.  The first scenario is to create probability distributions right out of a sample, and to use these very distributions during test generation.  This helps to focus test generation on those features that are <em>most commonly used</em>, which thus minimizes the risk of customers encountering failures.</p>
<p>To illustrate testing of common features, we choose the URL domain.  Let us assume that we are running some Web-related service, and this is a sample of the URLs our customers access most:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">URL_SAMPLE</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;https://user:password@cispa.saarland:80/&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://fuzzingbook.com?def=56&amp;x89=3&amp;x46=48&amp;def=def&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://cispa.saarland:80/def?def=7&amp;x23=abc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://fuzzingbook.com:80/&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://fuzzingbook.com:80/abc?def=abc&amp;abc=x14&amp;def=abc&amp;abc=2&amp;def=38&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ftps://fuzzingbook.com/x87&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://user:password@fuzzingbook.com:6?def=54&amp;x44=abc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;http://fuzzingbook.com:80?x33=25&amp;def=8&quot;</span><span class="p">,</span>
    <span class="s2">&quot;http://fuzzingbook.com:8080/def&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Using the Earley parser from the <a class="reference internal" href="Parser.html"><span class="std std-doc">chapter on parsers</span></a>, we can parse any of these inputs into a parse tree; we have to specify a token set, though.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">URL_TOKENS</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&lt;scheme&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;userinfo&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;host&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;port&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;id&gt;&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">url_parser</span> <span class="o">=</span> <span class="n">EarleyParser</span><span class="p">(</span><span class="n">URL_GRAMMAR</span><span class="p">,</span> <span class="n">tokens</span><span class="o">=</span><span class="n">URL_TOKENS</span><span class="p">)</span>
<span class="n">url_input</span> <span class="o">=</span> <span class="n">URL_SAMPLE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">url_input</span><span class="p">)</span>
<span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">url_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">url_input</span><span class="p">)</span>
<span class="n">display_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>https://cispa.saarland:80/def?def=7&amp;x23=abc
</pre></div>
</div>
<img alt="_images/98218acc7828047b497792d7e5ffc098bf433c7366d2b51694e574d1d5be4907.svg" src="_images/98218acc7828047b497792d7e5ffc098bf433c7366d2b51694e574d1d5be4907.svg" />
</div>
</div>
<p>Let us apply our <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarMiner</span></code> class on these inputs, using the above <code class="docutils literal notranslate"><span class="pre">url_parser</span></code> parser, and obtain a probabilistic URL grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_grammar_miner</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarMiner</span><span class="p">(</span><span class="n">url_parser</span><span class="p">)</span>
<span class="n">probabilistic_url_grammar</span> <span class="o">=</span> <span class="n">probabilistic_grammar_miner</span><span class="o">.</span><span class="n">mine_probabilistic_grammar</span><span class="p">(</span>
    <span class="n">URL_SAMPLE</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>These are the counts we obtained during parsing:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">probabilistic_grammar_miner</span><span class="o">.</span><span class="n">counts</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt; -&gt; &lt;url&gt;&#39;: 9, &#39;&lt;url&gt; -&gt; &lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;&lt;query&gt;&#39;: 9, &#39;&lt;scheme&gt; -&gt; https&#39;: 6, &#39;&lt;authority&gt; -&gt; &lt;userinfo&gt;@&lt;host&gt;:&lt;port&gt;&#39;: 2, &#39;&lt;userinfo&gt; -&gt; user:password&#39;: 2, &#39;&lt;host&gt; -&gt; cispa.saarland&#39;: 2, &#39;&lt;port&gt; -&gt; 80&#39;: 5, &#39;&lt;path&gt; -&gt; /&#39;: 2, &#39;&lt;query&gt; -&gt; &lt;query&gt;&#39;: 4, &#39;&lt;authority&gt; -&gt; &lt;host&gt;&#39;: 2, &#39;&lt;host&gt; -&gt; fuzzingbook.com&#39;: 7, &#39;&lt;path&gt; -&gt; &lt;path&gt;&#39;: 3, &#39;&lt;query&gt; -&gt; ?&lt;params&gt;&#39;: 5, &#39;&lt;params&gt; -&gt; &lt;param&gt;&amp;&lt;params&gt;&#39;: 10, &#39;&lt;param&gt; -&gt; &lt;id&gt;=&lt;nat&gt;&#39;: 9, &#39;&lt;id&gt; -&gt; def&#39;: 11, &#39;&lt;nat&gt; -&gt; &lt;digit&gt;&lt;digit&gt;&#39;: 5, &#39;&lt;digit&gt; -&gt; 5&#39;: 3, &#39;&lt;digit&gt; -&gt; 6&#39;: 1, &#39;&lt;id&gt; -&gt; x89&#39;: 1, &#39;&lt;nat&gt; -&gt; &lt;digit&gt;&#39;: 4, &#39;&lt;digit&gt; -&gt; 3&#39;: 2, &#39;&lt;id&gt; -&gt; x46&#39;: 1, &#39;&lt;digit&gt; -&gt; 4&#39;: 2, &#39;&lt;digit&gt; -&gt; 8&#39;: 3, &#39;&lt;params&gt; -&gt; &lt;param&gt;&#39;: 5, &#39;&lt;param&gt; -&gt; &lt;id&gt;=&lt;id&gt;&#39;: 6, &#39;&lt;authority&gt; -&gt; &lt;host&gt;:&lt;port&gt;&#39;: 5, &#39;&lt;path&gt; -&gt; /&lt;id&gt;&#39;: 4, &#39;&lt;digit&gt; -&gt; 7&#39;: 1, &#39;&lt;id&gt; -&gt; x23&#39;: 1, &#39;&lt;id&gt; -&gt; abc&#39;: 7, &#39;&lt;id&gt; -&gt; x14&#39;: 1, &#39;&lt;digit&gt; -&gt; 2&#39;: 2, &#39;&lt;scheme&gt; -&gt; ftps&#39;: 1, &#39;&lt;id&gt; -&gt; x87&#39;: 1, &#39;&lt;port&gt; -&gt; 6&#39;: 1, &#39;&lt;id&gt; -&gt; x44&#39;: 1, &#39;&lt;scheme&gt; -&gt; http&#39;: 2, &#39;&lt;id&gt; -&gt; x33&#39;: 1, &#39;&lt;port&gt; -&gt; 8080&#39;: 1}
</pre></div>
</div>
</div>
</div>
<p>These counts translate into individual probabilities.  We see that in our sample, most URLs use the <code class="docutils literal notranslate"><span class="pre">https:</span></code> scheme, whereas there is no input using the <code class="docutils literal notranslate"><span class="pre">ftp:</span></code> scheme.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;scheme&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;http&#39;, {&#39;prob&#39;: 0.2222222222222222}),
 (&#39;https&#39;, {&#39;prob&#39;: 0.6666666666666666}),
 (&#39;ftp&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;ftps&#39;, {&#39;prob&#39;: 0.1111111111111111})]
</pre></div>
</div>
</div>
</div>
<p>Likewise, we see that most given URLs have multiple parameters:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;params&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;&lt;param&gt;&#39;, {&#39;prob&#39;: 0.3333333333333333}),
 (&#39;&lt;param&gt;&amp;&lt;params&gt;&#39;, {&#39;prob&#39;: 0.6666666666666666})]
</pre></div>
</div>
</div>
</div>
<p>When we use this probabilistic grammar for fuzzing, these distributions are reflected in our generated inputs – no <code class="docutils literal notranslate"><span class="pre">ftp:</span></code> schemes either, and most inputs have multiple parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">)</span>
<span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;https://fuzzingbook.com/def?def=abc&amp;def=abc&amp;def=def&amp;def=abc&amp;abc=def&amp;def=def&amp;abc=def&#39;,
 &#39;http://fuzzingbook.com:80/def?def=7&amp;def=abc&amp;abc=88&#39;,
 &#39;https://cispa.saarland/def?def=2&#39;,
 &#39;http://user:password@fuzzingbook.com:80/def?abc=abc&amp;def=78&#39;,
 &#39;http://cispa.saarland:80/?def=54&amp;def=abc&#39;,
 &#39;https://fuzzingbook.com:80/def?def=def&#39;,
 &#39;http://fuzzingbook.com:80/abc?abc=abc&amp;abc=def&amp;def=85&amp;abc=7&amp;def=6&amp;abc=2&amp;def=abc&#39;,
 &#39;https://fuzzingbook.com/abc?def=32&amp;def=3&amp;abc=4&#39;,
 &#39;http://fuzzingbook.com/def?abc=24&amp;def=def&amp;def=48&#39;,
 &#39;https://cispa.saarland:80/?abc=abc&#39;]
</pre></div>
</div>
</div>
</div>
<p>Being able to replicate a probability distribution learned from a sample is not only important for focusing on commonly used features.  It can also help in achieving <em>valid inputs</em>, in particular if one learns probabilities <em>in context</em>, as discussed above: If within a given context, some elements are more likely than others (because they depend on each other), a learned probability distribution will reflect this; and hence, inputs generated from this learned probability distribution will have a higher chance to be valid, too.  We will explore this further in the <a class="reference internal" href="#Exercises"><span class="xref myst">exercises</span></a>, below.</p>
</section>
<section id="testing-uncommon-features">
<h3>Testing Uncommon Features<a class="headerlink" href="#testing-uncommon-features" title="Link to this heading">#</a></h3>
<p>So far, we have focused on <em>common</em> features; but from a testing perspective, one may just as well test <em>uncommon</em> features – that is, features that rarely occur in our usage samples and therefore would be less exercised in practice.  This is a common scenario in security testing, where one focuses on uncommon (and possibly lesser-known) features, as fewer users means fewer bugs reported, and thus more bugs left to be found and exploited.</p>
<p>To have our probabilistic grammar fuzzer focus on <em>uncommon</em> features, we <em>change the learned probabilities</em> such that commonly occurring features (i.e., those with a high learned probability) get a low probability, and vice versa: The last shall be first, and the first last.  A particularly simple way to achieve such an <em>inversion</em> of probabilities is to <em>swap</em> them: The alternatives with the highest and lowest probability swaps their probabilities, as so the alternatives with the second-highest and second-lowest probability, the alternatives with the third highest and lowest, and so on.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">invert_expansion()</span></code> takes an expansion (a list of alternatives) from a grammar and returns a new inverted expansion in which the probabilities have been swapped according to the rule above.  It creates a list of indexes, sorts it by increasing probability, and then for each <span class="math notranslate nohighlight">\(n\)</span>-th element, assigns it the probability of the <span class="math notranslate nohighlight">\(n\)</span>-th last element in the indexes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">invert_expansion</span><span class="p">(</span><span class="n">expansion</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expansion</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Expansion</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">sort_by_prob</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">prob</span> <span class="k">if</span> <span class="n">prob</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="n">inverted_expansion</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expansion</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
    <span class="n">indexes_and_probs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span><span class="p">,</span> <span class="n">exp_prob</span><span class="p">(</span><span class="n">alternative</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expansion</span><span class="p">)]</span>
    <span class="n">indexes_and_probs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">sort_by_prob</span><span class="p">)</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">indexes_and_probs</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span>
        <span class="c1"># print(indexes[j], &quot;gets&quot;, indexes[k])</span>
        <span class="n">inverted_expansion</span><span class="p">[</span><span class="n">indexes</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;prob&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expansion</span><span class="p">[</span><span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;prob&#39;</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

    <span class="k">return</span> <span class="n">inverted_expansion</span>
</pre></div>
</div>
</div>
</div>
<p>Here’s <code class="docutils literal notranslate"><span class="pre">invert_expansion()</span></code> in action.  This is our original probability distribution for URL schemes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;scheme&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;http&#39;, {&#39;prob&#39;: 0.2222222222222222}),
 (&#39;https&#39;, {&#39;prob&#39;: 0.6666666666666666}),
 (&#39;ftp&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;ftps&#39;, {&#39;prob&#39;: 0.1111111111111111})]
</pre></div>
</div>
</div>
</div>
<p>And this is the “inverted” distribution.  We see that the <code class="docutils literal notranslate"><span class="pre">ftp:</span></code> scheme, which previously had a probability of zero, now has the highest probability, whereas the most common scheme, <code class="docutils literal notranslate"><span class="pre">https:</span></code>, now has the previous zero probability of the <code class="docutils literal notranslate"><span class="pre">ftp:</span></code> scheme.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">invert_expansion</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;scheme&gt;&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;http&#39;, {&#39;prob&#39;: 0.1111111111111111}),
 (&#39;https&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;ftp&#39;, {&#39;prob&#39;: 0.6666666666666666}),
 (&#39;ftps&#39;, {&#39;prob&#39;: 0.2222222222222222})]
</pre></div>
</div>
</div>
</div>
<p>One nice feature of this swapping of probabilities is that the sum of probabilities stays unchanged; no normalization is needed.  Another nice feature is that the inversion of the inversion returns the original distribution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">invert_expansion</span><span class="p">(</span><span class="n">invert_expansion</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;scheme&gt;&#39;</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;http&#39;, {&#39;prob&#39;: 0.2222222222222222}),
 (&#39;https&#39;, {&#39;prob&#39;: 0.6666666666666666}),
 (&#39;ftp&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;ftps&#39;, {&#39;prob&#39;: 0.1111111111111111})]
</pre></div>
</div>
</div>
</div>
<p>Note that our implementation does not universally satisfy this property: If two alternatives <span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span> in the expansion share the same probability, then the second inversion may assign different probabilities to <span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>.</p>
<p>We can apply this inversion of expansions across the entire grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">invert_probs</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
    <span class="n">inverted_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
        <span class="n">inverted_grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">invert_expansion</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">inverted_grammar</span>
</pre></div>
</div>
</div>
</div>
<p>This means that probabilities would be swapped for each and every expansion:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_url_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;0&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;1&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;2&#39;, {&#39;prob&#39;: 0.14285714285714285}),
 (&#39;3&#39;, {&#39;prob&#39;: 0.14285714285714285}),
 (&#39;4&#39;, {&#39;prob&#39;: 0.14285714285714285}),
 (&#39;5&#39;, {&#39;prob&#39;: 0.21428571428571427}),
 (&#39;6&#39;, {&#39;prob&#39;: 0.07142857142857142}),
 (&#39;7&#39;, {&#39;prob&#39;: 0.07142857142857142}),
 (&#39;8&#39;, {&#39;prob&#39;: 0.21428571428571427}),
 (&#39;9&#39;, {&#39;prob&#39;: 0.0})]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inverted_probabilistic_url_grammar</span> <span class="o">=</span> <span class="n">invert_probs</span><span class="p">(</span><span class="n">probabilistic_url_grammar</span><span class="p">)</span>
<span class="n">inverted_probabilistic_url_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;0&#39;, {&#39;prob&#39;: 0.21428571428571427}),
 (&#39;1&#39;, {&#39;prob&#39;: 0.21428571428571427}),
 (&#39;2&#39;, {&#39;prob&#39;: 0.07142857142857142}),
 (&#39;3&#39;, {&#39;prob&#39;: 0.07142857142857142}),
 (&#39;4&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;5&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;6&#39;, {&#39;prob&#39;: 0.14285714285714285}),
 (&#39;7&#39;, {&#39;prob&#39;: 0.14285714285714285}),
 (&#39;8&#39;, {&#39;prob&#39;: 0.0}),
 (&#39;9&#39;, {&#39;prob&#39;: 0.14285714285714285})]
</pre></div>
</div>
</div>
</div>
<p>If we now use this “inverted” grammar for fuzzing, the generated inputs will focus on the <em>complement of the input samples</em>.  We will get plenty of tests of user/password features, as well as <code class="docutils literal notranslate"><span class="pre">ftp:</span></code> schemes – in essence, all the features present in our language, but rarely used (if at all) in our input samples.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">inverted_probabilistic_url_grammar</span><span class="p">)</span>
<span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;ftp://www.google.com&#39;,
 &#39;ftp://www.google.com/&#39;,
 &#39;ftp://www.google.com/&#39;,
 &#39;ftp://user:password@cispa.saarland&#39;,
 &#39;ftps://www.google.com/&#39;,
 &#39;ftp://user:password@www.google.com/&#39;,
 &#39;ftp://user:password@www.google.com&#39;,
 &#39;ftp://www.google.com/&#39;,
 &#39;ftp://user:password@www.google.com&#39;,
 &#39;ftp://user:password@www.google.com/&#39;]
</pre></div>
</div>
</div>
</div>
<p>Besides having <em>only</em> common or <em>only</em> uncommon features, one can also create mixed forms – for instance, testing uncommon features in a common context.  This can be helpful for security testing, where one may want an innocuous (common) “envelope” combined with an (uncommon) “payload”.  It all depends on where and how we tune the probabilities.</p>
</section>
<section id="learning-probabilities-from-input-slices">
<h3>Learning Probabilities from Input Slices<a class="headerlink" href="#learning-probabilities-from-input-slices" title="Link to this heading">#</a></h3>
<p>In our previous examples, we have learned from <em>all</em> inputs to generate common or uncommon inputs.  However, we can also learn from a <em>subset</em> of inputs to focus on the features present in that subset (or, conversely, to <em>avoid</em> its features).  If we know, for instance, that there is some subset of inputs that covers a functionality of interest (say, because it is particularly critical or because it has been recently changed), we can learn from this very subset and focus our test generation on its features.</p>
<p>To illustrate this approach, let us use the CGI grammar introduced in the <a class="reference internal" href="Coverage.html"><span class="std std-doc">chapter on coverage</span></a>.  We have a special interest in Line 25 in our CGI decoder – that is, the line that processes a <code class="docutils literal notranslate"><span class="pre">%</span></code> character followed by two valid hexadecimal digits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>        <span class="o">...</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;%&#39;</span><span class="p">:</span>
            <span class="n">digit_high</span><span class="p">,</span> <span class="n">digit_low</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">digit_high</span> <span class="ow">in</span> <span class="n">hex_values</span> <span class="ow">and</span> <span class="n">digit_low</span> <span class="ow">in</span> <span class="n">hex_values</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">hex_values</span><span class="p">[</span><span class="n">digit_high</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">hex_values</span><span class="p">[</span><span class="n">digit_low</span><span class="p">]</span> <span class="c1">### Line 25</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="o">...</span>

</pre></div>
</div>
<p>Let us assume that we do not know precisely under which conditions Line 25 is executed – but still, we’d like to test it thoroughly.  With our probability learning tools, we can learn these conditions, though.  We start with a set of random inputs and consider the subset that covers Line 25.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Coverage</span> <span class="kn">import</span> <span class="n">Coverage</span><span class="p">,</span> <span class="n">cgi_decode</span>
<span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">CGI_GRAMMAR</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cgi_fuzzer</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">coverage</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">cgi_input</span> <span class="o">=</span> <span class="n">cgi_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
        <span class="n">cgi_decode</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">)</span>
    <span class="n">coverage</span><span class="p">[</span><span class="n">cgi_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>These are all the random inputs that cover Line 25:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coverage_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">cgi_input</span> <span class="k">for</span> <span class="n">cgi_input</span> <span class="ow">in</span> <span class="n">coverage</span>
                  <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;cgi_decode&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coverage</span><span class="p">[</span><span class="n">cgi_input</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">coverage_slice</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;%36%c1%d2c2%4f++e&#39;, &#39;%2c%90+&#39;, &#39;c++%8b&#39;, &#39;a+%95&#39;, &#39;%76%00&#39;, &#39;+5&#39;, &#39;4&#39;, &#39;+&#39;, &#39;a&#39;, &#39;%71&#39;, &#39;%a2&#39;, &#39;%39%51%db%7c%66&#39;, &#39;++&#39;, &#39;%2a&#39;, &#39;d&#39;, &#39;%b9225&#39;, &#39;++c&#39;, &#39;%13+b&#39;, &#39;%32&#39;, &#39;2&#39;, &#39;+2+&#39;, &#39;-1%b11%d8&#39;, &#39;%08&#39;, &#39;d+4&#39;, &#39;%a3&#39;, &#39;%fe&#39;, &#39;e&#39;, &#39;1++&#39;, &#39;+%82%ed%42&#39;, &#39;%d5&#39;, &#39;%5bc&#39;, &#39;51&#39;, &#39;%b0&#39;, &#39;%47&#39;, &#39;b+%20&#39;, &#39;%d7&#39;, &#39;0+%17&#39;, &#39;%a5&#39;, &#39;%84&#39;, &#39;e+4%fc&#39;, &#39;d%6f+++1a&#39;, &#39;3&#39;, &#39;d+%95+&#39;, &#39;%1e&#39;, &#39;%244&#39;, &#39;%3c&#39;, &#39;5%75+%99%3c&#39;, &#39;+-&#39;, &#39;b&#39;, &#39;%80%74+a&#39;, &#39;%a7&#39;, &#39;21&#39;, &#39;ae&#39;, &#39;%c1%da&#39;, &#39;%c5+&#39;, &#39;b%44&#39;, &#39;%70%c4_3&#39;, &#39;1&#39;, &#39;dd+ad&#39;, &#39;4%63&#39;, &#39;%364+&#39;, &#39;%79%ab&#39;, &#39;%8a%f6&#39;, &#39;%53%43&#39;, &#39;+++%55+b5&#39;, &#39;%51+++&#39;, &#39;+%28&#39;, &#39;1%1c+&#39;, &#39;+%41%9b&#39;, &#39;%0d%20&#39;, &#39;+%3d+%c2&#39;]
</pre></div>
</div>
</div>
</div>
<p>Actually, about half of the inputs cover Line 25:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">coverage_slice</span><span class="p">)</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.71
</pre></div>
</div>
</div>
</div>
<p>Let us now learn a probabilistic grammar from this slice of inputs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_grammar_miner</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarMiner</span><span class="p">(</span>
    <span class="n">EarleyParser</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
<span class="n">probabilistic_cgi_grammar</span> <span class="o">=</span> <span class="n">probabilistic_grammar_miner</span><span class="o">.</span><span class="n">mine_probabilistic_grammar</span><span class="p">(</span>
    <span class="n">coverage_slice</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_probabilistic_grammar</span><span class="p">(</span><span class="n">probabilistic_cgi_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We see that percentage signs are very likely to occur:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_cgi_grammar</span><span class="p">[</span><span class="s1">&#39;&lt;letter&gt;&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;&lt;plus&gt;&#39;, {&#39;prob&#39;: 0.2556818181818182}),
 (&#39;&lt;percent&gt;&#39;, {&#39;prob&#39;: 0.42045454545454547}),
 (&#39;&lt;other&gt;&#39;, {&#39;prob&#39;: 0.32386363636363635})]
</pre></div>
</div>
</div>
</div>
<p>Using this grammar, we can now generate tests that specifically target Line 25:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_cgi_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
    <span class="n">probabilistic_cgi_grammar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">probabilistic_cgi_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;5&#39;, &#39;%3e&#39;, &#39;+4%e6&#39;, &#39;%19+&#39;, &#39;%da+&#39;, &#39;%5c&#39;, &#39;%28%5e&#39;, &#39;%b5+&#39;, &#39;2d4&#39;, &#39;455%8c&#39;, &#39;5%cb&#39;, &#39;%4c+%5c4e5+e+%aa%db%1d&#39;, &#39;a%1c%13&#39;, &#39;e+&#39;, &#39;%08%cc&#39;, &#39;b3&#39;, &#39;3&#39;, &#39;%c0%25&#39;, &#39;+&#39;, &#39;++c+%54d&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">coverage</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">cgi_input</span> <span class="o">=</span> <span class="n">probabilistic_cgi_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
        <span class="n">cgi_decode</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">)</span>
    <span class="n">coverage</span><span class="p">[</span><span class="n">cgi_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We see that the fraction of inputs that cover Line 25 is much higher already, showing that our focusing works:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coverage_slice</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cgi_input</span> <span class="k">for</span> <span class="n">cgi_input</span> <span class="ow">in</span> <span class="n">coverage</span>
                             <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;cgi_decode&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coverage</span><span class="p">[</span><span class="n">cgi_input</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">coverage_slice</span><span class="p">)</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.88
</pre></div>
</div>
</div>
</div>
<p>Repeating this one more time yields an even higher focusing:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">probabilistic_cgi_grammar</span> <span class="o">=</span> <span class="n">probabilistic_grammar_miner</span><span class="o">.</span><span class="n">mine_probabilistic_grammar</span><span class="p">(</span>
        <span class="n">coverage_slice</span><span class="p">)</span>
    <span class="n">probabilistic_cgi_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span>
        <span class="n">probabilistic_cgi_grammar</span><span class="p">)</span>

    <span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">coverage</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
        <span class="n">cgi_input</span> <span class="o">=</span> <span class="n">probabilistic_cgi_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
            <span class="n">cgi_decode</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">)</span>
        <span class="n">coverage</span><span class="p">[</span><span class="n">cgi_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>

    <span class="n">coverage_slice</span> <span class="o">=</span> <span class="p">[</span><span class="n">cgi_input</span> <span class="k">for</span> <span class="n">cgi_input</span> <span class="ow">in</span> <span class="n">coverage</span>
                      <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;cgi_decode&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coverage</span><span class="p">[</span><span class="n">cgi_input</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">coverage_slice</span><span class="p">)</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.83
</pre></div>
</div>
</div>
</div>
<p>By learning (and re-learning) probabilities from a subset of sample inputs, we can <em>specialize</em> fuzzers towards the properties of that subset – in our case, inputs that contain percentage signs and valid hexadecimal letters.  The degree to which we can specialize things is induced by the number of variables we can control – in our case, the probabilities for the individual rules.  Adding more context to the grammar, as discussed above, will increase the number of variables, and thus the amount of specialization.</p>
<p>A high degree of specialization, however, limits our possibilities to explore combinations that fall <em>outside</em> the selected scope, and limit our possibilities to find bugs induced by these combinations.  This trade-off is known as <em>exploration vs. exploitation</em> in machine learning – shall one try to explore as many (possibly shallow) combinations as possible, or focus (exploit) specific areas?  In the end, it all depends on where the bugs are, and where we are most likely to find them.  Assigning and learning probabilities allows us to control the search strategies – from the common to the uncommon to specific subsets.</p>
</section>
</section>
<section id="detecting-unnatural-numbers">
<h2>Detecting Unnatural Numbers<a class="headerlink" href="#detecting-unnatural-numbers" title="Link to this heading">#</a></h2>
<p>Let us close this chapter by getting back to our introductory example.  We said that Benford’s law allows us not only to produce, but also to detect “unnatural” lead digit distributions such as the ones produced by simple random choices.</p>
<p>If we use the regular <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code> class (which ignores probabilities) to generate (random) lead digits, this is the distribution we get for each leading digit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sample_size</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">random_integer_fuzzer</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span>
    <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">,</span>
    <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">)</span>
<span class="n">random_integers</span> <span class="o">=</span> <span class="p">[</span><span class="n">random_integer_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample_size</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random_counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">random_integers</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">crange</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">)]</span>
<span class="n">random_counts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[112, 104, 106, 103, 133, 97, 126, 120, 99]
</pre></div>
</div>
</div>
</div>
<p>(For simplicity, we use the simple list <code class="docutils literal notranslate"><span class="pre">count()</span></code> method here rather than deploying the full-fledged <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarMiner</span></code>.)</p>
<p>If we had a natural distribution of lead digits, this is what we would expect:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expected_prob_counts</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">exp_prob</span><span class="p">(</span>
        <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span>
    <span class="n">sample_size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">expected_prob_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[301.0, 176.0, 125.0, 97.0, 79.0, 67.0, 58.0, 51.0, 46.0]
</pre></div>
</div>
</div>
</div>
<p>And if we had a random distribution, we would expect an equal distribution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expected_random_counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_size</span> <span class="o">/</span> <span class="mi">9</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">expected_random_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[111.11111111111111, 111.11111111111111, 111.11111111111111, 111.11111111111111, 111.11111111111111, 111.11111111111111, 111.11111111111111, 111.11111111111111, 111.11111111111111]
</pre></div>
</div>
</div>
</div>
<p>Which distribution better matches our <code class="docutils literal notranslate"><span class="pre">random_counts</span></code> lead digits?  To this end, we run a <span class="math notranslate nohighlight">\(\chi^2\)</span>-test to compare the distribution we found (<code class="docutils literal notranslate"><span class="pre">random_counts</span></code>) against the “natural” lead digit distribution <code class="docutils literal notranslate"><span class="pre">expected_prob_counts</span></code> and the random distribution <code class="docutils literal notranslate"><span class="pre">expected_random_counts</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">chisquare</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<p>It turns out that there is a zero chance (<code class="docutils literal notranslate"><span class="pre">pvalue</span></code> = 0.0) that the observed distribution follows a “natural” distribution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">chisquare</span><span class="p">(</span><span class="n">random_counts</span><span class="p">,</span> <span class="n">expected_prob_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Power_divergenceResult(statistic=np.float64(435.87462280458345), pvalue=np.float64(3.925216460200427e-89))
</pre></div>
</div>
</div>
</div>
<p>However, there is a 97% chance that the observed behavior follows a random distribution:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">chisquare</span><span class="p">(</span><span class="n">random_counts</span><span class="p">,</span> <span class="n">expected_random_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Power_divergenceResult(statistic=np.float64(11.42), pvalue=np.float64(0.17901776899017763))
</pre></div>
</div>
</div>
</div>
<p>Hence, if you find some numbers published and doubt their validity, you can run the above test to check whether they are likely to be natural.  Better yet, insist that authors use Jupyter notebooks to produce their results, such that you can check every step of the calculation :-)</p>
</section>
<section id="id1">
<h2>Synopsis<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<p>A <em>probabilistic</em> grammar allows attaching individual <em>probabilities</em> to production rules.  To set the probability of an individual expansion <code class="docutils literal notranslate"><span class="pre">S</span></code> to the value <code class="docutils literal notranslate"><span class="pre">X</span></code> (between 0 and 1), replace it with a pair</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="n">X</span><span class="p">))</span>
</pre></div>
</div>
<p>If we want to ensure that 90% of phone numbers generated have an area code starting with <code class="docutils literal notranslate"><span class="pre">9</span></code>, we can write:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">US_PHONE_GRAMMAR</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">opts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PROBABILISTIC_US_PHONE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">,</span>
<span class="p">{</span>
      <span class="s2">&quot;&lt;lead-digit&gt;&quot;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span>
                          <span class="p">(</span><span class="s2">&quot;9&quot;</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.9</span><span class="p">))</span>
                      <span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarFuzzer</span></code> will extract and interpret these options.  Here is an example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">probabilistic_us_phone_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">(</span><span class="n">PROBABILISTIC_US_PHONE_GRAMMAR</span><span class="p">)</span>
<span class="p">[</span><span class="n">probabilistic_us_phone_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;(918)925-2501&#39;,
 &#39;(981)925-0792&#39;,
 &#39;(934)995-5029&#39;,
 &#39;(955)999-7801&#39;,
 &#39;(964)927-0877&#39;]
</pre></div>
</div>
</div>
</div>
<p>As you can see, the large majority of area codes now starts with <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">from</span> <span class="nn">ClassDiagram</span> <span class="kn">import</span> <span class="n">display_class_hierarchy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">display_class_hierarchy</span><span class="p">([</span><span class="n">ProbabilisticGrammarFuzzer</span><span class="p">],</span>
                        <span class="n">public_methods</span><span class="o">=</span><span class="p">[</span>
                            <span class="n">Fuzzer</span><span class="o">.</span><span class="n">run</span><span class="p">,</span>
                            <span class="n">Fuzzer</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span>
                            <span class="n">GrammarFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span>
                            <span class="n">GrammarFuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">,</span>
                            <span class="n">GrammarFuzzer</span><span class="o">.</span><span class="n">fuzz_tree</span><span class="p">,</span>
                            <span class="n">ProbabilisticGrammarFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span>
                        <span class="p">],</span>
                        <span class="n">types</span><span class="o">=</span><span class="p">{</span>
                            <span class="s1">&#39;DerivationTree&#39;</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                            <span class="s1">&#39;Expansion&#39;</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">,</span>
                            <span class="s1">&#39;Grammar&#39;</span><span class="p">:</span> <span class="n">Grammar</span>
                        <span class="p">},</span>
                        <span class="n">project</span><span class="o">=</span><span class="s1">&#39;fuzzingbook&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="336pt" height="287pt"
 viewBox="0.00 0.00 336.38 287.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 283)">
<g id="a_graph0"><a xlink:title="ProbabilisticGrammarFuzzer class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-283 332.38,-283 332.38,4 -4,4"/>
</a>
</g>
<!-- ProbabilisticGrammarFuzzer -->
<g id="node1" class="node">
<title>ProbabilisticGrammarFuzzer</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class ProbabilisticGrammarFuzzer:&#10;A grammar&#45;based fuzzer respecting probabilities in grammars.">
<polygon fill="none" stroke="black" points="0,-0.5 0,-72.75 191.5,-72.75 191.5,-0.5 0,-0.5"/>
<text text-anchor="start" x="8" y="-56.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProbabilisticGrammarFuzzer</text>
<polyline fill="none" stroke="black" points="0,-46.75 191.5,-46.75"/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="ProbabilisticGrammarFuzzer">
<g id="a_node1_1"><a xlink:href="#" xlink:title="check_grammar(self) &#45;&gt; None:&#10;Check the grammar passed">
<text text-anchor="start" x="26.75" y="-34.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">check_grammar()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[Any]) &#45;&gt; int:&#10;Return index of expansion in `children_alternatives` to be selected.&#10;&#39;children_alternatives`: a list of possible children for `node`.&#10;Defaults to random. To be overloaded in subclasses.">
<text text-anchor="start" x="26.75" y="-21.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
<g id="a_node1_3"><a xlink:href="#" xlink:title="supported_opts(self) &#45;&gt; Set[str]:&#10;Set of supported options. To be overloaded in subclasses.">
<text text-anchor="start" x="26.75" y="-8.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">supported_opts()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarFuzzer -->
<g id="node2" class="node">
<title>GrammarFuzzer</title>
<g id="a_node2"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="class GrammarFuzzer:&#10;Produce strings from grammars efficiently, using derivation trees.">
<polygon fill="none" stroke="black" points="37.88,-109.75 37.88,-182 153.62,-182 153.62,-109.75 37.88,-109.75"/>
<text text-anchor="start" x="45.88" y="-165.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarFuzzer</text>
<polyline fill="none" stroke="black" points="37.88,-156 153.62,-156"/>
<g id="a_node2_4"><a xlink:href="#" xlink:title="GrammarFuzzer">
<g id="a_node2_5"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol: str = &#39;&lt;start&gt;&#39;, min_nonterminals: int = 0, max_nonterminals: int = 10, disp: bool = False, log: Union[bool, int] = False) &#45;&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="62.75" y="-143.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node2_6"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="fuzz(self) &#45;&gt; str:&#10;Produce a string from the grammar.">
<text text-anchor="start" x="62.75" y="-130.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz()</text>
</a>
</g>
<g id="a_node2_7"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="fuzz_tree(self) &#45;&gt; DerivationTree:&#10;Produce a derivation tree from the grammar.">
<text text-anchor="start" x="62.75" y="-118" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">fuzz_tree()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- ProbabilisticGrammarFuzzer&#45;&gt;GrammarFuzzer -->
<g id="edge1" class="edge">
<title>ProbabilisticGrammarFuzzer&#45;&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M95.75,-73.04C95.75,-81.09 95.75,-89.77 95.75,-98.21"/>
<polygon fill="none" stroke="black" points="92.25,-97.98 95.75,-107.98 99.25,-97.98 92.25,-97.98"/>
</g>
<!-- Fuzzer -->
<g id="node3" class="node">
<title>Fuzzer</title>
<g id="a_node3"><a xlink:href="Fuzzer.ipynb" xlink:title="class Fuzzer:&#10;Base class for fuzzers.">
<polygon fill="none" stroke="black" points="67.12,-219 67.12,-278.5 124.38,-278.5 124.38,-219 67.12,-219"/>
<text text-anchor="start" x="75.12" y="-262.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
<polyline fill="none" stroke="black" points="67.12,-252.5 124.38,-252.5"/>
<g id="a_node3_8"><a xlink:href="#" xlink:title="Fuzzer">
<g id="a_node3_9"><a xlink:href="Fuzzer.ipynb" xlink:title="run(self, runner: Fuzzer.Runner = &lt;Fuzzer.Runner object at 0x110596240&gt;) &#45;&gt; Tuple[subprocess.CompletedProcess, str]:&#10;Run `runner` with fuzz input">
<text text-anchor="start" x="77.75" y="-240" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">run()</text>
</a>
</g>
<g id="a_node3_10"><a xlink:href="Fuzzer.ipynb" xlink:title="runs(self, runner: Fuzzer.Runner = &lt;Fuzzer.PrintRunner object at 0x110595e20&gt;, trials: int = 10) &#45;&gt; List[Tuple[subprocess.CompletedProcess, str]]:&#10;Run `runner` with fuzz input, `trials` times">
<text text-anchor="start" x="77.75" y="-227.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">runs()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;Fuzzer -->
<g id="edge2" class="edge">
<title>GrammarFuzzer&#45;&gt;Fuzzer</title>
<path fill="none" stroke="black" d="M95.75,-182.44C95.75,-190.54 95.75,-199.19 95.75,-207.47"/>
<polygon fill="none" stroke="black" points="92.25,-207.31 95.75,-217.31 99.25,-207.31 92.25,-207.31"/>
</g>
<!-- Legend -->
<g id="node4" class="node">
<title>Legend</title>
<text text-anchor="start" x="209.12" y="-52.62" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="209.12" y="-42.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="215.12" y="-42.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="209.12" y="-32.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="215.12" y="-32.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="209.12" y="-22.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="215.12" y="-22.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="209.12" y="-13.57" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</div></div>
</div>
</section>
<section id="lessons-learned">
<h2>Lessons Learned<a class="headerlink" href="#lessons-learned" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>By specifying probabilities, one can steer fuzzing towards input features of interest.</p></li>
<li><p>Learning probabilities from samples allows one to focus on features that are common or uncommon in input samples.</p></li>
<li><p>Learning probabilities from a subset of samples allows one to produce more similar inputs.</p></li>
</ul>
</section>
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Link to this heading">#</a></h2>
<p>Now that we have brought together probabilities and grammars (and revisited parsers and grammars), we have created a foundation for many applications.  Our next chapters will focus on</p>
<ul class="simple">
<li><p>how to <a class="reference internal" href="Reducer.html"><span class="std std-doc"><em>reduce</em> failing inputs to a minimum</span></a></p></li>
<li><p>how to <a class="reference internal" href="Carver.html"><span class="std std-doc">carve</span></a> and <a class="reference internal" href="APIFuzzer.html"><span class="std std-doc">produce</span></a> tests at the function level</p></li>
<li><p>how to <a class="reference internal" href="WebFuzzer.html"><span class="std std-doc">automatically test (Web) user interfaces</span></a></p></li>
</ul>
<p>Enjoy!</p>
</section>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading">#</a></h2>
<p>The idea of mining probabilities by parsing a corpus of data was first covered in “Learning to Fuzz: Application-Independent Fuzz Testing with Probabilistic, Generative Models of Input Data” \cite{Patra2016} which also learns and applies probabilistic rules for derivation trees.  Applying this idea on probabilistic grammars as well as inverting probabilities or learning from slices was first executed in the work “Inputs from Hell: Generating Uncommon Inputs from Common Samples” \cite{Pavese2018}.</p>
<p>Our exposition of Benford’s law follows <a class="reference external" href="https://brilliant.org/wiki/benfords-law/">this article</a>.</p>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">#</a></h2>
<section id="exercise-1-probabilistic-fuzzing-with-coverage">
<h3>Exercise 1: Probabilistic Fuzzing with Coverage<a class="headerlink" href="#exercise-1-probabilistic-fuzzing-with-coverage" title="Link to this heading">#</a></h3>
<p>Create a class <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarCoverageFuzzer</span></code> that extends <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> with probabilistic capabilities.  The idea is to first cover all uncovered expansions (like <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code>) and once all expansions are covered, to proceed by probabilities (like <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarFuzzer</span></code>).</p>
<p>To this end, define new instances of the <code class="docutils literal notranslate"><span class="pre">choose_covered_node_expansion()</span></code> and <code class="docutils literal notranslate"><span class="pre">choose_uncovered_node_expansion()</span></code> methods that choose an expansion based on the given weights.</p>
<p>If you are an advanced programmer, realize the class via <em>multiple inheritance</em> from <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> and <code class="docutils literal notranslate"><span class="pre">ProbabilisticGrammarFuzzer</span></code> to achieve this.</p>
<p>Multiple inheritance is a tricky thing.  If you have two classes <span class="math notranslate nohighlight">\(A'\)</span> and <span class="math notranslate nohighlight">\(A''\)</span> which both inherit from <span class="math notranslate nohighlight">\(A\)</span>, the same method <span class="math notranslate nohighlight">\(m()\)</span> of <span class="math notranslate nohighlight">\(A\)</span> may be overloaded in both <span class="math notranslate nohighlight">\(A'\)</span> and <span class="math notranslate nohighlight">\(A''\)</span>.  If one now inherits from <em>both</em> <span class="math notranslate nohighlight">\(A'\)</span> and <span class="math notranslate nohighlight">\(A''\)</span>, and calls <span class="math notranslate nohighlight">\(m()\)</span>, which of the <span class="math notranslate nohighlight">\(m()\)</span> implementations should be called?  Python “resolves” this conflict by simply invoking the one <span class="math notranslate nohighlight">\(m()\)</span> method in the class one inherits from first.</p>
<p>To avoid such conflicts, one can check whether the order in which one inherits makes a difference.  The method <code class="docutils literal notranslate"><span class="pre">inheritance_conflicts()</span></code> compares the attributes with each other; if they refer to different code, you have to resolve the conflict.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">inheritance_conflicts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">inheritance_conflicts</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">,</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;choose_node_expansion&#39;]
</pre></div>
</div>
</div>
</div>
<p>This is a method you <em>have</em> to implement for multiple inheritance besides <code class="docutils literal notranslate"><span class="pre">choose_covered_node_expansion()</span></code> and <code class="docutils literal notranslate"><span class="pre">choose_uncovered_node_expansion()</span></code>.</p>
<p><strong>Solution</strong>.  With multiple inheritance, this is fairly easy; we just need to point the three methods to the right places:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProbabilisticGrammarCoverageFuzzer</span><span class="p">(</span>
        <span class="n">GrammarCoverageFuzzer</span><span class="p">,</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">):</span>
    <span class="c1"># Choose uncovered expansions first</span>
    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">GrammarCoverageFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

    <span class="c1"># Among uncovered expansions, pick by (relative) probability</span>
    <span class="k">def</span> <span class="nf">choose_uncovered_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

    <span class="c1"># For covered nodes, pick by probability, too</span>
    <span class="k">def</span> <span class="nf">choose_covered_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ProbabilisticGrammarFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the first nine invocations, our fuzzer covers one digit after another:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cov_leaddigit_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGrammarCoverageFuzzer</span><span class="p">(</span>
    <span class="n">PROBABILISTIC_EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;leaddigit&gt;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">cov_leaddigit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;1&#39;, &#39;2&#39;, &#39;6&#39;, &#39;3&#39;, &#39;5&#39;, &#39;4&#39;, &#39;9&#39;, &#39;8&#39;, &#39;7&#39;]
</pre></div>
</div>
</div>
</div>
<p>After these, we again proceed by probabilities:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trials</span> <span class="o">=</span> <span class="mi">10000</span>

<span class="n">count</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">crange</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;9&#39;</span><span class="p">):</span>
    <span class="n">count</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">count</span><span class="p">[</span><span class="n">cov_leaddigit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">([(</span><span class="n">digit</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="n">digit</span><span class="p">]</span> <span class="o">/</span> <span class="n">trials</span><span class="p">)</span> <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="n">count</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;0&#39;, 0.0), (&#39;1&#39;, 0.3112), (&#39;2&#39;, 0.1736), (&#39;3&#39;, 0.1209), (&#39;4&#39;, 0.0966), (&#39;5&#39;, 0.0816), (&#39;6&#39;, 0.0649), (&#39;7&#39;, 0.0568), (&#39;8&#39;, 0.0484), (&#39;9&#39;, 0.046)]
</pre></div>
</div>
</div>
</div>
</section>
<section id="exercise-2-learning-from-past-bugs">
<h3>Exercise 2: Learning from Past Bugs<a class="headerlink" href="#exercise-2-learning-from-past-bugs" title="Link to this heading">#</a></h3>
<p>Learning from a set of inputs can be extremely valuable if one learns from <em>inputs that are known to have caused failures before.</em>  In this exercise, you will go and learn distributions from past vulnerabilities.</p>
<ol class="arabic simple">
<li><p>Download <a class="reference external" href="https://github.com/tunz/js-vuln-db"><code class="docutils literal notranslate"><span class="pre">js-vuln-db</span></code></a>, a set of JavaScript engine vulnerabilities.  Each vulnerability comes with code that exercises it.</p></li>
<li><p>Extract all <em>number literals</em> from the code, using <code class="docutils literal notranslate"><span class="pre">re.findall()</span></code> with appropriate regular expressions.</p></li>
<li><p>Convert these literals to (decimal) <em>numeric values</em> and count their respective occurrences.</p></li>
<li><p>Create a grammar <code class="docutils literal notranslate"><span class="pre">RISKY_NUMBERS</span></code> that produces these numbers with probabilities reflecting the above counts.</p></li>
</ol>
<p>Of course, there is more to vulnerabilities than just a specific numbers, but some numbers are more likely to induce errors than others.  The next time you fuzz a system, do not generate numbers randomly; instead, pick one from <code class="docutils literal notranslate"><span class="pre">RISKY_NUMBERS</span></code> :-)</p>
<p><strong>Solution.</strong> <em>Solution for the exercise</em></p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="Parser.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Parsing Inputs</p>
      </div>
    </a>
    <a class="right-next"
       href="GeneratorGrammarFuzzer.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Fuzzing with Generators</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-law-of-leading-digits">The Law of Leading Digits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#specifying-probabilities">Specifying Probabilities</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-probabilities">Computing Probabilities</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#distributing-probabilities">Distributing Probabilities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#checking-probabilities">Checking Probabilities</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#expanding-by-probability">Expanding by Probability</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#directed-fuzzing">Directed Fuzzing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#probabilities-in-context">Probabilities in Context</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-probabilities-from-samples">Learning Probabilities from Samples</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#counting-expansions">Counting Expansions</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#assigning-probabilities">Assigning Probabilities</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-common-features">Testing Common Features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-uncommon-features">Testing Uncommon Features</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#learning-probabilities-from-input-slices">Learning Probabilities from Input Slices</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#detecting-unnatural-numbers">Detecting Unnatural Numbers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-probabilistic-fuzzing-with-coverage">Exercise 1: Probabilistic Fuzzing with Coverage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-learning-from-past-bugs">Exercise 2: Learning from Past Bugs</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021-2025 CISPA Helmholtz Center for Information Security (www.cispa.de); © Copyright 2018-2020 Saarland University, authors, and contributors. All Rights Reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>