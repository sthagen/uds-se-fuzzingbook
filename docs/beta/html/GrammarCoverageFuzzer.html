
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Grammar Coverage &#8212; The Fuzzing Book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=42e1b1a5" />
    <link rel="stylesheet" type="text/css" href="_static/mastodon-timeline.css?v=f82c2b23" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'GrammarCoverageFuzzer';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Parsing Inputs" href="Parser.html" />
    <link rel="prev" title="Efficient Grammar Fuzzing" href="GrammarFuzzer.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>
<aside class="bd-header-announcement" aria-label="Announcement">
  <div class="bd-header-announcement__content"><p>This is a beta version of fuzzingbook.org, currently in development. See the <a href="https://fuzzingbook.org/"  style="color:white!important;">classic site</a> for resources.</p></div>
</aside>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/fuzzingbook.png" class="logo__image only-light" alt="The Fuzzing Book - Home"/>
    <script>document.write(`<img src="_static/fuzzingbook.png" class="logo__image only-dark" alt="The Fuzzing Book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="index.html">
                    The Fuzzing Book
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tours.html">Tours through the Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="Intro_Testing.html">Introduction to Software Testing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Lexical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Fuzzer.html">Fuzzing: Breaking Things with Random Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Coverage.html">Code Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationFuzzer.html">Mutation-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GreyboxFuzzer.html">Greybox Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SearchBasedFuzzer.html">Search-Based Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationAnalysis.html">Mutation Analysis</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Syntactical Fuzzing</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Grammars.html">Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarFuzzer.html">Efficient Grammar Fuzzing</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Grammar Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parser.html">Parsing Inputs</a></li>
<li class="toctree-l1"><a class="reference internal" href="ProbabilisticGrammarFuzzer.html">Probabilistic Grammar Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="GeneratorGrammarFuzzer.html">Fuzzing with Generators</a></li>

<li class="toctree-l1"><a class="reference internal" href="GreyboxGrammarFuzzer.html">Greybox Fuzzing with Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="Reducer.html">Reducing Failure-Inducing Inputs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Semantical Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingWithConstraints.html">Fuzzing with Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="GrammarMiner.html">Mining Input Grammars</a></li>
<li class="toctree-l1"><a class="reference internal" href="InformationFlow.html">Tracking Information Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="ConcolicFuzzer.html">Concolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="SymbolicFuzzer.html">Symbolic Fuzzing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DynamicInvariants.html">Mining Function Specifications</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Domain-Specific Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ConfigurationFuzzer.html">Testing Configurations</a></li>
<li class="toctree-l1"><a class="reference internal" href="APIFuzzer.html">Fuzzing APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Carver.html">Carving Unit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="PythonFuzzer.html">Testing Compilers</a></li>
<li class="toctree-l1"><a class="reference internal" href="WebFuzzer.html">Testing Web Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="GUIFuzzer.html">Testing Graphical User Interfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Managing Fuzzing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="FuzzingInTheLarge.html">Fuzzing in the Large</a></li>
<li class="toctree-l1"><a class="reference internal" href="WhenToStopFuzzing.html">When To Stop Fuzzing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="AcademicPrototyping.html">Academic Prototyping</a></li>
<li class="toctree-l1"><a class="reference internal" href="PrototypingWithPython.html">Prototyping with Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="ExpectError.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timer.html">Timer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Timeout.html">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="ClassDiagram.html">Class Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="RailroadDiagrams.html">Railroad Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="ControlFlow.html">Control Flow Graph</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About This Book</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ReleaseNotes.html">Fuzzingbook Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Importing.html">Using Fuzzingbook Code in your own Programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="Guide_for_Authors.html">Guide for Authors</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/master?urlpath=tree/docs/notebooks/GrammarCoverageFuzzer.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/uds-se/fuzzingbook/issues/new?title=Issue%20on%20page%20%2FGrammarCoverageFuzzer.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/GrammarCoverageFuzzer.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Grammar Coverage</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#covering-grammar-elements">Covering Grammar Elements</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tracking-grammar-coverage">Tracking Grammar Coverage</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#keeping-track-of-expansions">Keeping Track of Expansions</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-possible-expansions">Computing Possible Expansions</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tracking-expansions-while-fuzzing">Tracking Expansions while Fuzzing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-things-together">Putting Things Together</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#covering-grammar-expansions">Covering Grammar Expansions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deep-foresight">Deep Foresight</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determining-maximum-per-symbol-coverage">Determining Maximum per-Symbol Coverage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determining-yet-uncovered-children">Determining yet Uncovered Children</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adaptive-lookahead">Adaptive Lookahead</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-new-coverage">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">new_coverage()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-excursion">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#all-together">All Together</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-choose-node-expansion">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End of Excursion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coverage-in-context">Coverage in Context</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extending-grammars-for-context-coverage-manually">Extending Grammars for Context Coverage Manually</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extending-grammars-for-context-coverage-programmatically">Extending Grammars for Context Coverage Programmatically</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-duplicate-context">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">_duplicate_context()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End of Excursion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#covering-code-by-covering-grammars">Covering Code by Covering Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cgi-grammars">CGI Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-creating-the-plot">Excursion: Creating the Plot</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#url-grammars">URL Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Excursion: Creating the Plot</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#will-this-always-work">Will this always work?</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#equivalent-elements">Equivalent Elements</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#deep-data-processing">Deep Data Processing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-testing-ls">Exercise 1: Testing ls</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-caching">Exercise 2: Caching</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="grammar-coverage">
<h1>Grammar Coverage<a class="headerlink" href="#grammar-coverage" title="Link to this heading">#</a></h1>
<p><a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">Producing inputs from grammars</span></a> gives all possible expansions of a rule the same likelihood.  For producing a comprehensive test suite, however, it makes more sense to maximize <em>variety</em> – for instance, by not repeating the same expansions over and over again.  In this chapter, we explore how to systematically <em>cover</em> elements of a grammar such that we maximize variety and do not miss out individual elements.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">&#39;GGb3e5p0HC8&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
        <iframe
            width="640"
            height="360"
            src="https://www.youtube-nocookie.com/embed/GGb3e5p0HC8"
            frameborder="0"
            allowfullscreen
            
        ></iframe>
        </div></div>
</div>
<p><strong>Prerequisites</strong></p>
<ul class="simple">
<li><p>You should have read the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>.</p></li>
<li><p>You should have read the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on efficient grammar fuzzing</span></a>.</p></li>
</ul>
<section id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Link to this heading">#</a></h2>
<!-- Automatically generated. Do not edit. -->
<p>To <a class="reference internal" href="Importing.html"><span class="std std-doc">use the code provided in this chapter</span></a>, write</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fuzzingbook.GrammarCoverageFuzzer</span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>and then make use of the following features.</p>
<p>This chapter introduces <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code>, an efficient grammar fuzzer extending <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code> from the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on efficient grammar fuzzing</span></a>.  It strives to <em>cover all expansions at least once,</em> thus ensuring coverage of functionality.</p>
<p>In the following example, for instance, we use <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> to produce an expression. We see that the resulting expression covers all digits and all operators in a single expression.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
<span class="go">&#39;-(2 + 3) * 4.5 / 6 - 2.0 / +8 + 7 + 3&#39;</span>
</pre></div>
</div>
<p>After fuzzing, the <code class="docutils literal notranslate"><span class="pre">expansion_coverage()</span></code> method returns a mapping of grammar expansions covered.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
<span class="go">{&#39;&lt;digit&gt; -&gt; 0&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 1&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 2&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 3&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 4&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 5&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 6&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 7&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 8&#39;,</span>
<span class="go"> &#39;&lt;digit&gt; -&gt; 9&#39;,</span>
<span class="go"> &#39;&lt;expr&gt; -&gt; &lt;term&gt;&#39;,</span>
<span class="go"> &#39;&lt;expr&gt; -&gt; &lt;term&gt; + &lt;expr&gt;&#39;,</span>
<span class="go"> &#39;&lt;expr&gt; -&gt; &lt;term&gt; - &lt;expr&gt;&#39;,</span>
<span class="go"> &#39;&lt;factor&gt; -&gt; (&lt;expr&gt;)&#39;,</span>
<span class="go"> &#39;&lt;factor&gt; -&gt; +&lt;factor&gt;&#39;,</span>
<span class="go"> &#39;&lt;factor&gt; -&gt; -&lt;factor&gt;&#39;,</span>
<span class="go"> &#39;&lt;factor&gt; -&gt; &lt;integer&gt;&#39;,</span>
<span class="go"> &#39;&lt;factor&gt; -&gt; &lt;integer&gt;.&lt;integer&gt;&#39;,</span>
<span class="go"> &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&#39;,</span>
<span class="go"> &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;&#39;,</span>
<span class="go"> &#39;&lt;start&gt; -&gt; &lt;expr&gt;&#39;,</span>
<span class="go"> &#39;&lt;term&gt; -&gt; &lt;factor&gt;&#39;,</span>
<span class="go"> &#39;&lt;term&gt; -&gt; &lt;factor&gt; * &lt;term&gt;&#39;,</span>
<span class="go"> &#39;&lt;term&gt; -&gt; &lt;factor&gt; / &lt;term&gt;&#39;}</span>
</pre></div>
</div>
<p>Subsequent calls to <code class="docutils literal notranslate"><span class="pre">fuzz()</span></code> will go for further coverage (i.e., covering the other area code digits, for example); a call to <code class="docutils literal notranslate"><span class="pre">reset()</span></code> clears the recorded coverage, starting anew.</p>
<p>Since such coverage in inputs also yields higher code coverage, <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> is a recommended extension to <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code>.</p>
<p><img alt="" src="_images/GrammarCoverageFuzzer-synopsis-1.svg" /></p>
</section>
<section id="covering-grammar-elements">
<h2>Covering Grammar Elements<a class="headerlink" href="#covering-grammar-elements" title="Link to this heading">#</a></h2>
<p>The aim of test generation is to cover all functionality of a program – hopefully including the failing functionality, of course.  This functionality, however, is tied to the <em>structure of the input</em>: If we fail to produce certain input elements, then the associated code and functionality will not be triggered either, nixing our chances to find a bug in there.</p>
<p>As an example, consider our expression grammar <code class="docutils literal notranslate"><span class="pre">EXPR_GRAMMAR</span></code> from the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars.</span></a>:</p>
<ul class="simple">
<li><p>If we do not produce negative numbers, then negative numbers will not be tested.</p></li>
<li><p>If we do not produce floating-point numbers, then floating-point numbers will not be tested.</p></li>
</ul>
<p>Our aim must thus be to <em>cover all possible expansions</em> – and not only by chance, but <em>by design</em>.</p>
<p>One way to maximize such variety is to <em>track</em> the expansions that occur during grammar production: If we already have seen some expansion, we can prefer other possible expansion candidates out of the set of possible expansions.  Consider the following rule in our expression grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">bookutils.setup</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bookutils</span> <span class="kn">import</span> <span class="n">quiz</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Fuzzer</span> <span class="kn">import</span> <span class="n">Fuzzer</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">CGI_GRAMMAR</span><span class="p">,</span> <span class="n">URL_GRAMMAR</span><span class="p">,</span> <span class="n">START_SYMBOL</span>
<span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">Grammar</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;+&lt;factor&gt;&#39;, &#39;-&lt;factor&gt;&#39;, &#39;(&lt;expr&gt;)&#39;, &#39;&lt;integer&gt;.&lt;integer&gt;&#39;, &#39;&lt;integer&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>Let us assume we have already produced an <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> in the first expansion of <code class="docutils literal notranslate"><span class="pre">&lt;factor&gt;</span></code>.  As it comes to expand the next factor, we would mark the <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> expansion as already covered, and choose one of the yet uncovered alternatives such as <code class="docutils literal notranslate"><span class="pre">-&lt;factor&gt;</span></code> (a negative number) or <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;.&lt;integer&gt;</span></code> (a floating-point number).  Only when we have covered all alternatives would we go back and reconsider expansions covered before.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quiz</span><span class="p">(</span><span class="s2">&quot;Which expansions of `EXPR_GRAMMAR` does the expression `1 + 2` cover?&quot;</span><span class="p">,</span>
     <span class="p">[</span>
         <span class="s2">&quot;`&lt;start&gt; -&gt; &lt;expr&gt;`&quot;</span><span class="p">,</span>
         <span class="s2">&quot;`&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;`&quot;</span><span class="p">,</span>
         <span class="s2">&quot;`&lt;integer&gt; -&gt; &lt;digit&gt;`&quot;</span><span class="p">,</span>
         <span class="s2">&quot;`&lt;factor&gt; -&gt; +&lt;factor&gt;`&quot;</span>
     <span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
    
    <script>
    var bad_answers = new Map();

    function answer(quiz_id) {
        ans = 0;
        for (i = 1;; i++) {
            checkbox = document.getElementById(quiz_id + "-" + i.toString());
            if (!checkbox)
                break;
            if (checkbox.checked)
                ans |= (1 << i);
        }
        return ans;
    }
    function check_selection(quiz_id, correct_answer, multiple_choice, hint) {
        given_answer = answer(quiz_id);
        if (given_answer == correct_answer)
        {
            document.getElementById(quiz_id + "-submit").value = "Correct!";
            document.getElementById(quiz_id + "-hint").innerHTML = "";

            for (i = 1;; i++) {
                checkbox = document.getElementById(quiz_id + "-" + i.toString());
                label = document.getElementById(quiz_id + "-" + i.toString() + "-label")
                if (!checkbox)
                    break;

                if (checkbox.checked) {
                    label.style.fontWeight = "bold";
                }
                else {
                    label.style.textDecoration = "line-through";
                }
            }
        }
        else 
        {
            document.getElementById(quiz_id + "-submit").value = "Try again";

            if (!bad_answers.has(quiz_id)) {
                bad_answers.set(quiz_id, 1);
            }
            else {
                bad_answers.set(quiz_id, bad_answers.get(quiz_id) + 1);
            }

            if (bad_answers.get(quiz_id) >= 2 && hint.length > 0) {
                document.getElementById(quiz_id + "-hint").innerHTML = 
                    "&nbsp;&nbsp;(Hint: <code>" + hint + "</code>)";
            }

            if (!multiple_choice) {
                for (i = 1;; i++) {
                    checkbox = document.getElementById(quiz_id + "-" + i.toString());
                    label = document.getElementById(quiz_id + "-" + i.toString() + "-label")

                    if (!checkbox)
                        break;
                    if (checkbox.checked) {
                        label.style.textDecoration = "line-through";
                    }
                }
            }
        }
    }
    function clear_selection(quiz_id) {
        document.getElementById(quiz_id + "-submit").value = "Submit";
        document.getElementById(quiz_id + "-hint").innerHTML = "";
    }
    </script>
    
    <div class="quiz">
    <h3 class="quiz_title">Quiz</h3>
    <p>
    <div class="quiz_question">Which expansions of <code>EXPR_GRAMMAR</code> does the expression <code>1 + 2</code> cover?</div>
    </p>
    <p>
    <div class="quiz_options" title="Check all that apply.">
    
        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-1" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-1-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-1"><code>&lt;start&gt; -&gt; &lt;expr&gt;</code></label><br>
    
        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-2" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-2-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-2"><code>&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;</code></label><br>
    
        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-3" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-3-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-3"><code>&lt;integer&gt; -&gt; &lt;digit&gt;</code></label><br>
    
        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-4" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-4-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-4"><code>&lt;factor&gt; -&gt; +&lt;factor&gt;</code></label><br>
    
    </div>
    </p>
    <input id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-submit" type="submit" value="Submit" onclick="check_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790', 10, 1, '')">
    <span class="quiz_hint" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-hint"></span>
    </div>
    </div></div>
</div>
<p>Indeed! The expression has expansions from <code class="docutils literal notranslate"><span class="pre">&lt;start&gt;</span></code> and into individual digits.</p>
<section id="tracking-grammar-coverage">
<h3>Tracking Grammar Coverage<a class="headerlink" href="#tracking-grammar-coverage" title="Link to this heading">#</a></h3>
<p>This concept of <em>grammar coverage</em> is easy to implement.  We introduce a class <code class="docutils literal notranslate"><span class="pre">TrackingGrammarCoverageFuzzer</span></code> that keeps track of the current grammar coverage achieved:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">Expansion</span>
<span class="kn">from</span> <span class="nn">GrammarFuzzer</span> <span class="kn">import</span> <span class="n">GrammarFuzzer</span><span class="p">,</span> <span class="n">all_terminals</span><span class="p">,</span> <span class="n">nonterminals</span><span class="p">,</span> \
    <span class="n">display_tree</span><span class="p">,</span> <span class="n">DerivationTree</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GrammarFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Track grammar coverage during production&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># invoke superclass __init__(), passing all arguments</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="keeping-track-of-expansions">
<h4>Keeping Track of Expansions<a class="headerlink" href="#keeping-track-of-expansions" title="Link to this heading">#</a></h4>
<p>In the set <code class="docutils literal notranslate"><span class="pre">covered_expansions</span></code>, we store individual expansions seen.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the set of covered expansions as strings SYMBOL -&gt; EXPANSION&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span>

    <span class="k">def</span> <span class="nf">reset_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear coverage info tracked so far&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We save them the expansions as strings “<em>symbol</em> -&gt; <em>expansion</em>”, using the function <code class="docutils literal notranslate"><span class="pre">expansion_key()</span></code> to generate a string representation for the (<em>symbol</em>, <em>expansion</em>) pair.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                  <span class="n">expansion</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Expansion</span><span class="p">,</span>
                                   <span class="n">DerivationTree</span><span class="p">,</span> 
                                   <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert (symbol, `expansion`) into a key &quot;SYMBOL -&gt; EXPRESSION&quot;. </span>
<span class="sd">      `expansion` can be an expansion string, a derivation tree,</span>
<span class="sd">         or a list of derivation trees.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="c1"># Expansion or single derivation tree</span>
        <span class="n">expansion</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">expansion</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Derivation tree</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">expansion</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="n">all_terminals</span><span class="p">((</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">symbol</span> <span class="o">+</span> <span class="s2">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="n">expansion</span>
</pre></div>
</div>
</div>
</div>
<p>Here’s an example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expansion_key</span><span class="p">(</span><span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="n">START_SYMBOL</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;&lt;start&gt; -&gt; &lt;expr&gt;&#39;
</pre></div>
</div>
</div>
</div>
<p>Instead of <em>expansion</em>, we can also pass a list of children as argument, which will then automatically be converted into a string.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot; + &quot;</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s2">&quot;&lt;term&gt;&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
<span class="n">expansion_key</span><span class="p">(</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;&lt;expr&gt; -&gt; &lt;expr&gt; + &lt;term&gt;&#39;
</pre></div>
</div>
</div>
</div>
</section>
<section id="computing-possible-expansions">
<h4>Computing Possible Expansions<a class="headerlink" href="#computing-possible-expansions" title="Link to this heading">#</a></h4>
<p>We can compute the set of possible expansions in a grammar by enumerating all expansions.  The method <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code> traverses the grammar recursively starting from the given symbol (by default: the grammar start symbol) and accumulates all expansions in the set <code class="docutils literal notranslate"><span class="pre">expansions</span></code>.  With the <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> parameter (default: <span class="math notranslate nohighlight">\(\infty\)</span>), we can control how deep the grammar exploration should go; we will need this later in the chapter.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_max_expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                                <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">max_depth</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

        <span class="n">expansions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]:</span>
            <span class="n">expansions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">expansion</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">nonterminal</span> <span class="ow">in</span> <span class="n">nonterminals</span><span class="p">(</span><span class="n">expansion</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nonterminal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="p">:</span>
                    <span class="n">expansions</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_expansion_coverage</span><span class="p">(</span>
                        <span class="n">nonterminal</span><span class="p">,</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expansions</span>

    <span class="k">def</span> <span class="nf">max_expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span> \
            <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return set of all expansions in a grammar </span>
<span class="sd">           starting with `symbol` (default: start symbol).</span>
<span class="sd">           If `max_depth` is given, expand only to that depth.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_expansion_coverage</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="n">START_SYMBOL</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cov</span>
</pre></div>
</div>
</div>
</div>
<p>We can use <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code> to compute all the expansions within the expression grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;,
 &#39;&lt;digit&gt; -&gt; 1&#39;,
 &#39;&lt;digit&gt; -&gt; 2&#39;,
 &#39;&lt;digit&gt; -&gt; 3&#39;,
 &#39;&lt;digit&gt; -&gt; 4&#39;,
 &#39;&lt;digit&gt; -&gt; 5&#39;,
 &#39;&lt;digit&gt; -&gt; 6&#39;,
 &#39;&lt;digit&gt; -&gt; 7&#39;,
 &#39;&lt;digit&gt; -&gt; 8&#39;,
 &#39;&lt;digit&gt; -&gt; 9&#39;,
 &#39;&lt;expr&gt; -&gt; &lt;term&gt;&#39;,
 &#39;&lt;expr&gt; -&gt; &lt;term&gt; + &lt;expr&gt;&#39;,
 &#39;&lt;expr&gt; -&gt; &lt;term&gt; - &lt;expr&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; (&lt;expr&gt;)&#39;,
 &#39;&lt;factor&gt; -&gt; +&lt;factor&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; -&lt;factor&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; &lt;integer&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; &lt;integer&gt;.&lt;integer&gt;&#39;,
 &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&#39;,
 &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;&#39;,
 &#39;&lt;start&gt; -&gt; &lt;expr&gt;&#39;,
 &#39;&lt;term&gt; -&gt; &lt;factor&gt;&#39;,
 &#39;&lt;term&gt; -&gt; &lt;factor&gt; * &lt;term&gt;&#39;,
 &#39;&lt;term&gt; -&gt; &lt;factor&gt; / &lt;term&gt;&#39;}
</pre></div>
</div>
</div>
</div>
</section>
<section id="tracking-expansions-while-fuzzing">
<h4>Tracking Expansions while Fuzzing<a class="headerlink" href="#tracking-expansions-while-fuzzing" title="Link to this heading">#</a></h4>
<p>During expansion, we can keep track of expansions seen.  To do so, we hook into the method <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code>, expanding a single node in our <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">Grammar fuzzer</span></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                     <span class="n">new_child</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Expansion</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">new_child</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now covered:&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> 
                              <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coverage</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">index</span>
</pre></div>
</div>
</div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">missing_expansion_coverage()</span></code> is a helper method that returns the expansions that still have to be covered:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">missing_expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return expansions not covered yet&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="putting-things-together">
<h4>Putting Things Together<a class="headerlink" href="#putting-things-together" title="Link to this heading">#</a></h4>
<p>Let us show how tracking works.  To keep things simple, let us focus on <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code> expansions only.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span> <span class="o">=</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span>
    <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 9
Tree: 9
&#39;9&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;9&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 0
Tree: 0
&#39;0&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;0&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 5
Tree: 5
&#39;5&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;5&#39;
</pre></div>
</div>
</div>
</div>
<p>Here’s the set of covered expansions so far:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;, &#39;&lt;digit&gt; -&gt; 5&#39;, &#39;&lt;digit&gt; -&gt; 9&#39;}
</pre></div>
</div>
</div>
</div>
<p>This is the set of all expansions we can cover:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;,
 &#39;&lt;digit&gt; -&gt; 1&#39;,
 &#39;&lt;digit&gt; -&gt; 2&#39;,
 &#39;&lt;digit&gt; -&gt; 3&#39;,
 &#39;&lt;digit&gt; -&gt; 4&#39;,
 &#39;&lt;digit&gt; -&gt; 5&#39;,
 &#39;&lt;digit&gt; -&gt; 6&#39;,
 &#39;&lt;digit&gt; -&gt; 7&#39;,
 &#39;&lt;digit&gt; -&gt; 8&#39;,
 &#39;&lt;digit&gt; -&gt; 9&#39;}
</pre></div>
</div>
</div>
</div>
<p>This is the missing coverage:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 1&#39;,
 &#39;&lt;digit&gt; -&gt; 2&#39;,
 &#39;&lt;digit&gt; -&gt; 3&#39;,
 &#39;&lt;digit&gt; -&gt; 4&#39;,
 &#39;&lt;digit&gt; -&gt; 6&#39;,
 &#39;&lt;digit&gt; -&gt; 7&#39;,
 &#39;&lt;digit&gt; -&gt; 8&#39;}
</pre></div>
</div>
</div>
</div>
<p>On average, how many characters do we have to produce until all expansions are covered?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">average_length_until_full_coverage</span><span class="p">(</span><span class="n">fuzzer</span><span class="p">:</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">trials</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
        <span class="c1"># print(trial, end=&quot; &quot;)</span>
        <span class="n">fuzzer</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">digit_fuzzer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>28.4
</pre></div>
</div>
</div>
</div>
<p>For full expressions, this takes a bit longer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">expr_fuzzer</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>138.12
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="covering-grammar-expansions">
<h3>Covering Grammar Expansions<a class="headerlink" href="#covering-grammar-expansions" title="Link to this heading">#</a></h3>
<p>Let us now not only track coverage, but actually <em>produce</em> coverage.  The idea is as follows:</p>
<ol class="arabic simple">
<li><p>We determine children yet uncovered (in <code class="docutils literal notranslate"><span class="pre">uncovered_children</span></code>)</p></li>
<li><p>If all children are covered, we fall back to the original method (i.e., choosing one expansion randomly)</p></li>
<li><p>Otherwise, we select a child from the uncovered children and mark it as covered.</p></li>
</ol>
<p>To this end, we introduce a new fuzzer <code class="docutils literal notranslate"><span class="pre">SimpleGrammarCoverageFuzzer</span></code> that implements this strategy in the <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code> method – the method <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">the <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code> superclass uses to select the child to be expanded</span></a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;When choosing expansions, prefer expansions not covered.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index of expansion in `children_alternatives` to be selected.</span>
<span class="sd">           Picks uncovered expansions, if any.&quot;&quot;&quot;</span>

        <span class="c1"># Prefer uncovered expansions</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">uncovered_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                              <span class="k">if</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                              <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">]</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">uncovered_children</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncovered_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># All expansions covered - use superclass method</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_covered_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

        <span class="c1"># Select from uncovered nodes</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_uncovered_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">uncovered_children</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">index_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The two methods <code class="docutils literal notranslate"><span class="pre">choose_covered_node_expansion()</span></code> and <code class="docutils literal notranslate"><span class="pre">choose_uncovered_node_expansion()</span></code> are provided for subclasses to hook in:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_uncovered_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                                        <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> \
            <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index of expansion in _uncovered_ `children_alternatives`</span>
<span class="sd">           to be selected.</span>
<span class="sd">           To be overloaded in subclasses.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose_covered_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                      <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                                      <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> \
            <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index of expansion in _covered_ `children_alternatives`</span>
<span class="sd">           to be selected.</span>
<span class="sd">           To be overloaded in subclasses.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>By returning the set of expansions covered so far, we can invoke the fuzzer multiple times, each time adding to the grammar coverage.  Using the <code class="docutils literal notranslate"><span class="pre">EXPR_GRAMMAR</span></code> grammar to produce digits, for instance, the fuzzer produces one digit after the other:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;5&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;2&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;1&#39;
</pre></div>
</div>
</div>
</div>
<p>Here’s the set of covered expansions so far:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 1&#39;, &#39;&lt;digit&gt; -&gt; 2&#39;, &#39;&lt;digit&gt; -&gt; 5&#39;}
</pre></div>
</div>
</div>
</div>
<p>Let us fuzz some more. We see that with each iteration, we cover another expansion:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 9 7 4 8 3 6 
</pre></div>
</div>
</div>
</div>
<p>At the end, all expansions are covered:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>set()
</pre></div>
</div>
</div>
</div>
<p>Let us apply this on a more complex grammar – e.g., the full expression grammar.  We see that after a few iterations, we cover each and every digit, operator, and expansion:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>+(0.31 / (5) / 9 + 4 * 6 / 3 - 8 - 7) * -2
+++2 / 87360
((4) * 0 - 1) / -9.6 + 7 / 6 + 1 * 8 + 7 * 8
++++26 / -64.45
(8 / 1 / 6 + 9 + 7 + 8) * 1.1 / 0 * 1
7.7
++(3.5 / 3) - (-4 + 3) / (8 / 0) / -4 * 2 / 1
+(90 / --(28 * 8 / 5 + 5 / (5 / 8))) - +9.36 / 2.5 * (5 * (7 * 6 * 5) / 8)
9.11 / 7.28
1 / (9 - 5 * 6) / 6 / 7 / 7 + 1 + 1 - 7 * -3
</pre></div>
</div>
</div>
</div>
<p>Again, all expansions are covered:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>set()
</pre></div>
</div>
</div>
</div>
<p>We see that our strategy is much more effective in achieving coverage than the random approach:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>52.28
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="deep-foresight">
<h2>Deep Foresight<a class="headerlink" href="#deep-foresight" title="Link to this heading">#</a></h2>
<p>Selecting expansions for individual rules is a good start; however, it is not sufficient, as the following example shows.  We apply our coverage fuzzer on the CGI grammar from the <a class="reference internal" href="Grammars.html"><span class="std std-doc">chapter on grammars</span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CGI_GRAMMAR</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: [&#39;&lt;string&gt;&#39;],
 &#39;&lt;string&gt;&#39;: [&#39;&lt;letter&gt;&#39;, &#39;&lt;letter&gt;&lt;string&gt;&#39;],
 &#39;&lt;letter&gt;&#39;: [&#39;&lt;plus&gt;&#39;, &#39;&lt;percent&gt;&#39;, &#39;&lt;other&gt;&#39;],
 &#39;&lt;plus&gt;&#39;: [&#39;+&#39;],
 &#39;&lt;percent&gt;&#39;: [&#39;%&lt;hexdigit&gt;&lt;hexdigit&gt;&#39;],
 &#39;&lt;hexdigit&gt;&#39;: [&#39;0&#39;,
  &#39;1&#39;,
  &#39;2&#39;,
  &#39;3&#39;,
  &#39;4&#39;,
  &#39;5&#39;,
  &#39;6&#39;,
  &#39;7&#39;,
  &#39;8&#39;,
  &#39;9&#39;,
  &#39;a&#39;,
  &#39;b&#39;,
  &#39;c&#39;,
  &#39;d&#39;,
  &#39;e&#39;,
  &#39;f&#39;],
 &#39;&lt;other&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;-&#39;, &#39;_&#39;]}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c
+%a6++
+-
+
++
%18%b7
+e
_
d2+%e3
%d0
</pre></div>
</div>
</div>
</div>
<p>After 10 iterations, we still have a number of expansions uncovered:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;hexdigit&gt; -&gt; 2&#39;,
 &#39;&lt;hexdigit&gt; -&gt; 4&#39;,
 &#39;&lt;hexdigit&gt; -&gt; 5&#39;,
 &#39;&lt;hexdigit&gt; -&gt; 9&#39;,
 &#39;&lt;hexdigit&gt; -&gt; c&#39;,
 &#39;&lt;hexdigit&gt; -&gt; f&#39;,
 &#39;&lt;other&gt; -&gt; 0&#39;,
 &#39;&lt;other&gt; -&gt; 1&#39;,
 &#39;&lt;other&gt; -&gt; 3&#39;,
 &#39;&lt;other&gt; -&gt; 4&#39;,
 &#39;&lt;other&gt; -&gt; 5&#39;,
 &#39;&lt;other&gt; -&gt; a&#39;,
 &#39;&lt;other&gt; -&gt; b&#39;}
</pre></div>
</div>
</div>
</div>
<p>Why is that so?  The problem is that in the CGI grammar, the largest number of variations to be covered occurs in the <code class="docutils literal notranslate"><span class="pre">hexdigit</span></code> rule.  However, we first need to <em>reach</em> this expansion.  When expanding a <code class="docutils literal notranslate"><span class="pre">&lt;letter&gt;</span></code> symbol, we have the choice between three possible expansions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">CGI_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;letter&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;plus&gt;&#39;, &#39;&lt;percent&gt;&#39;, &#39;&lt;other&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>If all three expansions are covered already, then <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code> above will choose one randomly – even if there may be more expansions to cover when choosing <code class="docutils literal notranslate"><span class="pre">&lt;percent&gt;</span></code>.</p>
<p>What we need is a better strategy that will pick <code class="docutils literal notranslate"><span class="pre">&lt;percent&gt;</span></code> if there are more uncovered expansions following – even if <code class="docutils literal notranslate"><span class="pre">&lt;percent&gt;</span></code> is covered.  Such a strategy was first discussed by W. Burkhardt \cite{Burkhardt1967} under the name of “Shortest Path Selection”:</p>
<blockquote>
<div><p>This version selects, from several alternatives for development, that syntactic unit under which there is still an unused unit available, starting with the shortest path.</p>
</div></blockquote>
<p>This is what we will implement in the next steps.</p>
<section id="determining-maximum-per-symbol-coverage">
<h3>Determining Maximum per-Symbol Coverage<a class="headerlink" href="#determining-maximum-per-symbol-coverage" title="Link to this heading">#</a></h3>
<p>To address this problem, we introduce a new class <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> that builds on <code class="docutils literal notranslate"><span class="pre">SimpleGrammarCoverageFuzzer</span></code>, but with a <em>better strategy</em>.  First, we need to compute the <em>maximum set of expansions</em> that can be reached from a particular symbol, as we already have implemented in <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code>.  The idea is to later compute the <em>intersection</em> of this set and the expansions already covered, such that we can favor those expansions with a non-empty intersection.</p>
<p>The first step – computing the maximum set of expansions that can be reached from a symbol – is already implemented.  By passing a <code class="docutils literal notranslate"><span class="pre">symbol</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code>, we can compute the possible expansions for every symbol:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">(</span><span class="s1">&#39;&lt;integer&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;,
 &#39;&lt;digit&gt; -&gt; 1&#39;,
 &#39;&lt;digit&gt; -&gt; 2&#39;,
 &#39;&lt;digit&gt; -&gt; 3&#39;,
 &#39;&lt;digit&gt; -&gt; 4&#39;,
 &#39;&lt;digit&gt; -&gt; 5&#39;,
 &#39;&lt;digit&gt; -&gt; 6&#39;,
 &#39;&lt;digit&gt; -&gt; 7&#39;,
 &#39;&lt;digit&gt; -&gt; 8&#39;,
 &#39;&lt;digit&gt; -&gt; 9&#39;,
 &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&#39;,
 &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;&#39;}
</pre></div>
</div>
</div>
</div>
<p>We see that by expanding <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code>, we can cover a total of 12 productions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quiz</span><span class="p">(</span><span class="s2">&quot;How many productions would `f.max_expansion_coverage(&#39;&lt;digit&gt;&#39;)` return?&quot;</span><span class="p">,</span>
     <span class="p">[</span>
         <span class="s2">&quot;10&quot;</span><span class="p">,</span>
         <span class="s2">&quot;11&quot;</span><span class="p">,</span>
         <span class="s2">&quot;12&quot;</span><span class="p">,</span>
         <span class="s2">&quot;13&quot;</span>
     <span class="p">],</span> <span class="s2">&quot;100 / 100&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">
    
    <script>
    var bad_answers = new Map();

    function answer(quiz_id) {
        ans = 0;
        for (i = 1;; i++) {
            checkbox = document.getElementById(quiz_id + "-" + i.toString());
            if (!checkbox)
                break;
            if (checkbox.checked)
                ans |= (1 << i);
        }
        return ans;
    }
    function check_selection(quiz_id, correct_answer, multiple_choice, hint) {
        given_answer = answer(quiz_id);
        if (given_answer == correct_answer)
        {
            document.getElementById(quiz_id + "-submit").value = "Correct!";
            document.getElementById(quiz_id + "-hint").innerHTML = "";

            for (i = 1;; i++) {
                checkbox = document.getElementById(quiz_id + "-" + i.toString());
                label = document.getElementById(quiz_id + "-" + i.toString() + "-label")
                if (!checkbox)
                    break;

                if (checkbox.checked) {
                    label.style.fontWeight = "bold";
                }
                else {
                    label.style.textDecoration = "line-through";
                }
            }
        }
        else 
        {
            document.getElementById(quiz_id + "-submit").value = "Try again";

            if (!bad_answers.has(quiz_id)) {
                bad_answers.set(quiz_id, 1);
            }
            else {
                bad_answers.set(quiz_id, bad_answers.get(quiz_id) + 1);
            }

            if (bad_answers.get(quiz_id) >= 2 && hint.length > 0) {
                document.getElementById(quiz_id + "-hint").innerHTML = 
                    "&nbsp;&nbsp;(Hint: <code>" + hint + "</code>)";
            }

            if (!multiple_choice) {
                for (i = 1;; i++) {
                    checkbox = document.getElementById(quiz_id + "-" + i.toString());
                    label = document.getElementById(quiz_id + "-" + i.toString() + "-label")

                    if (!checkbox)
                        break;
                    if (checkbox.checked) {
                        label.style.textDecoration = "line-through";
                    }
                }
            }
        }
    }
    function clear_selection(quiz_id) {
        document.getElementById(quiz_id + "-submit").value = "Submit";
        document.getElementById(quiz_id + "-hint").innerHTML = "";
    }
    </script>
    
    <div class="quiz">
    <h3 class="quiz_title">Quiz</h3>
    <p>
    <div class="quiz_question">How many productions would <code>f.max_expansion_coverage('&lt;digit&gt;')</code> return?</div>
    </p>
    <p>
    <div class="quiz_options" title="Pick a choice.">
    
        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-1" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-1-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-1">10</label><br>
    
        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-2" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-2-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-2">11</label><br>
    
        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-3" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-3-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-3">12</label><br>
    
        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-4" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')">
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-4-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-4">13</label><br>
    
    </div>
    </p>
    <input id="f8753e00-d3ed-11ef-b013-6298cf1a5790-submit" type="submit" value="Submit" onclick="check_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790', 2, 0, '100 / 100')">
    <span class="quiz_hint" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-hint"></span>
    </div>
    </div></div>
</div>
<p>Indeed. Here are all the possible expansions for <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">(</span><span class="s1">&#39;&lt;digit&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;,
 &#39;&lt;digit&gt; -&gt; 1&#39;,
 &#39;&lt;digit&gt; -&gt; 2&#39;,
 &#39;&lt;digit&gt; -&gt; 3&#39;,
 &#39;&lt;digit&gt; -&gt; 4&#39;,
 &#39;&lt;digit&gt; -&gt; 5&#39;,
 &#39;&lt;digit&gt; -&gt; 6&#39;,
 &#39;&lt;digit&gt; -&gt; 7&#39;,
 &#39;&lt;digit&gt; -&gt; 8&#39;,
 &#39;&lt;digit&gt; -&gt; 9&#39;}
</pre></div>
</div>
</div>
</div>
</section>
<section id="determining-yet-uncovered-children">
<h3>Determining yet Uncovered Children<a class="headerlink" href="#determining-yet-uncovered-children" title="Link to this heading">#</a></h3>
<p>We can now start to implement <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code>.  Our idea is to determine the <em>missing coverage</em> for each child.</p>
<p>Given a list of children, we can use <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code> to compute the maximum coverage for each child. From this, we <em>subtract</em> the coverage already seen (<code class="docutils literal notranslate"><span class="pre">expansion_coverage()</span></code>). This results in the coverage we can still obtain.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Produce from grammars, aiming for coverage of all expansions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">new_child_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span>
                           <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return new coverage that would be obtained </span>
<span class="sd">           by expanding (`symbol`, `children`)&quot;&quot;&quot;</span>

        <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_child_coverage</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>
        <span class="n">new_cov</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
        <span class="n">new_cov</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>   <span class="c1"># -= is set subtraction</span>
        <span class="k">return</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">_new_child_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span>
                            <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">new_cov</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c_symbol</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c_symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">:</span>
                <span class="n">new_cov</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">(</span><span class="n">c_symbol</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_cov</span>
</pre></div>
</div>
</div>
</div>
<p>Let us illustrate <code class="docutils literal notranslate"><span class="pre">new_child_coverage()</span></code>.  We again start fuzzing, choosing expansions randomly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 2
Tree: 2
&#39;2&#39;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;2&#39;
</pre></div>
</div>
</div>
</div>
<p>This is our current coverage:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 2&#39;}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># docassert</span>
<span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;&lt;digit&gt; -&gt; 2&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>If we want to expand <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code> into <code class="docutils literal notranslate"><span class="pre">0</span></code>, that would yield us new coverage:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="p">[])])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;}
</pre></div>
</div>
</div>
</div>
<p>If we want to expand <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code> into <code class="docutils literal notranslate"><span class="pre">2</span></code> again, that would yield us <em>no</em> new coverage:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="p">[])])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>set()
</pre></div>
</div>
</div>
</div>
<p>When we go through the individual expansion possibilities for <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code>, we see that all expansions offer additional coverage, <em>except</em> for the <code class="docutils literal notranslate"><span class="pre">2</span></code> we have already covered.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">]:</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_to_children</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span><span class="s2">&quot;&lt;digit&gt;&quot;</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0 {&#39;&lt;digit&gt; -&gt; 0&#39;}
1 {&#39;&lt;digit&gt; -&gt; 1&#39;}
2 set()
3 {&#39;&lt;digit&gt; -&gt; 3&#39;}
4 {&#39;&lt;digit&gt; -&gt; 4&#39;}
5 {&#39;&lt;digit&gt; -&gt; 5&#39;}
6 {&#39;&lt;digit&gt; -&gt; 6&#39;}
7 {&#39;&lt;digit&gt; -&gt; 7&#39;}
8 {&#39;&lt;digit&gt; -&gt; 8&#39;}
9 {&#39;&lt;digit&gt; -&gt; 9&#39;}
</pre></div>
</div>
</div>
</div>
<p>This means that whenever choosing an expansion, we can make use of <code class="docutils literal notranslate"><span class="pre">new_child_coverage()</span></code> and choose among the expansions that offer the greatest new (unseen) coverage.</p>
</section>
<section id="adaptive-lookahead">
<h3>Adaptive Lookahead<a class="headerlink" href="#adaptive-lookahead" title="Link to this heading">#</a></h3>
<p>When choosing a child, we do not look out for the maximum overall coverage to be obtained, as this would have expansions with many uncovered possibilities totally dominate other expansions.  Instead, we aim for a <em>breadth-first</em> strategy, first covering all expansions up to a given depth, and only then looking for a greater depth.</p>
<p>The method <code class="docutils literal notranslate"><span class="pre">new_coverages()</span></code> is at the heart of this strategy: Starting with a maximum depth (<code class="docutils literal notranslate"><span class="pre">max_depth</span></code>) of zero, it increases the depth until it finds at least one uncovered expansion.</p>
<section id="excursion-implementing-new-coverage">
<h4>Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">new_coverage()</span></code><a class="headerlink" href="#excursion-implementing-new-coverage" title="Link to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">new_coverages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                      <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> \
            <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return coverage to be obtained for each child at minimum depth&quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">for</span> <span class="n">max_depth</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)):</span>
            <span class="n">new_coverages</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span>
                    <span class="n">symbol</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children_alternatives</span><span class="p">]</span>
            <span class="n">max_new_coverage</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_coverage</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">new_coverage</span> <span class="ow">in</span> <span class="n">new_coverages</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_new_coverage</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Uncovered node found</span>
                <span class="k">return</span> <span class="n">new_coverages</span>

        <span class="c1"># All covered</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="end-of-excursion">
<h4>End of Excursion<a class="headerlink" href="#end-of-excursion" title="Link to this heading">#</a></h4>
</section>
</section>
<section id="all-together">
<h3>All Together<a class="headerlink" href="#all-together" title="Link to this heading">#</a></h3>
<p>We can now define <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code> to make use of this strategy:</p>
<ol class="arabic simple">
<li><p>We determine the possible coverages to be obtained (using <code class="docutils literal notranslate"><span class="pre">new_coverages()</span></code>)</p></li>
<li><p>We (randomly) select among the children which sport the maximum coverage (using <code class="docutils literal notranslate"><span class="pre">choose_uncovered_node_expansion()</span></code>).</p></li>
</ol>
<section id="excursion-implementing-choose-node-expansion">
<h4>Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code><a class="headerlink" href="#excursion-implementing-choose-node-expansion" title="Link to this heading">#</a></h4>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Choose an expansion of `node` among `children_alternatives`.</span>
<span class="sd">           Return `n` such that expanding `children_alternatives[n]`</span>
<span class="sd">           yields the highest additional coverage.&quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">new_coverages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_coverages</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_coverages</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># All expansions covered - use superclass method</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_covered_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

        <span class="n">max_new_coverage</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="k">for</span> <span class="n">cov</span> <span class="ow">in</span> <span class="n">new_coverages</span><span class="p">)</span>

        <span class="n">children_with_max_new_coverage</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                                          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coverages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">max_new_coverage</span><span class="p">]</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coverages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">max_new_coverage</span><span class="p">]</span>

        <span class="c1"># Select a random expansion</span>
        <span class="n">new_children_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_uncovered_node_expansion</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">children_with_max_new_coverage</span><span class="p">)</span>
        <span class="n">new_children</span> <span class="o">=</span> <span class="n">children_with_max_new_coverage</span><span class="p">[</span><span class="n">new_children_index</span><span class="p">]</span>

        <span class="c1"># Save the expansion as covered</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">new_children</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now covered:&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">index_map</span><span class="p">[</span><span class="n">new_children_index</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id1">
<h4>End of Excursion<a class="headerlink" href="#id1" title="Link to this heading">#</a></h4>
<p>With this, our <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> is now complete!  Let us apply it on a series of examples.  On expressions, it quickly covers all digits and operators:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;-4.02 / (1) * +3 + 5.9 / 7 * 8 - 6&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>set()
</pre></div>
</div>
</div>
</div>
<p>On average, it is again faster than the simple strategy:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>50.74
</pre></div>
</div>
</div>
</div>
<p>On the CGI grammar, it takes but a few iterations to cover all letters and digits:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>%18%d03
%c3%94%7f+cd
%a6%b5%e2%5e%4c-54e01a2
%5eb%7cb_ec%a0+
</pre></div>
</div>
</div>
</div>
<p>This improvement can also be seen in comparing the random, expansion-only, and deep foresight strategies on the CGI grammar:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>211.34
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>68.64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>40.38
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="coverage-in-context">
<h2>Coverage in Context<a class="headerlink" href="#coverage-in-context" title="Link to this heading">#</a></h2>
<p>Sometimes, grammar elements are used in more than just one place.  In our expression grammar, for instance, the <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> symbol is used for integer numbers as well as for floating point numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;+&lt;factor&gt;&#39;, &#39;-&lt;factor&gt;&#39;, &#39;(&lt;expr&gt;)&#39;, &#39;&lt;integer&gt;.&lt;integer&gt;&#39;, &#39;&lt;integer&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>Our coverage production, as defined above, will ensure that all <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> expansions (i.e., all <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code> expansions) are covered.  However, the individual digits would be <em>distributed</em> across all occurrences of <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> in the grammar.  If our coverage-based fuzzer produces, say, <code class="docutils literal notranslate"><span class="pre">1234.56</span></code>  and <code class="docutils literal notranslate"><span class="pre">7890</span></code>, we would have full coverage of all digit expansions.  However, <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;.&lt;integer&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> in the <code class="docutils literal notranslate"><span class="pre">&lt;factor&gt;</span></code> expansions above would individually cover only a fraction of the digits.  If floating-point numbers and whole numbers have different functions that read them in, we would like each of these functions to be tested with all digits; maybe we would also like the whole and fractional part of a floating-point number to be tested with all digits each.</p>
<p>Ignoring the context in which a symbol is used (in our case, the various uses of <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;digit&gt;</span></code> in the <code class="docutils literal notranslate"><span class="pre">&lt;factor&gt;</span></code> context) can be useful if we can assume that all occurrences of this symbol are treated alike anyway.  If not, though, one way to ensure that an occurrence of a symbol is systematically covered independently of other occurrences is to assign the occurrence to a new symbol which is a <em>duplicate</em> of the old symbol.  We will first show how to <em>manually</em> create such duplicates, and then a dedicated function which does it automatically.</p>
<section id="extending-grammars-for-context-coverage-manually">
<h3>Extending Grammars for Context Coverage Manually<a class="headerlink" href="#extending-grammars-for-context-coverage-manually" title="Link to this heading">#</a></h3>
<p>As stated above, one simple way to achieve coverage in context is by <em>duplicating</em> symbols as well as the rules they reference to.  For instance, we could replace <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;.&lt;integer&gt;</span></code> by <code class="docutils literal notranslate"><span class="pre">&lt;integer-1&gt;.&lt;integer-2&gt;</span></code> and give <code class="docutils literal notranslate"><span class="pre">&lt;integer-1&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;integer-2&gt;</span></code> the same definitions as the original <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code>.  This would mean that not only all expansions of <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;</span></code>, but also all expansions of <code class="docutils literal notranslate"><span class="pre">&lt;integer-1&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;integer-2&gt;</span></code> would be covered.</p>
<p>Let us illustrate this with actual code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                  <span class="p">{</span>
                                      <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;+&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;-&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;(&lt;expr&gt;)&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer-1&gt;.&lt;integer-2&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer&gt;&quot;</span><span class="p">],</span>
                                      <span class="s2">&quot;&lt;integer-1&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;digit-1&gt;&lt;integer-1&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;digit-1&gt;&quot;</span><span class="p">],</span>
                                      <span class="s2">&quot;&lt;integer-2&gt;&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;&lt;digit-2&gt;&lt;integer-2&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;digit-2&gt;&quot;</span><span class="p">],</span>
                                      <span class="s2">&quot;&lt;digit-1&gt;&quot;</span><span class="p">:</span>
                                      <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span>
                                          <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">],</span>
                                      <span class="s2">&quot;&lt;digit-2&gt;&quot;</span><span class="p">:</span>
                                      <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span>
                                          <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">]</span>
                                  <span class="p">}</span>
                                  <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If we now run our coverage-based fuzzer on the extended grammar, we will cover all digits both of regular integers, and all digits in the whole and fraction part of floating-point numbers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-(43.76 / 8.0 * 5.5 / 6.9 * 6 / 4 + +03)
(90.1 - 1 * 7.3 * 9 + 5 / 8 / 7)
2.8
1.2
10.4
2
4386
7
0
08929.4302
</pre></div>
</div>
</div>
</div>
<p>We see how our “foresighted” coverage fuzzer specifically generates floating-point numbers that cover all digits both in the whole and fractional parts.</p>
</section>
<section id="extending-grammars-for-context-coverage-programmatically">
<h3>Extending Grammars for Context Coverage Programmatically<a class="headerlink" href="#extending-grammars-for-context-coverage-programmatically" title="Link to this heading">#</a></h3>
<p>If we want to enhance coverage in context, manually adapting our grammars may not be the perfect choice, since any change to the grammar will have to be replicated in all duplicates.  Instead, we introduce a function that will do the duplication for us.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">duplicate_context()</span></code> takes a grammar, a symbol in the grammar, and an expansion of this symbol (<code class="docutils literal notranslate"><span class="pre">None</span></code> or not given: all expansions of symbol),  and it changes the expansion to refer to a duplicate of all originally referenced rules.  The idea is that we invoke it as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer&gt;.&lt;integer&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and get a similar result as with our manual changes, above.</p>
<p>Here is the code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">new_symbol</span><span class="p">,</span> <span class="n">unreachable_nonterminals</span>
<span class="kn">from</span> <span class="nn">GrammarFuzzer</span> <span class="kn">import</span> <span class="n">expansion_to_children</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> 
                      <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                      <span class="n">expansion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expansion</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                      <span class="n">depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Duplicate an expansion within a grammar.</span>

<span class="sd">    In the given grammar, take the given expansion of the given `symbol`</span>
<span class="sd">    (if `expansion` is omitted: all symbols), and replace it with a</span>
<span class="sd">    new expansion referring to a duplicate of all originally referenced rules.</span>

<span class="sd">    If `depth` is given, limit duplication to `depth` references</span>
<span class="sd">    (default: unlimited)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orig_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">_duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">orig_grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span>
                       <span class="n">expansion</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="p">{})</span>

    <span class="c1"># After duplication, we may have unreachable rules; delete them</span>
    <span class="k">for</span> <span class="n">nonterminal</span> <span class="ow">in</span> <span class="n">unreachable_nonterminals</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">grammar</span><span class="p">[</span><span class="n">nonterminal</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<section id="excursion-implementing-duplicate-context">
<h4>Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">_duplicate_context()</span></code><a class="headerlink" href="#excursion-implementing-duplicate-context" title="Link to this heading">#</a></h4>
<p>The bulk of the work takes place in this helper function.  The additional parameter <code class="docutils literal notranslate"><span class="pre">seen</span></code> keeps track of symbols already expanded and avoids infinite recursion.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
                       <span class="n">orig_grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
                       <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">expansion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expansion</span><span class="p">],</span>
                       <span class="n">depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                       <span class="n">seen</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function for `duplicate_context()`&quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">expansion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">expansion</span><span class="p">:</span>
            <span class="n">new_expansion</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expansion_to_children</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>                 <span class="c1"># Duplicated already</span>
                    <span class="n">new_expansion</span> <span class="o">+=</span> <span class="n">seen</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># Terminal symbol or end of recursion</span>
                    <span class="n">new_expansion</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>                         <span class="c1"># Nonterminal symbol - duplicate</span>
                    <span class="c1"># Add new symbol with copy of rule</span>
                    <span class="n">new_s</span> <span class="o">=</span> <span class="n">new_symbol</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="n">grammar</span><span class="p">[</span><span class="n">new_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">orig_grammar</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

                    <span class="c1"># Duplicate its expansions recursively</span>
                    <span class="c1"># {**seen, **{s: new_s}} is seen + {s: new_s}</span>
                    <span class="n">_duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">orig_grammar</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">expansion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">seen</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">new_s</span><span class="p">}})</span>
                    <span class="n">new_expansion</span> <span class="o">+=</span> <span class="n">new_s</span>

            <span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_expansion</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id2">
<h4>End of Excursion<a class="headerlink" href="#id2" title="Link to this heading">#</a></h4>
<p>Here’s our above example of how <code class="docutils literal notranslate"><span class="pre">duplicate_context()</span></code> works, now with results.  We let it duplicate the <code class="docutils literal notranslate"><span class="pre">&lt;integer&gt;.&lt;integer&gt;</span></code> expansion in our expression grammar, and obtain a new grammar with an <code class="docutils literal notranslate"><span class="pre">&lt;integer-1&gt;.&lt;integer-2&gt;</span></code> expansion where both <code class="docutils literal notranslate"><span class="pre">&lt;integer-1&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;integer-2&gt;</span></code> refer to copies of the original rules:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer&gt;.&lt;integer&gt;&quot;</span><span class="p">)</span>
<span class="n">dup_expr_grammar</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: [&#39;&lt;expr&gt;&#39;],
 &#39;&lt;expr&gt;&#39;: [&#39;&lt;term&gt; + &lt;expr&gt;&#39;, &#39;&lt;term&gt; - &lt;expr&gt;&#39;, &#39;&lt;term&gt;&#39;],
 &#39;&lt;term&gt;&#39;: [&#39;&lt;factor&gt; * &lt;term&gt;&#39;, &#39;&lt;factor&gt; / &lt;term&gt;&#39;, &#39;&lt;factor&gt;&#39;],
 &#39;&lt;factor&gt;&#39;: [&#39;+&lt;factor&gt;&#39;,
  &#39;-&lt;factor&gt;&#39;,
  &#39;(&lt;expr&gt;)&#39;,
  &#39;&lt;integer-1&gt;.&lt;integer-2&gt;&#39;,
  &#39;&lt;integer&gt;&#39;],
 &#39;&lt;integer&gt;&#39;: [&#39;&lt;digit&gt;&lt;integer&gt;&#39;, &#39;&lt;digit&gt;&#39;],
 &#39;&lt;digit&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;],
 &#39;&lt;integer-1&gt;&#39;: [&#39;&lt;digit-1&gt;&lt;integer-1&gt;&#39;, &#39;&lt;digit-2&gt;&#39;],
 &#39;&lt;digit-1&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;],
 &#39;&lt;digit-2&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;],
 &#39;&lt;integer-2&gt;&#39;: [&#39;&lt;digit-3&gt;&lt;integer-2&gt;&#39;, &#39;&lt;digit-4&gt;&#39;],
 &#39;&lt;digit-3&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;],
 &#39;&lt;digit-4&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]}
</pre></div>
</div>
</div>
</div>
<p>Just like above, using such a grammar for coverage fuzzing will now cover digits in a number of contexts.  To be precise, there are five contexts: Regular integers, as well as single-digit and multi-digit whole and fractional parts of floating-point numbers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(57.5)
2
+-(1 / 3 + 6 / 0 - 7 * 59 * 3 + 8 * 4)
374.88
5.709
0.93
01.1
892.27
219.50
6.636
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">depth</span></code> parameter controls how deep the duplication should go.  Setting <code class="docutils literal notranslate"><span class="pre">depth</span></code> to 1 will duplicate only the next rule:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;factor&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;integer&gt;.&lt;integer&gt;&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dup_expr_grammar</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;start&gt;&#39;: [&#39;&lt;expr&gt;&#39;],
 &#39;&lt;expr&gt;&#39;: [&#39;&lt;term&gt; + &lt;expr&gt;&#39;, &#39;&lt;term&gt; - &lt;expr&gt;&#39;, &#39;&lt;term&gt;&#39;],
 &#39;&lt;term&gt;&#39;: [&#39;&lt;factor&gt; * &lt;term&gt;&#39;, &#39;&lt;factor&gt; / &lt;term&gt;&#39;, &#39;&lt;factor&gt;&#39;],
 &#39;&lt;factor&gt;&#39;: [&#39;+&lt;factor&gt;&#39;,
  &#39;-&lt;factor&gt;&#39;,
  &#39;(&lt;expr&gt;)&#39;,
  &#39;&lt;integer-1&gt;.&lt;integer-2&gt;&#39;,
  &#39;&lt;integer&gt;&#39;],
 &#39;&lt;integer&gt;&#39;: [&#39;&lt;digit&gt;&lt;integer&gt;&#39;, &#39;&lt;digit&gt;&#39;],
 &#39;&lt;digit&gt;&#39;: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;],
 &#39;&lt;integer-1&gt;&#39;: [&#39;&lt;digit&gt;&lt;integer-1&gt;&#39;, &#39;&lt;digit&gt;&#39;],
 &#39;&lt;integer-2&gt;&#39;: [&#39;&lt;digit&gt;&lt;integer-2&gt;&#39;, &#39;&lt;digit&gt;&#39;]}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">depth</span></code> is set to <span class="math notranslate nohighlight">\(\infty\)</span>, indicating unlimited duplication.  True unbounded duplication could lead to problems for a recursive grammar such as <code class="docutils literal notranslate"><span class="pre">EXPR_GRAMMAR</span></code>, so <code class="docutils literal notranslate"><span class="pre">duplicate_context()</span></code> is set to no longer duplicate symbols once duplicated.  Still, if we apply it to duplicate <em>all</em> <code class="docutils literal notranslate"><span class="pre">&lt;expr&gt;</span></code> expansions, we obtain a grammar with no less than 292 rules:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>292
</pre></div>
</div>
</div>
</div>
<p>This gives us almost 2000 expansions to cover:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1981
</pre></div>
</div>
</div>
</div>
<p>Duplicating one more time keeps on both growing the grammar and the coverage requirements:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">&quot;&lt;expr-1&gt;&quot;</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>594
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3994
</pre></div>
</div>
</div>
</div>
<p>At this point, plenty of contexts can be covered individually – for instance, multiplications of elements within additions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;expr&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;term-1&gt; + &lt;expr-4&gt;&#39;, &#39;&lt;term-5&gt; - &lt;expr-8&gt;&#39;, &#39;&lt;term-9&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;term-1-1&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;&lt;factor-1-1&gt; * &lt;term-1-1&gt;&#39;, &#39;&lt;factor-2-1&gt; / &lt;term-1-1&gt;&#39;, &#39;&lt;factor-3-1&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dup_expr_grammar</span><span class="p">[</span><span class="s2">&quot;&lt;factor-1-1&gt;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;+&lt;factor-1-1&gt;&#39;,
 &#39;-&lt;factor-1-1&gt;&#39;,
 &#39;(&lt;expr-1-1&gt;)&#39;,
 &#39;&lt;integer-1-1&gt;.&lt;integer-2-1&gt;&#39;,
 &#39;&lt;integer-3-1&gt;&#39;]
</pre></div>
</div>
</div>
</div>
<p>The resulting grammars may no longer be useful for human maintenance; but running a coverage-driven fuzzer such as <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer()</span></code> will then go and cover all these expansions in all contexts.  If you want to cover elements in many contexts, then <code class="docutils literal notranslate"><span class="pre">duplicate_context()</span></code> followed by a coverage-driven fuzzer is your friend.</p>
</section>
</section>
</section>
<section id="covering-code-by-covering-grammars">
<h2>Covering Code by Covering Grammars<a class="headerlink" href="#covering-code-by-covering-grammars" title="Link to this heading">#</a></h2>
<p>With or without context: By systematically covering all input elements, we get a larger variety in our inputs – but does this translate into a wider variety of program behaviors?  After all, these behaviors are what we want to cover, including the unexpected behaviors.</p>
<p>In a grammar, there are elements that directly correspond to program features.  A program handling arithmetic expressions will have functionality that is directly triggered by individual elements - say, an addition feature triggered by the presence of <code class="docutils literal notranslate"><span class="pre">+</span></code>, subtraction triggered by the presence of <code class="docutils literal notranslate"><span class="pre">-</span></code>, and floating-point arithmetic triggered by the presence of floating-point numbers in the input.</p>
<p>Such a connection between input structure and functionality leads to a strong <em>correlation between grammar coverage and code coverage</em>.  In other words: If we can achieve a high grammar coverage, this also leads to a high code coverage.</p>
<section id="cgi-grammars">
<h3>CGI Grammars<a class="headerlink" href="#cgi-grammars" title="Link to this heading">#</a></h3>
<p>Let us explore this relationship on one of our grammars – say, the CGI decoder from the <a class="reference internal" href="Coverage.html"><span class="std std-doc">chapter on coverage</span></a>.</p>
<section id="excursion-creating-the-plot">
<h4>Excursion: Creating the Plot<a class="headerlink" href="#excursion-creating-the-plot" title="Link to this heading">#</a></h4>
<p>We compute a mapping <code class="docutils literal notranslate"><span class="pre">coverages</span></code> where in <code class="docutils literal notranslate"><span class="pre">coverages[x]</span></code> = <code class="docutils literal notranslate"><span class="pre">{y_1,</span> <span class="pre">y_2,</span> <span class="pre">...}</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is the grammar coverage obtained, and <code class="docutils literal notranslate"><span class="pre">y_n</span></code> is the code coverage obtained for the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th run.</p>
<p>We first compute the maximum coverage, as in the <a class="reference internal" href="Coverage.html"><span class="std std-doc">chapter on coverage</span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Coverage</span> <span class="kn">import</span> <span class="n">Coverage</span><span class="p">,</span> <span class="n">cgi_decode</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov_max</span><span class="p">:</span>
    <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">&#39;%20&#39;</span><span class="p">)</span>
    <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">&#39;%?a&#39;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we run our experiment:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">,</span> <span class="n">max_nonterminals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">coverages</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
    <span class="n">overall_cov</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">max_cov</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
            <span class="n">cgi_decode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">overall_cov</span> <span class="o">|=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overall_cov</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov_max</span><span class="o">.</span><span class="n">coverage</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">:</span>
            <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We compute the averages for the <code class="docutils literal notranslate"><span class="pre">y</span></code>-values:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coverages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>and create a scatter plot:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">mtick</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;CGI coverage&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Coverage of cgi_decode() vs. grammar coverage&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;grammar coverage (expansions)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;code coverage (lines)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;code coverage (lines)&#39;)
</pre></div>
</div>
<img alt="_images/28a9dba2aa49257fe327744b8feacedcddd352cfb11be63127d9c471cca0bd3e.png" src="_images/28a9dba2aa49257fe327744b8feacedcddd352cfb11be63127d9c471cca0bd3e.png" />
</div>
</div>
</section>
<section id="id3">
<h4>End of Excursion<a class="headerlink" href="#id3" title="Link to this heading">#</a></h4>
<p>This scatter plot shows the relationship between grammar coverage (X axis) and code coverage (Y axis).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/6cff1d032d3a1eb66ca3f38e3e9ff7d79e52656a6b1156287a8dfec0787c6556.png" src="_images/6cff1d032d3a1eb66ca3f38e3e9ff7d79e52656a6b1156287a8dfec0787c6556.png" />
</div>
</div>
<p>We see that the higher the grammar coverage, the higher the code coverage.</p>
<p>This also translates into a correlation coefficient of about 0.9, indicating a strong correlation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.        , 0.81663071],
       [0.81663071, 1.        ]])
</pre></div>
</div>
</div>
</div>
<p>This is also confirmed by the Spearman rank correlation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">spearmanr</span>  <span class="c1"># type: ignore</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spearmanr</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SignificanceResult(statistic=np.float64(0.9477544699285101), pvalue=np.float64(2.2771918715723359e-10))
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="url-grammars">
<h3>URL Grammars<a class="headerlink" href="#url-grammars" title="Link to this heading">#</a></h3>
<p>Let us repeat this experiment on URL grammars.  We use the same code as above, except for exchanging the grammars and the function in place:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
</pre></div>
</div>
</div>
</div>
<section id="id4">
<h4>Excursion: Creating the Plot<a class="headerlink" href="#id4" title="Link to this heading">#</a></h4>
<p>Again, we first compute the maximum coverage, making an educated guess as in the <a class="reference internal" href="Coverage.html"><span class="std std-doc">chapter on coverage</span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov_max</span><span class="p">:</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;http://foo.bar/path&quot;</span><span class="p">)</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;https://foo.bar#fragment&quot;</span><span class="p">)</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;ftp://user:password@foo.bar?query=value&quot;</span><span class="p">)</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;ftps://127.0.0.1/?x=1&amp;y=2&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here comes the actual experiment:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">URL_GRAMMAR</span><span class="p">,</span> <span class="n">max_nonterminals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">coverages</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
    <span class="n">overall_cov</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
            <span class="n">urlparse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">overall_cov</span> <span class="o">|=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overall_cov</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov_max</span><span class="o">.</span><span class="n">coverage</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">:</span>
            <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coverages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;URL coverage&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Coverage of urlparse() vs. grammar coverage&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;grammar coverage (expansions)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;code coverage (lines)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;code coverage (lines)&#39;)
</pre></div>
</div>
<img alt="_images/9f022018d3eb0c38f804e040fe44ff55185ddad1caa49ae1a39ff3c6885bef84.png" src="_images/9f022018d3eb0c38f804e040fe44ff55185ddad1caa49ae1a39ff3c6885bef84.png" />
</div>
</div>
</section>
<section id="id5">
<h4>End of Excursion<a class="headerlink" href="#id5" title="Link to this heading">#</a></h4>
<p>This scatter plot shows the relationship between grammar coverage (X axis) and code coverage (Y axis).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/03b1f1ca5d1914c2d78ab06bea3c33d48fa81e78af105465505e609ee586c130.png" src="_images/03b1f1ca5d1914c2d78ab06bea3c33d48fa81e78af105465505e609ee586c130.png" />
</div>
</div>
<p>Here, we have an even stronger correlation of more than .95:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.       , 0.8819171],
       [0.8819171, 1.       ]])
</pre></div>
</div>
</div>
</div>
<p>This is also confirmed by the Spearman rank correlation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">spearmanr</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SignificanceResult(statistic=np.float64(0.9486832980505139), pvalue=np.float64(0.05131670194948612))
</pre></div>
</div>
</div>
</div>
<p>We conclude: If one wants to obtain high code coverage, it is a good idea to strive for high grammar coverage first.</p>
</section>
</section>
<section id="will-this-always-work">
<h3>Will this always work?<a class="headerlink" href="#will-this-always-work" title="Link to this heading">#</a></h3>
<p>The correlation observed for the CGI and URL examples will not hold for every program and every structure.</p>
<section id="equivalent-elements">
<h4>Equivalent Elements<a class="headerlink" href="#equivalent-elements" title="Link to this heading">#</a></h4>
<p>First, some grammar elements are treated uniformly by a program even though the grammar sees them as different symbols.  In the host name of a URL, for instance, we can have many characters, although a URL-handling program treats them all the same.  Likewise, individual digits, once composed into a number, make less of a difference than the value of the number itself.  Hence, achieving variety in digits or characters will not necessarily yield a large difference in functionality.</p>
<p>This problem can be addressed by <em>differentiating elements dependent on their context</em>, and covering alternatives for each context, as discussed above.  The key is to identify the contexts in which variety is required, and those where it is not.</p>
</section>
<section id="deep-data-processing">
<h4>Deep Data Processing<a class="headerlink" href="#deep-data-processing" title="Link to this heading">#</a></h4>
<p>Second, the way the data is processed can make a large difference.  Consider the input to a <em>media player</em>, consisting of compressed media data.  While processing the media data, the media player will show differences in behavior (notably in its output), but these differences cannot be directly triggered through individual elements of the media data.  Likewise, a <em>machine learner</em> that is trained on a large set of inputs typically will not have its behavior controlled by a single syntactic element of the input.  (Well, it could, but then, we would not need a machine learner.)  In these cases of “deep” data processing, achieving structural coverage in the grammar will not necessarily induce code coverage.</p>
<p>One way to address this problem is to achieve not only <em>syntactic</em>, but actually <em>semantic</em> variety.  In the <a class="reference internal" href="GeneratorGrammarFuzzer.html"><span class="std std-doc">chapter on fuzzing with constraints</span></a>, we will see how to specifically generate and filter input values, especially numerical values.  Such generators can also be applied in context, such that each and every facet of the input can be controlled individually.
Also, in the above examples, <em>some</em> parts of the input can still be covered structurally: <em>Metadata</em> (such as author name or composer for the media player) or <em>configuration data</em> (such as settings for the machine learner) can and should be covered systematically; we will see how this is done <a class="reference internal" href="ConfigurationFuzzer.html"><span class="std std-doc">in the chapter on “Configuration fuzzing”</span></a>.</p>
</section>
</section>
</section>
<section id="id6">
<h2>Synopsis<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>This chapter introduces <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code>, an efficient grammar fuzzer extending <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code> from the <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">chapter on efficient grammar fuzzing</span></a>.  It strives to <em>cover all expansions at least once,</em> thus ensuring coverage of functionality.</p>
<p>In the following example, for instance, we use <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> to produce an expression. We see that the resulting expression covers all digits and all operators in a single expression.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;-(2 + 3) * 4.5 / 6 - 2.0 / +8 + 7 + 3&#39;
</pre></div>
</div>
</div>
</div>
<p>After fuzzing, the <code class="docutils literal notranslate"><span class="pre">expansion_coverage()</span></code> method returns a mapping of grammar expansions covered.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;&lt;digit&gt; -&gt; 0&#39;,
 &#39;&lt;digit&gt; -&gt; 1&#39;,
 &#39;&lt;digit&gt; -&gt; 2&#39;,
 &#39;&lt;digit&gt; -&gt; 3&#39;,
 &#39;&lt;digit&gt; -&gt; 4&#39;,
 &#39;&lt;digit&gt; -&gt; 5&#39;,
 &#39;&lt;digit&gt; -&gt; 6&#39;,
 &#39;&lt;digit&gt; -&gt; 7&#39;,
 &#39;&lt;digit&gt; -&gt; 8&#39;,
 &#39;&lt;digit&gt; -&gt; 9&#39;,
 &#39;&lt;expr&gt; -&gt; &lt;term&gt;&#39;,
 &#39;&lt;expr&gt; -&gt; &lt;term&gt; + &lt;expr&gt;&#39;,
 &#39;&lt;expr&gt; -&gt; &lt;term&gt; - &lt;expr&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; (&lt;expr&gt;)&#39;,
 &#39;&lt;factor&gt; -&gt; +&lt;factor&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; -&lt;factor&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; &lt;integer&gt;&#39;,
 &#39;&lt;factor&gt; -&gt; &lt;integer&gt;.&lt;integer&gt;&#39;,
 &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&#39;,
 &#39;&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;&#39;,
 &#39;&lt;start&gt; -&gt; &lt;expr&gt;&#39;,
 &#39;&lt;term&gt; -&gt; &lt;factor&gt;&#39;,
 &#39;&lt;term&gt; -&gt; &lt;factor&gt; * &lt;term&gt;&#39;,
 &#39;&lt;term&gt; -&gt; &lt;factor&gt; / &lt;term&gt;&#39;}
</pre></div>
</div>
</div>
</div>
<p>Subsequent calls to <code class="docutils literal notranslate"><span class="pre">fuzz()</span></code> will go for further coverage (i.e., covering the other area code digits, for example); a call to <code class="docutils literal notranslate"><span class="pre">reset()</span></code> clears the recorded coverage, starting anew.</p>
<p>Since such coverage in inputs also yields higher code coverage, <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> is a recommended extension to <code class="docutils literal notranslate"><span class="pre">GrammarFuzzer</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="kn">from</span> <span class="nn">ClassDiagram</span> <span class="kn">import</span> <span class="n">display_class_hierarchy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># ignore</span>
<span class="n">display_class_hierarchy</span><span class="p">([</span><span class="n">GrammarCoverageFuzzer</span><span class="p">],</span>
                        <span class="n">public_methods</span><span class="o">=</span><span class="p">[</span>
                            <span class="n">Fuzzer</span><span class="o">.</span><span class="n">run</span><span class="p">,</span>
                            <span class="n">Fuzzer</span><span class="o">.</span><span class="n">runs</span><span class="p">,</span>
                            <span class="n">GrammarFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span>
                            <span class="n">GrammarFuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">,</span>
                            <span class="n">GrammarFuzzer</span><span class="o">.</span><span class="n">fuzz_tree</span><span class="p">,</span>
                            <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">,</span>
                            <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">,</span>
                            <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">,</span>
                            <span class="n">GrammarCoverageFuzzer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span>
                            <span class="n">GrammarCoverageFuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">,</span>
                            <span class="n">GrammarCoverageFuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">,</span>
                        <span class="p">],</span>
                        <span class="n">types</span><span class="o">=</span><span class="p">{</span>
                            <span class="s1">&#39;DerivationTree&#39;</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                            <span class="s1">&#39;Expansion&#39;</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">,</span>
                            <span class="s1">&#39;Grammar&#39;</span><span class="p">:</span> <span class="n">Grammar</span>
                        <span class="p">},</span>
                        <span class="n">project</span><span class="o">=</span><span class="s1">&#39;fuzzingbook&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="346pt" height="582pt"
 viewBox="0.00 0.00 345.75 582.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 578)">
<g id="a_graph0"><a xlink:title="GrammarCoverageFuzzer class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-578 341.75,-578 341.75,4 -4,4"/>
</a>
</g>
<!-- GrammarCoverageFuzzer -->
<g id="node1" class="node">
<title>GrammarCoverageFuzzer</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class GrammarCoverageFuzzer:&#10;Produce from grammars, aiming for coverage of all expansions.">
<polygon fill="none" stroke="black" points="27.38,-0.5 27.38,-85.5 200.88,-85.5 200.88,-0.5 27.38,-0.5"/>
<text text-anchor="start" x="35.38" y="-69.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="27.38,-59.5 200.88,-59.5"/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="GrammarCoverageFuzzer">
<g id="a_node1_1"><a xlink:href="#" xlink:title="_new_child_coverage(self, children: List[DerivationTree], max_depth: Union[int, float]) &#45;&gt; Set[str]">
<text text-anchor="start" x="45.12" y="-46" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">_new_child_coverage()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) &#45;&gt; int:&#10;Choose an expansion of `node` among `children_alternatives`.&#10;Return `n` such that expanding `children_alternatives[n]`&#10;yields the highest additional coverage.">
<text text-anchor="start" x="45.12" y="-34.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
<g id="a_node1_3"><a xlink:href="#" xlink:title="new_child_coverage(self, symbol: str, children: List[DerivationTree], max_depth: Union[int, float] = inf) &#45;&gt; Set[str]:&#10;Return new coverage that would be obtained&#10;by expanding (`symbol`, `children`)">
<text text-anchor="start" x="45.12" y="-20.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">new_child_coverage()</text>
</a>
</g>
<g id="a_node1_4"><a xlink:href="#" xlink:title="new_coverages(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) &#45;&gt; Optional[List[Set[str]]]:&#10;Return coverage to be obtained for each child at minimum depth">
<text text-anchor="start" x="45.12" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">new_coverages()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- SimpleGrammarCoverageFuzzer -->
<g id="node2" class="node">
<title>SimpleGrammarCoverageFuzzer</title>
<g id="a_node2"><a xlink:href="#" xlink:title="class SimpleGrammarCoverageFuzzer:&#10;When choosing expansions, prefer expansions not covered.">
<polygon fill="none" stroke="black" points="6.75,-122.5 6.75,-194.75 221.5,-194.75 221.5,-122.5 6.75,-122.5"/>
<text text-anchor="start" x="14.75" y="-178.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="6.75,-168.75 221.5,-168.75"/>
<g id="a_node2_5"><a xlink:href="#" xlink:title="SimpleGrammarCoverageFuzzer">
<g id="a_node2_6"><a xlink:href="#" xlink:title="choose_covered_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) &#45;&gt; int:&#10;Return index of expansion in _covered_ `children_alternatives`&#10;to be selected.&#10;To be overloaded in subclasses.">
<text text-anchor="start" x="15.12" y="-156.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_covered_node_expansion()</text>
</a>
</g>
<g id="a_node2_7"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) &#45;&gt; int:&#10;Return index of expansion in `children_alternatives` to be selected.&#10;Picks uncovered expansions, if any.">
<text text-anchor="start" x="15.12" y="-143.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
<g id="a_node2_8"><a xlink:href="#" xlink:title="choose_uncovered_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) &#45;&gt; int:&#10;Return index of expansion in _uncovered_ `children_alternatives`&#10;to be selected.&#10;To be overloaded in subclasses.">
<text text-anchor="start" x="15.12" y="-130.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_uncovered_node_expansion()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;SimpleGrammarCoverageFuzzer -->
<g id="edge1" class="edge">
<title>GrammarCoverageFuzzer&#45;&gt;SimpleGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M114.12,-85.99C114.12,-94.06 114.12,-102.57 114.12,-110.79"/>
<polygon fill="none" stroke="black" points="110.63,-110.63 114.13,-120.63 117.63,-110.63 110.63,-110.63"/>
</g>
<!-- TrackingGrammarCoverageFuzzer -->
<g id="node3" class="node">
<title>TrackingGrammarCoverageFuzzer</title>
<g id="a_node3"><a xlink:href="#" xlink:title="class TrackingGrammarCoverageFuzzer:&#10;Track grammar coverage during production">
<polygon fill="none" stroke="black" points="0,-231.75 0,-367.75 228.25,-367.75 228.25,-231.75 0,-231.75"/>
<text text-anchor="start" x="8" y="-351.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">TrackingGrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="0,-341.75 228.25,-341.75"/>
<g id="a_node3_9"><a xlink:href="#" xlink:title="TrackingGrammarCoverageFuzzer">
<g id="a_node3_10"><a xlink:href="#" xlink:title="__init__(self, *args, **kwargs) &#45;&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="30.12" y="-329.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node3_11"><a xlink:href="#" xlink:title="expansion_coverage(self) &#45;&gt; Set[str]:&#10;Return the set of covered expansions as strings SYMBOL &#45;&gt; EXPANSION">
<text text-anchor="start" x="30.12" y="-316.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">expansion_coverage()</text>
</a>
</g>
<g id="a_node3_12"><a xlink:href="#" xlink:title="max_expansion_coverage(self, symbol: Optional[str] = None, max_depth: Union[int, float] = inf) &#45;&gt; Set[str]:&#10;Return set of all expansions in a grammar&#10;starting with `symbol` (default: start symbol).&#10;If `max_depth` is given, expand only to that depth.">
<text text-anchor="start" x="30.12" y="-303.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">max_expansion_coverage()</text>
</a>
</g>
<g id="a_node3_13"><a xlink:href="#" xlink:title="missing_expansion_coverage(self) &#45;&gt; Set[str]:&#10;Return expansions not covered yet">
<text text-anchor="start" x="30.12" y="-291" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">missing_expansion_coverage()</text>
</a>
</g>
<g id="a_node3_14"><a xlink:href="#" xlink:title="reset_coverage(self) &#45;&gt; None:&#10;Clear coverage info tracked so far">
<text text-anchor="start" x="30.12" y="-278.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">reset_coverage()</text>
</a>
</g>
<g id="a_node3_15"><a xlink:href="#" xlink:title="_max_expansion_coverage(self, symbol: str, max_depth: Union[int, float]) &#45;&gt; Set[str]">
<text text-anchor="start" x="30.12" y="-264.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">_max_expansion_coverage()</text>
</a>
</g>
<g id="a_node3_16"><a xlink:href="#" xlink:title="add_coverage(self, symbol: str, new_child: Union[str, Tuple[str, Dict[str, Any]], List[DerivationTree]]) &#45;&gt; None">
<text text-anchor="start" x="30.12" y="-251.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_coverage()</text>
</a>
</g>
<g id="a_node3_17"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) &#45;&gt; int:&#10;Return index of expansion in `children_alternatives` to be selected.&#10;&#39;children_alternatives`: a list of possible children for `node`.&#10;Defaults to random. To be overloaded in subclasses.">
<text text-anchor="start" x="30.12" y="-240" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- SimpleGrammarCoverageFuzzer&#45;&gt;TrackingGrammarCoverageFuzzer -->
<g id="edge2" class="edge">
<title>SimpleGrammarCoverageFuzzer&#45;&gt;TrackingGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M114.12,-195.09C114.12,-202.82 114.12,-211.29 114.12,-219.95"/>
<polygon fill="none" stroke="black" points="110.63,-219.89 114.13,-229.89 117.63,-219.89 110.63,-219.89"/>
</g>
<!-- GrammarFuzzer -->
<g id="node4" class="node">
<title>GrammarFuzzer</title>
<g id="a_node4"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="class GrammarFuzzer:&#10;Produce strings from grammars efficiently, using derivation trees.">
<polygon fill="none" stroke="black" points="56.25,-404.75 56.25,-477 172,-477 172,-404.75 56.25,-404.75"/>
<text text-anchor="start" x="64.25" y="-460.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarFuzzer</text>
<polyline fill="none" stroke="black" points="56.25,-451 172,-451"/>
<g id="a_node4_18"><a xlink:href="#" xlink:title="GrammarFuzzer">
<g id="a_node4_19"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol: str = &#39;&lt;start&gt;&#39;, min_nonterminals: int = 0, max_nonterminals: int = 10, disp: bool = False, log: Union[bool, int] = False) &#45;&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="81.12" y="-438.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node4_20"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="fuzz(self) &#45;&gt; str:&#10;Produce a string from the grammar.">
<text text-anchor="start" x="81.12" y="-425.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz()</text>
</a>
</g>
<g id="a_node4_21"><a xlink:href="GrammarFuzzer.ipynb" xlink:title="fuzz_tree(self) &#45;&gt; DerivationTree:&#10;Produce a derivation tree from the grammar.">
<text text-anchor="start" x="81.12" y="-413" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">fuzz_tree()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- TrackingGrammarCoverageFuzzer&#45;&gt;GrammarFuzzer -->
<g id="edge3" class="edge">
<title>TrackingGrammarCoverageFuzzer&#45;&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M114.12,-367.87C114.12,-376.36 114.12,-384.91 114.12,-393"/>
<polygon fill="none" stroke="black" points="110.63,-392.94 114.13,-402.94 117.63,-392.94 110.63,-392.94"/>
</g>
<!-- Fuzzer -->
<g id="node5" class="node">
<title>Fuzzer</title>
<g id="a_node5"><a xlink:href="Fuzzer.ipynb" xlink:title="class Fuzzer:&#10;Base class for fuzzers.">
<polygon fill="none" stroke="black" points="85.5,-514 85.5,-573.5 142.75,-573.5 142.75,-514 85.5,-514"/>
<text text-anchor="start" x="93.5" y="-557.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
<polyline fill="none" stroke="black" points="85.5,-547.5 142.75,-547.5"/>
<g id="a_node5_22"><a xlink:href="#" xlink:title="Fuzzer">
<g id="a_node5_23"><a xlink:href="Fuzzer.ipynb" xlink:title="run(self, runner: Fuzzer.Runner = &lt;Fuzzer.Runner object at 0x11ab1b950&gt;) &#45;&gt; Tuple[subprocess.CompletedProcess, str]:&#10;Run `runner` with fuzz input">
<text text-anchor="start" x="96.12" y="-535" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">run()</text>
</a>
</g>
<g id="a_node5_24"><a xlink:href="Fuzzer.ipynb" xlink:title="runs(self, runner: Fuzzer.Runner = &lt;Fuzzer.PrintRunner object at 0x11ab1b590&gt;, trials: int = 10) &#45;&gt; List[Tuple[subprocess.CompletedProcess, str]]:&#10;Run `runner` with fuzz input, `trials` times">
<text text-anchor="start" x="96.12" y="-522.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">runs()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;Fuzzer -->
<g id="edge4" class="edge">
<title>GrammarFuzzer&#45;&gt;Fuzzer</title>
<path fill="none" stroke="black" d="M114.12,-477.44C114.12,-485.54 114.12,-494.19 114.12,-502.47"/>
<polygon fill="none" stroke="black" points="110.63,-502.31 114.13,-512.31 117.63,-502.31 110.63,-502.31"/>
</g>
<!-- Legend -->
<g id="node6" class="node">
<title>Legend</title>
<text text-anchor="start" x="218.5" y="-59" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="218.5" y="-49" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="224.5" y="-49" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="218.5" y="-39" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="224.5" y="-39" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="218.5" y="-29" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="224.5" y="-29" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="218.5" y="-19.95" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</div></div>
</div>
</section>
<section id="lessons-learned">
<h2>Lessons Learned<a class="headerlink" href="#lessons-learned" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Achieving <em>grammar coverage</em> quickly results in a large variety of inputs.</p></li>
<li><p>Duplicating grammar rules allows covering elements in specific <em>contexts</em>.</p></li>
<li><p>Achieving grammar coverage can help in obtaining <em>code coverage</em>.</p></li>
</ul>
</section>
<section id="next-steps">
<h2>Next Steps<a class="headerlink" href="#next-steps" title="Link to this heading">#</a></h2>
<p>From here, you can learn how to</p>
<ul class="simple">
<li><p><a class="reference internal" href="ConfigurationFuzzer.html"><span class="std std-doc">use grammar coverage to systematically test configurations</span></a>.</p></li>
</ul>
</section>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Link to this heading">#</a></h2>
<p>The idea of ensuring that each expansion in the grammar is used at least once goes back to Burkhardt \cite{Burkhardt1967}, to be later rediscovered by Paul Purdom \cite{Purdom1972}.  The relation between grammar coverage and code coverage was discovered by Nikolas Havrikov, who explores it in his PhD thesis.</p>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">#</a></h2>
<section id="exercise-1-testing-ls">
<h3>Exercise 1: Testing ls<a class="headerlink" href="#exercise-1-testing-ls" title="Link to this heading">#</a></h3>
<p>Consider the Unix <code class="docutils literal notranslate"><span class="pre">ls</span></code> program, used to list the contents of a directory.  Create a grammar for invoking <code class="docutils literal notranslate"><span class="pre">ls</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">LS_EBNF_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;-&lt;options&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;options&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;option&gt;*&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;option&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;@&#39;</span><span class="p">,</span>
                 <span class="c1"># many more</span>
                 <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">LS_EBNF_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">GrammarCoverageFuzzer</span></code> to test all options.  Be sure to invoke <code class="docutils literal notranslate"><span class="pre">ls</span></code> with each option set.</p>
<p><strong>Solution.</strong>  We can copy the set of option characters right from the manual page:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Grammars</span> <span class="kn">import</span> <span class="n">convert_ebnf_grammar</span><span class="p">,</span> <span class="n">srange</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">LS_EBNF_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;&lt;start&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;-&lt;options&gt;&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;options&gt;&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&lt;option&gt;*&#39;</span><span class="p">],</span>
    <span class="s1">&#39;&lt;option&gt;&#39;</span><span class="p">:</span> <span class="n">srange</span><span class="p">(</span><span class="s2">&quot;ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">LS_EBNF_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">LS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">LS_EBNF_GRAMMAR</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">Fuzzer</span> <span class="kn">import</span> <span class="n">ProgramRunner</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">LS_GRAMMAR</span><span class="p">,</span> <span class="n">max_nonterminals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">invocation</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span> <span class="n">invocation</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;; &quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">invocation</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="n">ProgramRunner</span><span class="p">([</span><span class="s2">&quot;ls&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">ls</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ls -; ls -Wgx; ls -qe; ls -1cC; ls -tL; ls -slUn; ls -imF; ls -SB; ls -PTo; ls -hHb; ls -pdk@; ls -AO; ls -rG; ls -wa; ls -fu; ls -Rc; 
</pre></div>
</div>
</div>
</div>
<p>By setting <code class="docutils literal notranslate"><span class="pre">max_nonterminals</span></code> to other values, you can control how many options <code class="docutils literal notranslate"><span class="pre">ls</span></code> should be invoked with.  We will see more of such examples in the <a class="reference internal" href="ConfigurationFuzzer.html"><span class="std std-doc">chapter on configuration testing</span></a>.</p>
</section>
<section id="exercise-2-caching">
<h3>Exercise 2: Caching<a class="headerlink" href="#exercise-2-caching" title="Link to this heading">#</a></h3>
<p>The value of <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code> depends on the grammar only.  Change the implementation such that the values are precomputed for each symbol and depth upon initialization (<code class="docutils literal notranslate"><span class="pre">__init__()</span></code>); this way, <code class="docutils literal notranslate"><span class="pre">max_expansion_coverage()</span></code> can simply look up the value in the table.</p>
<p><strong>Solution.</strong> This is like exercise 1 and 2 <a class="reference internal" href="GrammarFuzzer.html"><span class="std std-doc">in the chapter on efficient grammar fuzzing</span></a>; you can implement a similar solution here.</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="GrammarFuzzer.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Efficient Grammar Fuzzing</p>
      </div>
    </a>
    <a class="right-next"
       href="Parser.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Parsing Inputs</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synopsis">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#covering-grammar-elements">Covering Grammar Elements</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tracking-grammar-coverage">Tracking Grammar Coverage</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#keeping-track-of-expansions">Keeping Track of Expansions</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#computing-possible-expansions">Computing Possible Expansions</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#tracking-expansions-while-fuzzing">Tracking Expansions while Fuzzing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#putting-things-together">Putting Things Together</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#covering-grammar-expansions">Covering Grammar Expansions</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deep-foresight">Deep Foresight</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determining-maximum-per-symbol-coverage">Determining Maximum per-Symbol Coverage</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#determining-yet-uncovered-children">Determining yet Uncovered Children</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adaptive-lookahead">Adaptive Lookahead</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-new-coverage">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">new_coverage()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-excursion">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#all-together">All Together</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-choose-node-expansion">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">choose_node_expansion()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">End of Excursion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coverage-in-context">Coverage in Context</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extending-grammars-for-context-coverage-manually">Extending Grammars for Context Coverage Manually</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#extending-grammars-for-context-coverage-programmatically">Extending Grammars for Context Coverage Programmatically</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-implementing-duplicate-context">Excursion: Implementing <code class="docutils literal notranslate"><span class="pre">_duplicate_context()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">End of Excursion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#covering-code-by-covering-grammars">Covering Code by Covering Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cgi-grammars">CGI Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#excursion-creating-the-plot">Excursion: Creating the Plot</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#url-grammars">URL Grammars</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">Excursion: Creating the Plot</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">End of Excursion</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#will-this-always-work">Will this always work?</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#equivalent-elements">Equivalent Elements</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#deep-data-processing">Deep Data Processing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">Synopsis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lessons-learned">Lessons Learned</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#next-steps">Next Steps</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#background">Background</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-1-testing-ls">Exercise 1: Testing ls</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#exercise-2-caching">Exercise 2: Caching</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2021-2025 CISPA Helmholtz Center for Information Security (www.cispa.de); © Copyright 2018-2020 Saarland University, authors, and contributors. All Rights Reserved.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>